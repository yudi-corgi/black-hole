const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":149,\"nextId\":149,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-09312a04\",\"2\":\"v-09312a04#序\",\"3\":\"v-09312a04#基于-mybatisplus-jackson-实现枚举出入参转换\",\"4\":\"v-09312a04#其它\",\"5\":\"v-09312a04@0\",\"6\":\"v-09312a04@1\",\"7\":\"v-e005054c\",\"8\":\"v-e005054c#前言\",\"9\":\"v-e005054c#基础\",\"10\":\"v-e005054c#结构\",\"11\":\"v-e005054c#属性\",\"12\":\"v-e005054c#常用方法\",\"13\":\"v-e005054c#方法原理\",\"14\":\"v-e005054c#put-方法实现\",\"15\":\"v-e005054c#get-方法实现\",\"16\":\"v-e005054c#resize-transfer-方法实现\",\"17\":\"v-e005054c#补充\",\"18\":\"v-e005054c#与-hashtable-的区别\",\"19\":\"v-e005054c#hashmap-死链问题\",\"20\":\"v-e005054c#总结\",\"21\":\"v-e005054c@0\",\"22\":\"v-e005054c@1\",\"23\":\"v-71db46f9\",\"24\":\"v-71db46f9#前言\",\"25\":\"v-71db46f9#死链原因和解决方法\",\"26\":\"v-71db46f9#结构变化\",\"27\":\"v-71db46f9#链表与红黑树转换时机\",\"28\":\"v-71db46f9#原理解析\",\"29\":\"v-71db46f9#node-k-v-和-treenode-k-v\",\"30\":\"v-71db46f9#put-方法\",\"31\":\"v-71db46f9#get-方法\",\"32\":\"v-71db46f9#hash-方法\",\"33\":\"v-71db46f9#resize-方法\",\"34\":\"v-71db46f9#关于红黑树\",\"35\":\"v-71db46f9#尾声\",\"36\":\"v-71db46f9@0\",\"37\":\"v-71db46f9@1\",\"38\":\"v-a973e02c\",\"39\":\"v-a973e02c#什么是类的加载\",\"40\":\"v-a973e02c#类的加载过程\",\"41\":\"v-a973e02c#加载\",\"42\":\"v-a973e02c#连接\",\"43\":\"v-a973e02c#验证-确保被加载的类的正确性\",\"44\":\"v-a973e02c#准备-为类的静态变量分配内存-并将其初始化为默认值\",\"45\":\"v-a973e02c#解析-把常量池内的符号引用转换为直接引用\",\"46\":\"v-a973e02c#初始化\",\"47\":\"v-a973e02c#类加载器\",\"48\":\"v-a973e02c#双亲委派模型\",\"49\":\"v-a973e02c#自定义类加载器\",\"50\":\"v-a973e02c#总结\",\"51\":\"v-a973e02c#参考资料\",\"52\":\"v-a973e02c@0\",\"53\":\"v-a973e02c@1\",\"54\":\"v-3d8443f8\",\"55\":\"v-3d8443f8#什么是-jvm\",\"56\":\"v-3d8443f8#概念\",\"57\":\"v-3d8443f8#理解\",\"58\":\"v-3d8443f8#jvm-内存模型\",\"59\":\"v-3d8443f8#程序计数器-私有\",\"60\":\"v-3d8443f8#虚拟机栈-私有\",\"61\":\"v-3d8443f8#栈帧-stack-frame-结构\",\"62\":\"v-3d8443f8#异常-exception\",\"63\":\"v-3d8443f8#本地方法栈-私有\",\"64\":\"v-3d8443f8#堆-共享\",\"65\":\"v-3d8443f8#异常-exception-1\",\"66\":\"v-3d8443f8#方法区-共享\",\"67\":\"v-3d8443f8#运行时常量池\",\"68\":\"v-3d8443f8#补充\",\"69\":\"v-3d8443f8#总结\",\"70\":\"v-3d8443f8#参考资料\",\"71\":\"v-3d8443f8#花絮\",\"72\":\"v-3d8443f8@0\",\"73\":\"v-3d8443f8@1\",\"74\":\"v-348f9061\",\"75\":\"v-348f9061#写在前头\",\"76\":\"v-348f9061#为什么-2023-年-oauth-仍然很难-why-is-oauth-still-hard-in-2023\",\"77\":\"v-348f9061#oauth-实践-oauth-in-practice\",\"78\":\"v-348f9061#问题-1-oauth-标准太大且复杂-problem-1-the-oauth-standard-is-just-too-big-and-complex\",\"79\":\"v-348f9061#问题-2-每个人的-oauth-都有细微的差别-problem-2-everybody-s-oauth-is-different-in-subtle-ways\",\"80\":\"v-348f9061#问题-3-许多-api-向-oauth-添加非标准扩展-problem-3-many-apis-add-nonstandard-extensions-to-oauth\",\"81\":\"v-348f9061#问题-4-invalid-request-——调试-oauth-流程很困难-problem-4-invalid-request-—-debugging-oauth-flows-is-hard\",\"82\":\"v-348f9061#问题-5-基于-api-构建的审批繁琐-problem-5-cumbersome-approvals-to-build-on-top-of-apis\",\"83\":\"v-348f9061#问题-6-oauth-安全性很困难且目标不断变化-problem-6-oauth-security-is-hard-and-a-moving-target\",\"84\":\"v-348f9061#最后但并非最不重要的一点-有些事情我们还没有讨论过-last-but-not-least-some-things-we-haven-t-talked-about-yet\",\"85\":\"v-348f9061#有更好的方法吗-a-better-way\",\"86\":\"v-348f9061@0\",\"87\":\"v-348f9061@1\",\"88\":\"v-4c159622\",\"89\":\"v-4c159622#写在前头\",\"90\":\"v-4c159622#分片并不意味着分布式-sharded-does-not-imply-distributed\",\"91\":\"v-4c159622#分片解决方案-sharding-solutions\",\"92\":\"v-4c159622#分布式数据库-distributed-databases\",\"93\":\"v-4c159622@0\",\"94\":\"v-4c159622@1\",\"95\":\"v-d962bf1c\",\"96\":\"v-d962bf1c#介绍\",\"97\":\"v-d962bf1c#实现背景\",\"98\":\"v-d962bf1c#使用场景\",\"99\":\"v-d962bf1c#region\",\"100\":\"v-d962bf1c#应用\",\"101\":\"v-d962bf1c#静态配置\",\"102\":\"v-d962bf1c#动态配置\",\"103\":\"v-d962bf1c#代码示例\",\"104\":\"v-d962bf1c#实现原理\",\"105\":\"v-d962bf1c#小故事\",\"106\":\"v-d962bf1c@0\",\"107\":\"v-d962bf1c@1\",\"108\":\"v-2560cb50\",\"109\":\"v-2560cb50#前言\",\"110\":\"v-2560cb50#事务同步接口\",\"111\":\"v-2560cb50#使用方式\",\"112\":\"v-2560cb50#基于接口\",\"113\":\"v-2560cb50#基于注解\",\"114\":\"v-2560cb50#注意事项\",\"115\":\"v-2560cb50#注解方式方法入参问题\",\"116\":\"v-2560cb50#aftercommit-aftercompletion-事务范围问题\",\"117\":\"v-2560cb50#实际场景\",\"118\":\"v-2560cb50#思考题\",\"119\":\"v-2560cb50#问题一\",\"120\":\"v-2560cb50#问题二\",\"121\":\"v-2560cb50#总结\",\"122\":\"v-2560cb50@0\",\"123\":\"v-2560cb50@1\",\"124\":\"v-46e92f7e\",\"125\":\"v-46e92f7e#介绍\",\"126\":\"v-46e92f7e#集成-jakarta-websocket\",\"127\":\"v-46e92f7e#项目依赖\",\"128\":\"v-46e92f7e#端点\",\"129\":\"v-46e92f7e#onopen\",\"130\":\"v-46e92f7e#onclose\",\"131\":\"v-46e92f7e#onerror\",\"132\":\"v-46e92f7e#onmessage\",\"133\":\"v-46e92f7e#配置端点扫描\",\"134\":\"v-46e92f7e#js-连接测试\",\"135\":\"v-46e92f7e#在端点中注入-bean\",\"136\":\"v-46e92f7e#关于-onmessage-方法的-last-参数\",\"137\":\"v-46e92f7e#关于心跳\",\"138\":\"v-46e92f7e#后续\",\"139\":\"v-46e92f7e#参考资料\",\"140\":\"v-46e92f7e@0\",\"141\":\"v-46e92f7e@1\",\"142\":\"v-38d14346\",\"143\":\"v-e1e3da16\",\"144\":\"v-09041878\",\"145\":\"v-3d0c4d0a\",\"146\":\"v-411dc1da\",\"147\":\"v-1a2ef2a6\",\"148\":\"v-7783265c\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,29],\"1\":[1],\"2\":[1,30],\"3\":[5,350],\"4\":[1,5],\"5\":[null,null,1],\"6\":[null,null,1],\"7\":[2],\"8\":[1,25],\"9\":[1,16],\"10\":[1,60],\"11\":[1,50],\"12\":[1,39],\"13\":[1,7],\"14\":[2,99],\"15\":[2,59],\"16\":[3,104],\"17\":[1],\"18\":[3,33],\"19\":[2,38],\"20\":[1,30],\"21\":[null,null,1],\"22\":[null,null,3],\"23\":[5],\"24\":[1,28],\"25\":[1,75],\"26\":[1,40],\"27\":[1,40],\"28\":[1],\"29\":[4,69],\"30\":[2,126],\"31\":[2,57],\"32\":[2,59],\"33\":[2,218],\"34\":[1,22],\"35\":[1,28],\"36\":[null,null,1],\"37\":[null,null,3],\"38\":[2,14],\"39\":[1,43],\"40\":[1,10],\"41\":[1,17],\"42\":[1,4],\"43\":[2,23],\"44\":[3,27],\"45\":[2,29],\"46\":[1,64],\"47\":[1,47],\"48\":[1,36],\"49\":[1,22],\"50\":[1,24],\"51\":[1,5],\"52\":[null,null,1],\"53\":[null,null,2],\"54\":[2],\"55\":[2],\"56\":[1,30],\"57\":[1,49],\"58\":[2,33],\"59\":[3,24],\"60\":[3,18],\"61\":[4,16],\"62\":[3,8],\"63\":[3,22],\"64\":[3,51],\"65\":[3,6],\"66\":[3,53],\"67\":[1,30],\"68\":[1,38],\"69\":[1,18],\"70\":[1,21],\"71\":[1,31],\"72\":[null,null,1],\"73\":[null,null,2],\"74\":[6],\"75\":[1,114],\"76\":[11,90],\"77\":[4,109],\"78\":[13,337],\"79\":[13,345],\"80\":[14,263],\"81\":[12,202],\"82\":[14,271],\"83\":[12,213],\"84\":[14,123],\"85\":[5,95],\"86\":[null,null,1],\"87\":[null,null,1],\"88\":[1],\"89\":[1,86],\"90\":[6,51],\"91\":[3,186],\"92\":[3,246],\"93\":[null,null,1],\"94\":[null,null,1],\"95\":[3],\"96\":[1,33],\"97\":[1,68],\"98\":[1,6],\"99\":[1,46],\"100\":[1],\"101\":[1,174],\"102\":[1,38],\"103\":[1,88],\"104\":[1,71],\"105\":[1,56],\"106\":[null,null,1],\"107\":[null,null,2],\"108\":[2],\"109\":[1,18],\"110\":[1,49],\"111\":[1],\"112\":[1,54],\"113\":[1,98],\"114\":[1],\"115\":[1,37],\"116\":[3,15],\"117\":[1,111],\"118\":[1,14],\"119\":[1,30],\"120\":[1,157],\"121\":[1,16],\"122\":[null,null,1],\"123\":[null,null,2],\"124\":[4],\"125\":[1,78],\"126\":[3],\"127\":[1,22],\"128\":[1,156],\"129\":[2,27],\"130\":[2,5],\"131\":[2,12],\"132\":[2,20],\"133\":[1,40],\"134\":[2,94],\"135\":[2,61],\"136\":[5,98],\"137\":[1,15],\"138\":[1,18],\"139\":[1,10],\"140\":[null,null,1],\"141\":[null,null,3],\"142\":[2],\"143\":[1],\"144\":[1],\"145\":[1],\"146\":[1],\"147\":[1],\"148\":[1]},\"averageFieldLength\":[2.4026656543626204,66.70366112795445,0.6476900546063558],\"storedFields\":{\"0\":{\"h\":\"关于作者\",\"t\":[\"Java 开发一枚 (●ˇ∀ˇ●) ~，博客刚切换，一些配置还有内容还需要时间慢慢缝补。\",\"2020.07.08，使用 Hexo 首次建立个人博客，也在同一天发布了第一篇文章\",\"2020.08.09，因工作琐事，加上深感自己对技术的理解还不够深入，经验也不够充足，所以停更，更专注地学习各项技术、积累经验\",\"2023.09.21，时隔三年，重拾博客，从 Hexo 转向 VuePress\",\"Continue...\"]},\"1\":{\"h\":\"枚举字典的巧用\"},\"2\":{\"h\":\"序\",\"t\":[\"一般在项目当中，关于字典的管理方式可概括为以下两种：\",\"交由数据库维护，前后端需要时调用接口获取，好处是可以对字典做成页面配置，随时增删查改，前后端同步；\",\"前后端根据业务约定好字典内容后，各自存储，这样就无需依赖 API 调用。\",\"第一种做法比较有利于字典需要频繁变化的场景，缺点是需要网络调用接口；而第二种虽然避免了网络问题，但要求前后端手动同步好字典数据，以免出错，对于变化较多的字典较为麻烦。\",\"用哪一种根据业务决定即可，因为根据实际情况，前端总是需要对字典数据做一些特殊处理，比如根据订单状态执行不同操作，需要依赖字典做条件判断，这避免不了需要在前端存储一份字典数据的问题。（个人）目前所接触过的实际项目也基本都是前后端自己维护，除了个别纯后台管理系统才采用了第一种方案。\",\"以下内容是基于第二种方案，针对枚举字典的出入参转化进行介绍。\"]},\"3\":{\"h\":\"基于 MyBatisPlus + Jackson 实现枚举出入参转换\",\"t\":[\"当接口的出入参中包含字典字段时，比如性别gender，常见的做法是出入参都用Integer类型修饰，前后端传递字典数值即可。对于前端，倘若查询列表数据过多且字典字段存在好几个，则需要前端一一转化，增加了前端计算量，对于页面渲染性能有影响。对于后端则无大碍，但获取到的参数若直接是枚举类型，那么使用参数时也可以更灵活。因此，可通过对字典字段的出入参进行转化，返回给前端时不仅有字典值，还有对应的字典描述以直接展示，而后端获取到的参数就是一个枚举类型。\",\"在 MyBatis 中提供了字段类型处理器，用于JavaType与JdbcType之间的转换，而这正巧可以作用于枚举类型字段的出参转化。\",\"MyBatis 基础字段类型处理器对象为BaseTypeHandler<T>，该类提供了对引用泛型类型的转化，简单看下其源码：\",\"public abstract class BaseTypeHandler<T> extends TypeReference<T> implements TypeHandler<T> { /** * ...其它内容 */ // 该类提供了四个可供开发者实现的钩子方法，用于自定义转化非空、可空的参数 public abstract void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; public abstract T getNullableResult(ResultSet rs, String columnName) throws SQLException; public abstract T getNullableResult(ResultSet rs, int columnIndex) throws SQLException; public abstract T getNullableResult(CallableStatement cs, int columnIndex) throws SQLException; } \",\"因为要转化的是枚举类型，首先创建一个枚举接口（枚举无法继承），在其中封装常用的操作；\",\"public interface BasicEnum<E extends Enum<E>> { Integer code(); // 枚举代码 String name(); // 枚举内容 /** * 用枚举代码获取枚举对象，该方法会在 MP 的字段类型处理器中使用 */ static BasicEnum<?> fromCode(Class<?> enumCls, Integer code) { if (enumCls == null || code == null) { return null; } BasicEnum<?>[] enumConstants = (BasicEnum<?>[]) enumCls.getEnumConstants(); for (BasicEnum<?> enumConstant : enumConstants) { if (enumConstant.code().equals(code)) { return enumConstant; } } log.error(\\\"类 {} 中没有值为[{}]的枚举\\\", enumCls, code); throw new RuntimeException(String.format(\\\"值[%s]没有对应的枚举!\\\", code)); } //... 其它操作，比如根据值获取文本、通过文本获取值、遍历等等 } /** * 性别枚举，实现 BasicEnum */ public enum GenderEnum implements BasicEnum<DemoEnum> { MALE(1, \\\"男\\\"), FEMALE(2, \\\"女\\\"), UNKNOWN(3, \\\"未知\\\"); DemoEnum(Integer code, String name) { this.code = code; this.name = name; } private final Integer code; private final String name; @Override public Integer code() { return this.code; } @Override public String name() { return this.name; } } \",\"因为上面为枚举抽象了一个统一接口BasicEnum，因此可以直接利用它来创建一个类型处理器：\",\"public class EnumHelperTypeHandler <E extends Enum<E>> extends BaseTypeHandler<BasicEnum<E>> { // 要转化的类型，因为泛型指定为 BasicEnum，所以该处理器只针对枚举类型字段 private final Class<E> cls; public EnumHelperTypeHandler(Class<E> cls) { this.cls = cls; } /** * 该方法将 DB 查询到的枚举 code 转为指定的 jdbc 类型 */ @Override public void setNonNullParameter(PreparedStatement ps, int i, BasicEnum<E> parameter, JdbcType jdbcType) throws SQLException { if (jdbcType == null){ ps.setObject(i,parameter.code()); log.warn(\\\"SQL 中枚举字段没有指定 JdbcType\\\"); return; } switch (jdbcType) { case TINYINT: ps.setByte(i, parameter.code().byteValue()); break; case SMALLINT: ps.setShort(i, parameter.code().shortValue()); break; case INTEGER: ps.setInt(i, parameter.code()); break; case BIGINT: ps.setLong(i, parameter.code().longValue()); break; case VARBINARY: case CHAR: ps.setString(i, String.valueOf(parameter.code())); break; default: throw new IllegalArgumentException(String.format(\\\"不支持枚举转换JDBC类型 => %s\\\", jdbcType)); } } /** * 以下三个方法调用 value2Enum() 方法，根据 code 转为枚举对象 */ @Override public BasicEnum<E> getNullableResult(ResultSet rs, String columnName) throws SQLException { return value2Enum(rs.getObject(columnName)); } @Override public BasicEnum<E> getNullableResult(ResultSet rs, int columnIndex) throws SQLException { return value2Enum(rs.getObject(columnIndex)); } @Override public BasicEnum<E> getNullableResult(CallableStatement cs, int columnIndex) throws SQLException { return value2Enum(cs.getObject(columnIndex)); } @SuppressWarnings(\\\"unchecked\\\") public BasicEnum<E> value2Enum(Object val) { if (val == null) { return null; } int code; if (val instanceof String) { code = Integer.parseInt((String) val); } else if (val instanceof Number) { code = ((Number) val).intValue(); } else { throw new IllegalArgumentException(String.format(\\\"不支持的类型转枚举 => %s\\\", val.getClass())); } return (BasicEnum<E>) BasicEnum.fromCode(cls, code); } } \",\"类型转化器创建好后，需要在application.yml中配置如下信息：\",\"mybatis-plus: configuration: # 设置默认的枚举类型转化器 default-enum-type-handler: com.bingqiling.enumconv.enums.EnumHelperTypeHandler \",\"到这一步关于枚举类型数据的出参就搞定了，接下来是入参，需要利用到 Jackson 的序列化与反序列化功能：\",\"/** * 反序列化，转化入参 */ public class EnumHelperJsonDeserializer<E extends Enum<E>> extends JsonDeserializer<BasicEnum<E>> { @Override public BasicEnum<E> deserialize(JsonParser p, DeserializationContext deserializationContext) throws IOException { // 枚举的code值 Integer code = p.getIntValue(); JsonStreamContext parsingContext = p.getParsingContext(); // 当前反序列化目标对象的类 Object currentValue = parsingContext.getCurrentValue(); // 当前字段所在类 Class<?> cls = parsingContext.getCurrentValue().getClass(); // 当前反序列化的字段名 String fieldName = parsingContext.getCurrentName(); // 当前反序列化字段的类型 Field field = ReflectionUtils.findField(cls, fieldName); Class<?> fieldType = null; if (field != null) { fieldType = field.getType(); } // 如果 filedType 为 null，那么执行 fromCode() 将会抛出异常，根据异常决定返回什么信息给前端即可 return (BasicEnum<E>) BasicEnum.fromCode(fieldType, code); } } /** * 序列化，转化出参 */ public class EnumHelperJsonSerializer extends JsonSerializer<BasicEnum<?>> { @Override public void serialize(BasicEnum basicEnum, JsonGenerator gen, SerializerProvider serializers) throws IOException { if (basicEnum == null || basicEnum.code() == null) { gen.writeNull(); return; } // 写枚举的值 gen.writeNumber(basicEnum.code()); // 写出枚举名称键值，就是在这一步，为枚举字段添加一个字段来描述对应的内容 String currentName = gen.getOutputContext().getCurrentName(); if (currentName != null) { // 这里的做法是字段名使用参数名+Name，值为枚举的 name gen.writeStringField(currentName + \\\"Name\\\", basicEnum.name()); } } } // 然后在 BasicEnum 接口添加两个注解使用上述的序列化与反序列化器即可 @JsonSerialize(using = com.example.config.EnumHelperJsonSerializer.class) @JsonDeserialize(using = com.example.config.EnumHelperJsonDeserializer.class) public interface BasicEnum<E extends Enum<E>> { //... } \",\"到这里基本配置就已经完成，可以构建入参、接口进行测试了。如下：\",\"public class EnumDTO { // 直接使用枚举类型 private GenderEnum gender; // getter/setter 方法省略 } public class ResultVO { private GenderEnum gender; // getter/setter 方法省略 } // Controller @RestController @RequestMapping(\\\"/demo\\\") public class DemoController { // user 表只是测试用，User 对象包含了一个字段 GenderEnum gender，知道这个即可 @Resource private UserMapper userMapper; @PostMapping(\\\"/convert\\\") public ResultVO enumConvertTest(@RequestBody EnumDTO param) { System.out.println(\\\"入参枚举：\\\" + param.getGender()); List<User> users = userMapper.selectList(Wrappers.emptyWrapper()); ResultVO resultVO = new ResultVO(); resultVO.setGender(users.get(0).getGender()); return resultVO; } } \",\"### 请求 GET localhost:8091/demo/convert Content-Type: application/json { \\\"gender\\\": 1 } \",\"如上代码，HTTP 请求只需指定数值，出入参返回皆会自动转为枚举和增加相应字段，入参与返回数据如下：\",\"入参转化\",\"{ \\\"code\\\": 200, \\\"msg\\\": \\\"成功\\\", \\\"data\\\": { \\\"gender\\\": 1, \\\"genderName\\\": \\\"男\\\" } } \",\"到这里所有操作就已完成，实现了出入参的改变。\",\"至于 MyBatis 提供的TypeHandler类型转换器原理并不复杂，就是对 MyBatis 查询结果集的遍历处理，调用相应转化器器进行转化，而且还内置了默认的类型转换器，如字符串StringTypeHandler、数值IntegerTypeHandler，以及 MyBatis Plus 也提供了自己实现的JacksonTypeHandler。感兴趣的同学可自己追踪源码，此处不再赘述，完！\"]},\"4\":{\"h\":\"其它\",\"t\":[\"这里补充一个关于枚举字典的抽象优化，直戳链接进入：巧用枚举让字典表的管理和使用变得简单，还不错。\"]},\"5\":{\"c\":[\"开发技巧\"]},\"6\":{\"c\":[\"开发技巧\"]},\"7\":{\"h\":\"聊聊 HashMap\"},\"8\":{\"h\":\"前言\",\"t\":[\"Map，Java 三大集合框架之一，JDK1.2 时便已存在，是一个Key-Value键值对映射的接口，即一个Key对应一个Value。在日常开发使用中，我们常见的 Map 实现类有：HashMap、Hashtable、TreeMap、LinkedHashMap 等，用以应对不同业务情况下的数据存储与使用。而本篇的主角是 HashMap，让我们来粗浅的聊聊它吧。（注意：本篇 HashMap 的源码和原理讲解全部基于 JDK1.7）\"]},\"9\":{\"h\":\"基础\",\"t\":[\"HashMap 是基于哈希表（Hashtable）的 Map 实现类，以Key-Value形式保存数据，Key唯一，Value可重复，并采用 Hash 算法确定Key-Value的存储位置从而保证其进行数据快速存取。类图如下：\",\"HashMap 类图\"]},\"10\":{\"h\":\"结构\",\"t\":[\"HashMap 的底层结构是 数组+链表，是通过计算key的hash值来确定数组下标位置，然后将key和value作为Entry<K,V>对象进行存储。这里需要注意，是作为 Entry<K,V> 对象存储，而不是通过key确定数组下标后直接存放值。Entry<K,V> 是 Map 的内部接口，本质上是一个映射（键值对），HashMap 类中对它有一个静态实现，如下：\",\"static class Entry<K,V> implements Map.Entry<K,V> { final K key; V value; Entry<K,V> next; //链表节点中的下一个 Entry<K,V> 对象 int hash; //当前 Entry 对象的 hash 值 //构造函数 Entry(int h, K k, V v, Entry<K,V> n) { value = v; next = n; key = k; hash = h; } //其它代码省略 ... } \",\"从源码可以看出，Entry<K,V>对象保存了key、value、hash值，还保存了当前Entry<K,V>对象的下一个Entry<K,V>对象：Entry<K,V> next。这也是为什么 HasHMap 结构是数组+链表，数组其实就是Entry<K,V>类型数组，而链表则是单向的，每个节点都是一个Entry<K,V>对象，并保存了下一个Entry<K,V>节点的数据，通过一张图来简单理解下：\",\"HashMap 结构图\"]},\"11\":{\"h\":\"属性\",\"t\":[\"HashMap 内部定义的几个主要属性如下：\",\"transient Entry[] table：Entry<K,V>对象数组，长度始终保持为 2 的幂次方\",\"transient int size：HashMap 已存储的元素数量\",\"final float loadFactor：负载因子，默认是 0.75，扩容时使用\",\"static final int DEFAULT_INITIAL_CAPACITY：HashMap 的默认初始容量\",\"int threshold：阈值，当 HashMap 存储的元素数量达到该值，则会触发扩容操作\",\"transient int modCount：记录 HashMap 结构修改的次数，如修改值、重新扩容等\",\"HashMap 阈值大小计算为： capacity(容量) * loadFactor(负载因子) = threshold(阈值) ，capacity也就是构建 HashMap 时指定的容量大小（不指定则默认为 16）。一旦 HashMap 的size超过阈值，就会进行扩容操作，重新调整 HashMap 的大小以便存放更多的元素。\"]},\"12\":{\"h\":\"常用方法\",\"t\":[\"public int size()：返回 HashMap 的元素数量\",\"public boolean isEmpty()：判断 HashMap 是否为空\",\"public V put(K key, V value)：存放键值对，即数据元素\",\"public V get(Object key)：通过key获取Value`\",\"public V remove(Object key)：通过key删除元素\",\"public void clear()：清空 HashMap\",\"public boolean containsKey(Object key)：判断传递的key在 HashMap 中是否已存在\",\"public boolean containsValue(Object value)：判断传递的value是否已有key进行映射\",\"public Set keySet()：获取所有key的 Set 集合\",\"public Set> entrySet()：获取所有Entry<K,V>的 Set 集合，可以用来遍历 HashMap\"]},\"13\":{\"h\":\"方法原理\",\"t\":[\"接下来我们具体看看 HashMap 设值、取值、扩容、复制数据等方法的具体实现是怎么样的。\"]},\"14\":{\"h\":\"put 方法实现\",\"t\":[\"public V put(K key, V value) { if (key == null) return putForNullKey(value); //1.判断 key 是否为 Null，为 Null 直接存放在数组下标 0 的位置 int hash = hash(key); //2.计算 key 的 hash 值 int i = indexFor(hash, table.length); //3.通过 hash 值计算数组下标 index for (Entry<K,V> e = table[i]; e != null; e = e.next) { Object k; //4.判断 hash 值和 key 值是否相同，相同则覆盖并返回旧值 if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //5.修改次数 +1 addEntry(hash, key, value, i); //6.将 key-value 封装为 Entry 对象并添加， return null; } static int indexFor(int h, int length) { return h & (length-1); // 数组长度-1，按位与计算出下标 } void addEntry(int hash, K key, V value, int bucketIndex) { //如果加入新元素超过阈值，则扩容为原来的2倍大小 if ((size >= threshold) && (null != table[bucketIndex])) { resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); // 创建 Entry } void createEntry(int hash, K key, V value, int bucketIndex) { Entry<K,V> e = table[bucketIndex]; //若 e 不为空，则说明发生 hash 碰撞，将 Entry 插入到链表头，将原有节点(e)作为下一个节点 table[bucketIndex] = new Entry<>(hash, key, value, e); size++; //HashMap 元素数量 +1 } \",\"根据上方源码总结下步骤：\",\"判断key是否为null，为null则直接存放到数组下标为 0 的位置；\",\"计算key的 hash 值并通过该值确定数组下标位置；\",\"判断key是否重复，重复则覆盖并返回旧值；\",\"在addEntry()方法判断是否需要扩容，最后将key-value封装为Entry<K,V>对象保存。\"]},\"15\":{\"h\":\"get 方法实现\",\"t\":[\"理解了put()方法后，get()方法就简单多了，直接上源码：\",\"public V get(Object key) { if (key == null) return getForNullKey(); //1.判断 key 是否 Null，为空直接获取数组下标为 0 的元素 Entry<K,V> entry = getEntry(key); return null == entry ? null : entry.getValue(); //三目表达式判断 } final Entry<K,V> getEntry(Object key) { int hash = (key == null) ? 0 : hash(key); //计算 key 的 hash 值 //2.indexFor() 计算数组下标并循环遍历该下标处的链表节点 for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null;e = e.next) { Object k; //3.判断是否 hash 值和 key 值是否相同且不为 null，不匹配则循环判断下一节点 if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } return null; } \",\"步骤如下：\",\"判断key是否 null，为 null 直接取数组下标为 0 的元素；\",\"在getEntry()方法里计算key的hash值找到下标然后循环遍历判断key的值，存在返回值，不存在则返回null。\"]},\"16\":{\"h\":\"resize/transfer 方法实现\",\"t\":[\"这两个方法主要是数组扩容和数据复制，在 HashMap 中，这个过程称为 rehashing。源码如下：\",\"void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; //1.获取旧数组长度 //MAXIMUM_CAPACITY 的值为 1<<30，是 Integer.MAX_VALUE 的一半减1，已经大的夸张，基本不存在扩容情况 //所以重新设置阈值后直接返回 if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } //2.创建一个新的数组，大小为原来的2倍 Entry[] newTable = new Entry[newCapacity]; //3.获取是否需要重新计算 hash boolean oldAltHashing = useAltHashing; useAltHashing |= sun.misc.VM.isBooted() && (newCapacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean rehash = oldAltHashing ^ useAltHashing; //4.扩容的关键方法，旧数组数据复制到新数组 transfer(newTable, rehash); table = newTable; //5.重新计算阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; //遍历旧数组 for (Entry<K,V> e : table) { //遍历当前节点的链表 while(null != e) { Entry<K,V> next = e.next; //判断是否需要重新计算 hash if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); //计算数组下标 e.next = newTable[i]; //头插法，链表头部插入，已有的节点往后移作为 next 节点 newTable[i] = e; //头部插入 e = next; } } } \",\"过程理解起来也不难：\",\"创建大小为原来 2 倍的新数组；\",\"在transfer()方法将旧数组数据循环遍历复制到新数组（关键）；\",\"将新数组赋值给 HashMap 的table变量，并重新计算阈值。\",\"理解清楚 HashMap 的设值、取值、扩容复制原理后，基本上其它方法实现都可以很容易理解了，这里就不多赘述。\"]},\"17\":{\"h\":\"补充\"},\"18\":{\"h\":\"与 Hashtable 的区别\",\"t\":[\"HashMap\",\"key 允许为 Null（唯一）\",\"线程不安全\",\"效率较高\",\"继承于 AbstractMap<K,V>\",\"Hashtable\",\"key 不为空\",\"线程安全\",\"效率较低\",\"继承于 Dictionary<K,V>\",\"Hashtable 的key不能为空，是因为put()方法里作了判断，为空直接抛出 NPE 异常；而它之所以是线程安全，通过源码可知是因为内部方法都加上了 Synchronize同步锁，但Synchronize是重量级锁，容易引起线程上下文切换而带来线程调度的开销，因此在多线程并发应用中使用是比较少的，推荐使用 ConcurrentHashMap，其采用的是分段锁，效率比 Hashtable 要高出许多。\"]},\"19\":{\"h\":\"HashMap 死链问题\",\"t\":[\"HashMap 死链是指在 Java 并发情况下，多线程操作 HashMap 产生 Race Condition(竞用条件)，而此时 HashMap 刚好需要扩容，导致旧数据复制到新数组产生死循环。简单讲就是链表中 A(Entry) 的 next 属性指向 B(Entry)，而 B 的 next 属性又指向 A。\",\"关于死链具体情况，在左耳朵耗子-陈皓的《疫苗：Java HashMap的死循环》这篇里讲解的非常清楚，很清晰易懂。并且死链情况在 Java 8 中已经得到解决，在 Java 8 版本开始，HashMap 的结构就变为了 数组+链表+红黑树，后续新篇章也会对 Java 8 的 HashMap 作下介绍讲解。\"]},\"20\":{\"h\":\"总结\",\"t\":[\"最后来概括下 HashMap 的工作原理：当通过put()方法存值时会调用key.hashCode()计算哈希值从而获取数组下标，并将Key-Value作为 Entry<K,V> 对象进行存储，调用get()方法时同样计算key的哈希值然后获取数组下标，然后通过 key.equals()判断值是否相同，最终返回结果。当存值时若元素数量大于阈值threshold则进行扩容，大小为原来的2倍。\",\"Java 8 前的 HashMap 原理并不复杂，至于其它的一些细枝末节，在理解了上面的内容后，自己去查看源码学习，就会很轻松了。\"]},\"21\":{\"c\":[\"Java\"]},\"22\":{\"c\":[\"Java\",\"HashMap\",\"集合\"]},\"23\":{\"h\":\"Java 8 中 HashMap 的改变\"},\"24\":{\"h\":\"前言\",\"t\":[\"在聊聊 HashMap 篇中，通过 JDK1.7 的 HashMap 的几个方法：put()、get()、resize()/transfer()讲解了其原理，在最后简单描述了 HashMap 死链问题。引出了在 Java 8 中，HashMap 底层结构变化为 数组+链表+红黑树，提高了查询效率，并解决了死链问题。我们就以此作为切入点，来看看 HashMap 在 Java 8 版本有了哪些变化。\"]},\"25\":{\"h\":\"死链原因和解决方法\",\"t\":[\"Java 8 之前的 HashMap 并发扩容出现死链，原因之一是链表节点的存储方式引起，即 头插法。每当添加新元素时，都是放在链表头节点，原头节点就变成新节点的 next 节点。这就导致了并发扩容时，若链表元素 rehash 后依旧在同一个数组下标位置，则链表元素会出现逆序（或翻转），即 A-B-C 变成 C-B-A。另一个是因为复制数据是在 while 循环里遍历一个节点就插入到新的数组位置，假设有两个线程，线程一获取到 A 节点以及下一节点 B 后就被阻塞，而线程二直接完成了扩容操作，链表变成 C-B-A，当线程一恢复运行后，B 的下一节点又变成 A，死链就出现了。\",\"再次贴上复制数据的方法源码，方便大家回顾：\",\"// JDK 7 源码 void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry<K,V> e : table) { while(null != e) { Entry<K,V> next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } } } \",\"而在 Java 8 中则更改为 尾插法，即添加的新元素会放在链表尾节点，这样在扩容时就不会出现元素逆序的情况，并且在扩容方法的 while 循环复制数据中，是将索引下标处的链表节点全部遍历获取后，再存入到新数组中，这样就避免了死链问题。关于其逻辑实现在下面会讲到，可以先看下图简单对比头插法和尾插法：\",\"HashMap 7/8 链表结构\"]},\"26\":{\"h\":\"结构变化\",\"t\":[\"Java 8 中，HashMap 底层结构变为 数组+链表+红黑树，显著提高了查询效率。在 HashMap 中，获取元素可以简单分为以下两步：\",\"根据key.hashCode()获取 hash 值，然后确定数组下标 index；\",\"若数组下标位置节点key不匹配，则遍历链表，通过key.equals()查找。\",\"在 Java 8 之前只是用链表解决冲突问题，在发生碰撞问题时，这两步获取元素的时间复杂度为 O(1)+O(n)。因此，当碰撞频率高时 n 变大，查询速度就会受到影响。在 Java 8 中则利用红黑树替代链表，而红黑树是一种自平衡的二叉查找树，如此一来，获取元素的时间复杂度就变为 O(1)+O(log n)，在 n 变大时，能够理想地解决查询效率变低的问题。\"]},\"27\":{\"h\":\"链表与红黑树转换时机\",\"t\":[\"当发生哈希碰撞时，首先用链表存储，当链表节点数量大于等于 8 时，就会转换为红黑树，而一旦节点数量小于等于 6，红黑树又会转换为链表。当节点数量达到 8 时，红黑树的平均查找时间为 3(log 8)，而链表则为 4(8/2)，这才有了转换的必要。而选择 6 和 8，中间存在差值 7，是假设当链表长度大于小于 8 时，红黑树和链表就互相转换，若 HashMap 存储的元素数量在 8 徘徊，频繁增删，红黑树和链表就会频繁转换，效率将会降低。\",\"static final int TREEIFY_THRESHOLD = 8; //HashMap 默认的转换为红黑树的节点阈值 static final int UNTREEIFY_THRESHOLD = 6; // 默认的转换为链表的节点阈值 \"]},\"28\":{\"h\":\"原理解析\"},\"29\":{\"h\":\"Node<K,V> 和 TreeNode<K,V>\",\"t\":[\"在 Java 8 之前，key-value是用Entry<K,V>对象保存，Java 8 中则变为Node<K,V>，但其内部方法实现基本相同，依旧实现Map.Entry<K,V>接口，下面是源码：\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; V value; Node<K,V> next; Node(int hash, K key, V value, Node<K,V> next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } // ...其它代码省略... } \",\"重要的是内部静态类增加了TreeNode<K,V>，该类也就是红黑树节点对象，在下面源码中，TreeNode<K,V>类是继承LinkedHashMap.Entry<K,V>类，而进入该类，可以看到其实也是继承HashMap.Node<K,V>类，并含有before、after两个属性，但TreeNode<K,V>本身并没有直接使用到这两个属性，只是维护了双向链表的应用，便于在红黑树和链表之间进行转换：\",\"static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> { TreeNode<K,V> parent; // 红黑树根节点 TreeNode<K,V> left; // 左节点 TreeNode<K,V> right; // 右节点 TreeNode<K,V> prev; // 当前节点的前一节点 boolean red; // 是否为红色节点 TreeNode(int hash, K key, V val, Node<K,V> next) { super(hash, key, val, next); // 调用父类的构造方法 } // ...其它代码省略... } // LinkedHashMap.Entry<K,V> 的实现 static class Entry<K,V> extends HashMap.Node<K,V> { Entry<K,V> before, after; Entry(int hash, K key, V value, Node<K,V> next) { super(hash, key, value, next); // 调用父类 HashMap.Node<K,V> 的构造方法 } } \"]},\"30\":{\"h\":\"put 方法\",\"t\":[\"依旧是从put()方法开始，直接上源码：\",\"public V put(K key, V value) { // 1、获取 key 的 Hash 值 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; // 2、判断 table 是否为空，为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 3、计算数组下标，判断该位置是否为空，为空直接添加 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node<K,V> e; K k; // 4、判断 hash 值和 key 是否相同，相同赋值给 e if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 5、若为树节点，执行 putTreeVal() 添加 else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { // 6、遍历链表，尾插法 for (int binCount = 0; ; ++binCount) { // 6.1、next 节点为空直接添加 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 6.2、当链表节点数量 >= 8 则转换为红黑树 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 6.3、next 节点不为空，则判断是否与当前遍历节点相同 if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } // 7、e 不为空则进行覆盖并返回旧值 if (e != null) { // existing mapping for key V oldValue = e.value; // 7.1、onlyIfAbsent 表示是否覆盖已存在的值 // put()默认传递 false 覆盖， putIfAbsent()传递 true 不覆盖 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size > threshold) // 8、判断是否超过阈值，超过则扩容 resize(); afterNodeInsertion(evict); return null; } \",\"总结下步骤：\",\"获取key的 hash 值，然后进入putVal()方法，若 table 为空则先创建；\",\"计算数组下标，判断下标处元素，若为空直接新增，不为空先判断key.equals(k)；\",\"不同说明发生碰撞，判断是否为树节点，是则调用putTreeVal()新增树节点；\",\"若是链表节点，则遍历到链表尾部判断，当节点不存在则新增（尾插法）；\",\"如果链表长度大于等于TREEIFY_THRESHOLD，就将链表转换为红黑树；\",\"若节点已经存在,则替换旧值oldValue并返回；\",\"最后判断容量若大于阈值，就进行扩容resize()。\"]},\"31\":{\"h\":\"get 方法\",\"t\":[\"public V get(Object key) { Node<K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node<K,V> getNode(int hash, Object key) { Node<K,V>[] tab; Node<K,V> first, e; int n; K k; // 1、获取数组下标位置第一个节点，命中则直接返回 if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; // 2、若为树节点则调用 getTreeNode() 去获取 if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K,V>)first).getTreeNode(hash, key); // 4、若为链表则遍历判断 do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"获取元素的逻辑还是比较简单，步骤如下：\",\"计算key的 hash 值找到数组下标，若下标处第一个节点匹配则返回；\",\"若有冲突，判断是树节点还是链表节点，然后通过key.equals(k)查找匹配的节点。\"]},\"32\":{\"h\":\"Hash 方法\",\"t\":[\"在新增和获取过程中，计算下标时，先对 key 的哈希值进行 hash 操作，再进一步计算下标，如下图所示：\",\"Hash 计算\",\"对key.hashCode()的 hash 操作实现如下：\",\"static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } // 计算下标方式：(n-1) & hash \",\"在 Java 8 之前原本是直接 & 运算获取下标，但一般情况下 HashMap 长度都小于 2^16，这就导致 & 运算的一直是哈希值的低 16 位甚至更低，假设长度为 16，则下标运算的结果取决于哈希值的低 4 位（即长度为 2 的 n 次方，位运算结果取决于低 n 位）。为了让哈希值的低 16 位更随机，便让哈希值与高 16 位（h >>> 16）进行异或运算，以让低 16 位更随机散列，减少碰撞。\"]},\"33\":{\"h\":\"resize 方法\",\"t\":[\"在resize()方法上有这么一段注释：\",\"Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.\",\"其意思大概就是初始化或增加数组大小，如果数组本就为空，则按默认值进行初始化，否则，因为使用的是 2 次幂扩展（即原来大小的 2 倍），元素存放在新数组要么是原位置，要么是原位置加上 2 次幂。搭配一张图来看就会很好理解：\",\"扩容计算\",\"因为扩容为n << 1，即 2 倍，所以 n-1 就是在高位多 1 bit（红色），若多出的高位 bit 经过 & 运算为 1，则元素 index 变为 原索引+原数组容量(即 2 次幂)，为 0 则不需要变化。因此扩容时不需要重新计算 hash 值，只需要在 原 hash 值跟原数组长度 & 运算 后判断是否等于 0 来确定是否需要移动即可。举个例子，假设数组长度原本是 16，n(16) -1 = 0000 1111，n(16) = 0001 0000，因为扩容后 n(32)-1 = 0001 1111，高位多 1 bit ，所以直接同 16 进行 & 运算效果相当于只跟高位 bit 进行位运算，如下图：\",\"高位 & 运算\",\"来看下resize()方法的源码，在 6.3 处就体现了上面说的元素是否需要移动的判断：\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 1、若是超过最大值，则不扩容，任由其碰撞了 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 2、不超过最大值则扩容为原来的 2 倍 else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } // 3、若无数据，则用初始化阈值赋值 else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; // 4、若无数据并且阈值为 0，则使用默认值设置 else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 5、若新数组未设置阈值，则进入此处计算新的 threshold if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) { // 6、遍历旧数组复制数据 for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; // 6.1、若当前节点没有冲突，则计算新的数组下标直接存值 if (e.next == null) newTab[e.hash & (newCap - 1)] = e; // 6.2、若为树节点，则调用 TreeNode.split() else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // preserve order // 6.3、以下部分是遍历链表节点进行复制，并判断节点在新数组的位置 // loHead：不需要改变位置的链表头节点，hiHead：需要改变位置的链表头节点 // loTail 和 hiTail 则是对应链表尾节点 Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; // 6.3.1、为 0 说明原索引位置存值 if ((e.hash & oldCap) == 0) { if (loTail == null) // 6.3.2、尾节点为空，则链表为空，头节点指向当前遍历节点 e(仅第一次) loHead = e; else // 6.3.3、尾节点不为空，则链表存在，将尾节点指向当前遍历节点 e loTail.next = e; // 6.3.4、将尾节点指向当前遍历节点 e loTail = e; } // 6.3.5、不为 0 说明新位置是原索引 + oldCap(旧容量) else { // 与上面同理 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 6.3.6、判断两个尾节点，不为空说明链表存在，将头节点保存在相应位置 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } \",\"扩容方法实现逻辑重点在于复制数据的 for 循环中，简单分为以下几步：\",\"若当前遍历的节点元素位置没有冲突，则直接计算新的数组下标存值；\",\"若为树节点，调用TreeNode.split()方法进行具体操作；\",\"若为链表节点则进行遍历，通过元素原 hash 值与旧数组长度 & 运算判断位置是否需要移动，采用两个头节点和两个尾节点保存元素构成链表，再将链表头节点存放到新数组的相应位置。\"]},\"34\":{\"h\":\"关于红黑树\",\"t\":[\"在上面内容中，基本侧重于 HashMap 整体的实现逻辑描述，而红黑树相关的内容，如新增树节点、链表红黑树互转等则讲解不多。主要是因为红黑树结构、以及树节点平衡被打破后的处理情况等内容比较复杂，讲解起来会很啰嗦冗余，而且对不了解红黑树的读者会很不友好。此处附上文章：程序员小灰 - 什么是红黑树，供感兴趣的读者学习下红黑树的相关知识（已会可忽略），结合上面对于 HashMap 的原理解析，再去查看关于红黑树操作的源码，理解起来就会比较轻松了 (●ˇ∀ˇ●) 。\"]},\"35\":{\"h\":\"尾声\",\"t\":[\"Java 8 HashMap 原理宏观上跟以前的思路差不多，主要是在新增、获取、删除元素和扩容等方法增加了对红黑树节点的判断，重要的变化可以简单归纳为：底层结构新增红黑树、链表存储方式变为尾插法，hash() 方法优化。而这些改变对 HashMap 性能提升影响是比较大的，在Java 8 中 HashMap 的性能提升一文中含有性能测试的结果。\",\"在实际开发中，HashMap 使用是非常频繁的，掌握原理，有助于我们在使用时，若遇到异常 Bug，可以快速定位、解决问题，并且 HashMap 也是面试经典问题了。\"]},\"36\":{\"c\":[\"Java\"]},\"37\":{\"c\":[\"Java\",\"HashMap\",\"集合\"]},\"38\":{\"h\":\"JVM 类加载机制\",\"t\":[\"在 JVM-内存模型 篇已经详细讲解了 JVM 内存模型的结构，如果想先了解 JVM 的内存模型，可以戳一下链接先去看看哦。这一篇，我将着重描述 Java 类加载机制，在 JVM 中类的加载到底经历了哪些过程。\"]},\"39\":{\"h\":\"什么是类的加载\",\"t\":[\"类的加载指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在 JVM 运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终结果是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并提供了访问方法区内的数据结构的接口。\",\"我们可以简单看张图理解下：\",\"类加载\",\"从图片我们知道，类加载完毕后，类的数据全部都存放在 JVM 的方法区，堆区只是提供了一个入口去调用相应的对象数据，比如Class.newInstance()，所以到这里，我们也能理解为什么 Java 对象都存放在堆区的原因。\",\"类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError 错误），如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。（此段引用于 纯洁的微笑-Java 类加载机制）\"]},\"40\":{\"h\":\"类的加载过程\",\"t\":[\"如下图所示，JVM 类加载主要经历五个部分：加载、连接、初始化、使用、卸载。接下来一一讲解每个部分都做了什么。\",\"类加载过程\"]},\"41\":{\"h\":\"加载\",\"t\":[\"加载是类加载过程的第一个阶段，主要是查找并加载类的二进制数据，而这一阶段也就会在堆区生成一个 java.lang.Class 对象，作为入口用于访问该对象在方法区里的数据结构。而且这一步也是可控的，我们可以使用默认的类加载器，也可以自定义类加载器对 Java 文件进行加载（关于 类加载器 👈下面有做简单介绍）。\"]},\"42\":{\"h\":\"连接\",\"t\":[\"连接细化分下来，其实有三步，分别为以下三个部分：\"]},\"43\":{\"h\":\"验证：确保被加载的类的正确性\",\"t\":[\"这是连接的第一步，判断当前 Class 文件的字节流信息是否符合当前 JVM 规范要求，大致会进行以下四个部分的验证：\",\"文件格式验证：验证字节流是否符合 Class 文件格式的规范\",\"元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求\",\"字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的\",\"符号引用验证：确保”解析”动作能正确执行\"]},\"44\":{\"h\":\"准备：为类的静态变量分配内存，并将其初始化为默认值\",\"t\":[\"这一步主要是在方法区中为类变量分配内存，并初始化类变量的值。\",\"比如声明如下，value的值在准备阶段会被初始化为 0，而不是 80，即数据类型的默认初始值，实际值的初始化会在 初始化 阶段（下面会讲到）：\",\"public static int value = 80; \",\"但如果是下面的声明方式，则会直接赋值为 8080，在编译阶段会为 value 生成 ConstantValue 属性，并在准备阶段赋值为 8080：\",\"public static final int value = 8080; \"]},\"45\":{\"h\":\"解析：把常量池内的符号引用转换为直接引用\",\"t\":[\"主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用，符号引用类型常见如下：\",\"CONSTANT_Class_info\",\"CONSTANT_Field_info\",\"CONSTANT_Method_info\",\"符号引用：一组符号来描述目标，可以是任何字面量，它与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。\",\"直接引用：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，当有了直接引用，就说明引用的目标在内存已经存在。\"]},\"46\":{\"h\":\"初始化\",\"t\":[\"为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化，Java 中为类变量进行初始值设定有两种方式：(1) 声明类变量时指定值；(2) 在静态代码块赋值。\",\"初始化的步骤如下：\",\"假如这个类还没有被加载和连接，则程序先加载并连接该类\",\"假如该类的直接父类还没有被初始化，则先初始化其直接父类\",\"假如类中有初始化语句，则系统依次执行这些初始化语句\",\"类初始化其实是执行类构造器方法的过程，编译器会自动收集类中的类变量赋值操作和静态代码块的语句合并而成，并且 JVM 会保证子构造器方法执行前，父类构造器已经执行完毕。如果一个类中既没有类变量也没有静态代码块，那么编译器可以不为这个类生成构造器方法。\",\"而初始化只有在对类的主动使用时才会触发，触发方式大概有以下几种：\",\"创建类的实例，也就是 new 的方式\",\"访问某个类或接口的静态变量，或者对该静态变量赋值\",\"调用类的静态方法反射（如Class.forName(\\\"com.Test\\\")）\",\"初始化某个类的子类，则其父类也会被初始化\",\"Java 虚拟机启动时被标明为启动类的类，直接使用 java.exe 命令来运行某个主类\",\"不会触发类初始化的情况如下：\",\"通过子类引用父类的静态字段，只会触发父类的初始化，而子类不会初始化\",\"定义数组对象，不会触发该类的初始化\",\"常量在编译期间会存入调用类的常量池，但本质上并没有直接引用定义常量的类，所以也不会触发初始化\",\"通过类名获取 Class 对象（Test.Class），不会触发\",\"通过Class.forName()加载指定类时，如果指定参数initialize为 false ，不会触发类初 始化，因为该参数是告诉虚拟机是否要对类进行初始化\"]},\"47\":{\"h\":\"类加载器\",\"t\":[\"类加载经过 初始化 这一步后，就已经可以正常使用，这个过程走下来，其实在最初的 加载 这一步开发者可以控制外，其它都是由 JVM 自行完成。而控制加载过程，则需要使用到类加载器。\",\"我们先简单了解下 JVM 提供的三种类加载器，如下图所示：\",\"类加载器\",\"启动类加载器(Bootstrap ClassLoader) ：负责加载 JAVA_HOME\\\\lib 目录中的，或通过 -Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。\",\"扩展类加载器(Extension ClassLoader) ：负责加载 JAVA_HOME\\\\lib\\\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。\",\"应用程序类加载器(Application ClassLoader）：负责加载用户路径（classpath）上的类库。\"]},\"48\":{\"h\":\"双亲委派模型\",\"t\":[\"在上面类加器图中我们可以看到，当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。这样子的好处是保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。\",\"而类加载器存在以下机制：\",\"全盘负责：当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。\",\"父类委托：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。\",\"缓存机制：缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效。\"]},\"49\":{\"h\":\"自定义类加载器\",\"t\":[\"当然，如果有需要，我们也可以自定义类加载器，只要 继承 ClassLoader 并重写其 loadClass() 方法，然后编写加载的具体逻辑代码即可。但这里有个要注意的点，如果直接重写 loadClass() 方法，有可能会破坏原本的双亲委派模型哦，具体如何避免该问题，就得查看浏览下 loadClass() 方法的源码了。而自定义实现类加载器的有 Tomcat、Java 代码生成器之类的案例，有兴趣的读者也可了解下。\"]},\"50\":{\"h\":\"总结\",\"t\":[\"本篇主要讲解 JVM 类加载机制，意在让读者明白 Java 文件编写后 JVM 是如何处理并正确使用，并理解类加载器的执行机制。当然本篇并不算全面细致的讲解，也有忽略的细节，如 连接-验证 步骤若是反复验证影响了加载效率该如何做，启动类加载器无法被 Java 程序直接引用等问题。\",\"但事无巨细，很多问题都是在某些情况下触发，都是要读者们在实际应用中去注意、发现并解决这些问题，久而久之，不仅问题解决了，还能更深入的理解其核心原理。\"]},\"51\":{\"h\":\"参考资料\",\"t\":[\"《深入理解Java虚拟机》第7章 / 周志明 / 机械工业出版社\"]},\"52\":{\"c\":[\"Java\"]},\"53\":{\"c\":[\"Java\",\"JVM\"]},\"54\":{\"h\":\"JVM 内存模型\"},\"55\":{\"h\":\"什么是 JVM\"},\"56\":{\"h\":\"概念\",\"t\":[\"JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，是一种用于计算设备的规范、能够运行 Java 字节码的虚拟机，拥有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。\",\"引入 Java 虚拟机后，Java 语言开发的程序在不同平台上运行时不需要重新编译。JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 JVM 上运行的字节码（.class），就可以在多种平台上不加修改地运行。对于 JVM，除了 Oracle，也有其它的开源或闭源实现。（摘自维基百科）\"]},\"57\":{\"h\":\"理解\",\"t\":[\"Java 是一门可跨平台的语言，但其本身并不能跨平台，而是通过 JVM 来实现。是通过 JVM 将编译好的文件解释成平台系统（Mac、Linux、Windows 等）可执行的机器码，然后系统加以运行，实现 “一次编译，到处运行” 的效果。\",\"学习 JVM，可以围绕四个部分进行：\",\"类的加载机制\",\"内存模型\",\"GC 算法、垃圾回收\",\"GC 分析、命令调优\",\"本篇着重于 JVM 内存模型的讲解，作为 Java 开发人员，平常或多或少会有这样的疑问，堆内存空间应当设置多大？OOM（OutOfMemoryError）异常到底涉及了运行时数据内存哪块区域？JVM 内存调优从哪里入手？\",\"在理解了 JVM 内存模型后，我们就可以知道，平常编写的 Java 文件信息是如何被 JVM 管理、存放，Java 方法执行时生成的变量、返回结果等 JVM 又是如何操作，堆内存大小如何设置等等。\"]},\"58\":{\"h\":\"JVM 内存模型\",\"t\":[\"Java 程序的开发，并不需要像 C/C++ 开发一样时刻关注内存的释放，而是全权交由 JVM 去管理，JVM 内存模型主要是指运行时内存模型，分为 线程私有 和 线程共享 数据区两大类：\",\"线程私有：程序计数器、虚拟机栈、本地方法栈；\",\"线程共享：Java 堆（Heap）、方法区（包含运行时常量池）。\",\"线程私有数据区域生命周期与线程相同，依赖用户线程的启动（结束）而创建（销毁）；线程共享数据区域则随虚拟机的启动（关闭）而创建（销毁）。\",\"JVM 内存模型结构图（绿色共享，橙色私有）：\",\"内存模型\"]},\"59\":{\"h\":\"程序计数器（私有）\",\"t\":[\"程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器，每个线程都有一个独立的计数器，互不影响。通过该计数器，JVM 解释器就知道下一步要执行的字节码指令位置，而分支、循环、跳转、异常处理、线程恢复等基础功能也都依赖于该计数器来实现。\",\"如果线程正在执行的是一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，若为 Native 方法，则计数器的值为空（Undefined），并且该内存区域是唯一一个在虚拟机中没有规定任何 OOM 异常情况的区域。\"]},\"60\":{\"h\":\"虚拟机栈（私有）\",\"t\":[\"是描述 Java 方法执行的内存模型，每个方法（不含 Native）在执行时都会创建一个栈帧，方法执行过程，就对应着虚拟机栈的入栈到出栈的过程。（现在明白平常用 IDE 调试时点击 Drop Frame 是回退到方法执行前的原因了吧 (●’◡’●)）\"]},\"61\":{\"h\":\"栈帧（Stack Frame）结构\",\"t\":[\"局部变量表\",\"操作栈\",\"动态链接\",\"方法返回地址\",\"额外附加信息\",\"栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。\"]},\"62\":{\"h\":\"异常（Exception）\",\"t\":[\"JVM 规范规定该区域有两种异常：\",\"StackOverFlowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出；\",\"OutOfMemoryError：当 JVM 动态扩展到无法申请足够内存时抛出。\"]},\"63\":{\"h\":\"本地方法栈（私有）\",\"t\":[\"本地方法栈的作用其实与虚拟机栈类似，区别只在于 本地方法栈是为 Native 方法 服务，而虚拟机栈是为 Java 方法 服务。虚拟机规范中对本地方法栈中的方法使用的语言、方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。有的虚拟机实现也将本地方法栈和虚拟机栈合并，如 HotSpot 虚拟机。\",\"对于异常抛出规范，也与虚拟机栈相同，分别是 StackOverFlowError 和 OutOfMemoryError。\"]},\"64\":{\"h\":\"堆（共享）\",\"t\":[\"Java 堆（Heap）是 JVM 管理的最大的一块内存，也是 GC（Garbage Collection，垃圾收集）的重点照顾对象，存放的是几乎所有的对象实例和数组数据。（JIT 编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在 Java 堆，而是栈内存）\",\"由于主流 JVM 实现对于 GC 采用分代收集算法，因此从 GC 角度来看，Java 堆可分为：\",\"新生代（Eden 区、From Servivor 区、To Servivor 区）\",\"老年代\",\"可以简单的理解新生代主要是存放新创建的对象，而老年代则是存放生命周期或存活时间较长的对象。并且 JVM 在新生代的 Eden 区开辟了一小块内存区域，即 分配缓冲区（TLAB - Thread-local allocation buffer，线程私有），因为 Java 程序中很多对象都是小对象且用过即丢，不存在线程共享和适合被快速 GC ，所以小对象通常会被 JVM 优先分配在 TLAB 上，好处是分配内存效率高。\"]},\"65\":{\"h\":\"异常（Exception）\",\"t\":[\"JVM 规范规定该区域可抛出异常： OutOfMemoryError，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时抛出。\"]},\"66\":{\"h\":\"方法区（共享）\",\"t\":[\"方法区主要存放的是虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等，而 GC 在此区域出现频率较低，主要针对的是常量池的回收和类型的卸载，GC 不会在主程序运行期对方法区进行清理，所以容易随着加载的 Class 增多导致类膨胀，从而引发 OutOfMemoryError 异常。\",\"方法区也常被称为**“永久代（Permanent Generation）”**，这是因为 **HotSpot 虚拟机（Sun JDK 和 Open JDK 自带的虚拟机实现）**的设计团队选择把 GC 分代收集扩展至方法区（也可以理解为是用永久代方法实现了方法区），从而在 GC 方面与 Java 堆保持一致。\",\"在 Java 8 后，永久代则被替换为**“元空间（Metaspace）”**，当然了，后者依然是基于 HotSpot 虚拟机，两者区别主要在于：元空间并不在虚拟机中，而是使用本地内存。因此元空间的大小仅受本地内存限制，基本不存在 OOM 异常问题。并且类的元数据放入本地内存，字符串池和静态变量等则放入到 Java 堆中。\"]},\"67\":{\"h\":\"运行时常量池\",\"t\":[\"作为方法区的一部分，用于存放编译期生产的各种字面量和符号引用，运行时常量池除了编译期产生的 Class 文件的常量池，还可以在运行期间，将新的常量加入常量池，比如 String 类的 intern() 方法。该区域不会抛出 OutOfMemoryError 异常。\",\"字面量：与 Java 语言层面的常量概念相近，包含文本字符串、声明为 final 的常量值等；\",\"符号引用：编译语言层面的概念，包括以下三类： \",\"类和接口的全限定名；\",\"字段的名称和描述符；\",\"方法的名称和描述符。\"]},\"68\":{\"h\":\"补充\",\"t\":[\"关于堆、栈内存的大小设置，可以通过 IDE（IDEA、Eclipse）或 Web 容器（Tomcat ）等来配置，可通过下图来了解参数所控制的区域分别是什么。\",\"堆栈设置\",\"参数控制：\",\"-Xms：设置堆的最小空间大小；\",\"-Xmx：设置堆的最大空间大小；\",\"-XX:NewSize：设置新生代最小空间大小；\",\"-XX:MaxNewSize：设置新生代最大空间大小；\",\"-XX:PermSize：设置永久代最小空间大小；（JDK 8 后无效）\",\"-XX:MaxPermSize：设置永久代最大空间大小；（JDK 8 后无效）\",\"-XX:MetaspaceSize：设置元空间最小空间大小；（JDK 8 后有效）\",\"-XX:MaxMetaspaceSize：设置元空间最大空间大小；（JDK 8 后有效）\",\"-Xss：设置每个线程的堆栈大小。\"]},\"69\":{\"h\":\"总结\",\"t\":[\"本篇主要说明 JVM 内存结构及其概念，意在让大伙了解 JVM 结构是个什么样子，而了解 JVM 是如何管理内存、如何处理 Java 程序运行所产生的数据，可以启发我们在内存管理、性能分析和调优方面的思维。作为 Java 开发者，想要强化个人的技术，扩展自己的思维，JVM 是一道必须攻破的关卡。\"]},\"70\":{\"h\":\"参考资料\",\"t\":[\"《深入理解Java虚拟机》第2章 / 周志明 / 机械工业出版社\",\"《Java虚拟机规范》/ 作者:Tim Lindholm、Frank Yellin 等 / 译者:爱飞翔、周志明等 / 机械工业出版社\",\"技术博客：Java 虚拟机：JVM 内存模型，作者：方志朋\"]},\"71\":{\"h\":\"花絮\",\"t\":[\"本篇是我第一次编写的博客文章，之所以以 JVM 知识为开头，也是因为对于 JVM 的内容一直都是仅凭记忆，就导致容易遗忘，而且很多知识点都是零零散散，没有连结成知识网，也没有做一些知识记录，加上本人也想通过搭建一个博客网站，来总结自己一路学习的技术和知识，并分享给别人，因此便有了这个开头。\",\"博客的编写，尤其是技术类，要考虑的细节还是挺多，如技术原理、常用实现方式、个人实际使用经验、流行程度、更新迭代等。总的来说，这对于我个人的知识总结能力也大有脾益，对一门新技术，我崇尚的是从不会、到了解掌握、再到能讲解给别人听让别人理解。\",\"路漫漫其修远兮，吾将上下而求索。\"]},\"72\":{\"c\":[\"Java\"]},\"73\":{\"c\":[\"Java\",\"JVM\"]},\"74\":{\"h\":\"为什么 OAuth 在 2023 年仍然难以实现？\"},\"75\":{\"h\":\"写在前头\",\"t\":[\"本篇是 Why is OAuth still hard in 2023? 一文的中文翻译（由沉浸式翻译提供并优化了下排版），文章内容翔实，说明了 OAuth 的复杂性、安全性、实际应用困难等方面的问题。\",\"以下是太长不看版（由 AI 整理）：\",\"这篇文章讨论了为什么 OAuth 在 2023 年仍然难以实现。作者们通过为 50 个最受欢迎的 API 实现 OAuth 的经验得出结论，OAuth 实际应用中的体验类似于 2008 年的 JavaScript 浏览器 API。尽管有一个通用的共识关于如何实现 OAuth，但每个 API 实际上都有自己对标准的解释、实现上的怪癖、非标准行为和扩展。\",\"文章中提到的问题包括：\",\"OAuth 标准过于庞大和复杂：OAuth 2.0 标准包含了 17 个不同的 RFC（定义标准的文档），覆盖了从 OAuth 框架到威胁模型和私钥 JWT 的所有内容。尽管不是所有 RFC 对于简单的第三方访问令牌授权都是相关的，但即使只关注相关的部分，也足以让人感到复杂。\",\"每个 API 的 OAuth 实现都有细微差异：由于每个 API 实现的 OAuth 子集不同，开发者需要详细阅读每个 API 的 OAuth 文档，了解所需的参数、请求方式、重定向 URL 等。\",\"许多 API 添加了非标准的 OAuth 扩展：尽管 OAuth 标准已经非常广泛，但许多 API 仍然觉得需要添加一些非标准的功能。这意味着开发者需要为每个 API 实现特定的逻辑。\",\"调试 OAuth 流程困难：OAuth2 有标准化的错误消息，但它们通常无法提供足够的信息来帮助开发者调试问题。文档错误、缺失细节或未更新的情况很常见，导致 OAuth 流程在首次实施时经常遇到问题。\",\"基于 API 的构建需要繁琐的批准流程：许多流行的 API 需要开发者提交审核，这个过程可能需要数天甚至数月才能完成。有些 API 甚至要求开发者与他们签订收入分成协议。\",\"OAuth 安全性难以把握且不断变化：随着攻击手段的发现和网络技术的发展，OAuth 标准也在不断变化。新的安全最佳实践，如即将到来的 OAuth 2.1 标准，将使一些当前的最佳实践成为强制性要求。\",\"文章最后提到，作者正在开发一个名为 Nango 的开源服务，它提供了预构建的 OAuth 流程、安全的令牌存储和自动令牌刷新功能，支持超过 90 个 OAuth API。欢迎读者尝试使用并提供反馈。\",\"以下是原文+翻译：\"]},\"76\":{\"h\":\"为什么 2023 年 OAuth 仍然很难？ Why is OAuth still hard in 2023?\",\"t\":[\"We implemented OAuth for the 50 most popular APIs. TL;DR: It is still a mess. 我们为 50 个最流行的 API 实现了 OAuth。TL;DR（Tong long, did't read）：仍然是一团糟。\",\"OAuth is a standard protocol. Right? And there are client libraries for OAuth 2.0 availableinbasicallyeveryprogramminglanguageyoucanimagine. OAuth 是一个标准协议。正确的？基本上您能想象到的每种编程语言都有适用于 OAuth 2.0 的客户端库。\",\"You might conclude that, armed with a client library, you would be able to implement OAuth for any API in about 10 minutes. Or at least in an hour. 您可能会得出结论，配备客户端库后，您将能够在大约 10 分钟内为任何 API 实现 OAuth。或者至少一个小时内。\",\"If you manage, please email us — we’d like to treat you to a delicious dinner and hear how you did it. 如果您成功了，请给我们发电子邮件——我们很乐意请您享用一顿美味的晚餐，并听听您是如何做到的。\"]},\"77\":{\"h\":\"OAuth 实践 OAuth in practice\",\"t\":[\"We implemented OAuth for the 50 most popular APIs, such as Google (Gmail, Calendar, Sheets etc.), HubSpot, Shopify, Salesforce, Stripe, Jira, Slack, Microsoft (Azure, Outlook, OneDrive), LinkedIn, Facebook and other OAuth APIs.‍ 我们为 50 个最流行的 API 实现了 OAuth，例如 Google（Gmail、日历、表格等）、HubSpot、Shopify、Salesforce、Stripe、Jira、Slack、Microsoft（Azure、Outlook、OneDrive）、LinkedIn、Facebook 和其他 OAuth蜜蜂\",\"Our conclusion: The real-world OAuth experience is comparable to JavaScript browser APIs in 2008. There’s a general consensus on how things should be done, but in reality every API has its own interpretation of the standard, implementation quirks, and nonstandard behaviors and extensions. The result: footguns behind every corner. 我们的结论：现实世界的 OAuth 体验可与 2008 年的 JavaScript 浏览器 API 相媲美。对于应该如何完成工作存在普遍共识，但实际上每个 API 对标准、实现怪癖以及非标准行为和扩展都有自己的解释。结果是：每个角落后面都有枪。\",\"If it weren’t so annoying, it would be quite funny. Let’s dive in! 如果不是那么烦人的话，那就很有趣了。让我们深入了解一下！\"]},\"78\":{\"h\":\"问题 1：OAuth 标准太大且复杂 Problem 1: The OAuth standard is just too big and complex\",\"t\":[\"“This API also uses OAuth 2.0, and we already did that a few weeks ago. I should be done by tomorrow.” “这个 API 还使用 OAuth 2.0，我们几周前就已经这样做了。我应该在明天之前完成。” – Famous last words from the intern ——实习生著名的遗言\",\"OAuth is a very big standard. The OAuth 2.0’s official site currently lists 17 different RFCs (documents defining a standard) that together define how OAuth 2 works. They cover everything from the OAuth framework and Bearer tokens to threat models and private key JWTs. OAuth 是一个非常大的标准。 OAuth 2.0 的官方网站目前列出了 17 个不同的 RFC（定义标准的文档），它们共同定义了 OAuth 2 的工作方式。它们涵盖了从 OAuth 框架和 Bearer 令牌到威胁模型和私钥 JWT 的所有内容。\",\"“But,” I hear you say, “surely not all of these RFCs are relevant for a simple third-party-access token authorization with an API?” “但是，”我听到您说，“肯定不是所有这些 RFC 都与使用 API 的简单第三方访问令牌授权相关吗？” You’re right. Let’s focus only on the things that are likely to be relevant for the typical API third-party-access use case: 是的。让我们只关注可能与典型 API 第三方访问用例相关的内容：\",\"OAuth standard: OAuth 2.0 is the default now, but OAuth 1.0a is still used by some (and 2.1 is around the corner). Once you know which one your API uses, move on to: OAuth 标准：OAuth 2.0 现在是默认值，但 OAuth 1.0a 仍然被一些人使用（2.1 即将推出）。一旦您知道您的 API 使用哪一个，请继续：\",\"Grant type: Do you need authorization_code, client_credentials, or device_code? What do they do, and when should you use each of them? When in doubt, try authorization_code. 授权类型：您需要 authorization_code、client_credentials 或 device_code 吗？它们有什么作用，什么时候应该使用它们？如有疑问，请尝试 authorization_code。\",\"Side note: Refresh tokens are also a grant type, but kind of a special one. How they work is standardized, but how you ask for them in the first place is not. More on that later. 旁注：刷新令牌也是一种授予类型，但有点特殊。它们的工作方式是标准化的，但您最初要求它们的方式却不是标准化的。稍后会详细介绍。\",\"Now that you’re ready for your requests, let’s look at the many (72, to be precise) official OAuth parameters with a defined meaning and behavior. Common examples are prompt, scope, audience, resource, assertion, and login_hint. However, in our experience, most API providers seem to be as oblivious to this list as you probably were until now, so don't worry too much about it. 现在您已准备好接收请求，让我们看一下许多（准确地说是 72 个）具有定义含义和行为的官方 OAuth 参数。常见示例有提示、范围、受众、资源、断言和登录提示。然而，根据我们的经验，大多数 API 提供商似乎都像您到目前为止一样忽视了此列表，因此不必太担心。\",\"If you think this still feels too complicated and like a lot to learn, we tend to agree with you. 如果您认为这仍然感觉太复杂并且需要学习很多东西，我们倾向于同意您的观点。\",\"Most teams building public APIs seem to agree as well. Instead of implementing a full OAuth 2.0 subset, they just implement the parts of OAuth they think they need for their API’s use case. This leads to pretty long pages in docs outlining how OAuth works for this particular API. But we have a hard time blaming them; they have only the best intentions in mind for their DX. And if they truly tried to implement the full standard, you’d need to read a small book! 大多数构建公共 API 的团队似乎也同意这一点。他们没有实现完整的 OAuth 2.0 子集，而是只实现他们认为 API 用例所需的 OAuth 部分。这导致文档中出现相当长的页面来概述 OAuth 如何针对此特定 API 工作。但我们很难责怪他们；他们对 DX 的想法只有最好的。如果他们真的尝试实施完整的标准，您需要阅读一本小书！\",\"The Salesforce authorization_code OAuth flow. What's not to like about a clear visual for this simple 10-step process? Salesforce 授权代码 OAuth 流程。为什么不喜欢这个简单的 10 步流程的清晰视觉效果呢？\",\"The trouble is that everybody has a slightly different idea of which subset of OAuth is relevant for them, so you end up with lots of different (sub-) implementations. 问题在于，每个人对于 OAuth 的哪个子集与他们相关的想法都略有不同，因此最终会得到许多不同的（子）实现。\"]},\"79\":{\"h\":\"问题 2：每个人的 OAuth 都有细微的差别 Problem 2: Everybody’s OAuth is different in subtle ways\",\"t\":[\"As every API implements a different subset of OAuth, you quickly get into a situation where you are forced to read their long pages of OAuth docs in detail: 由于每个 API 都实现 OAuth 的不同子集，因此您很快就会陷入被迫详细阅读其长页 OAuth 文档的情况：\",\"Which parameters do they require in the authorize call? 他们在授权调用中需要哪些参数？\",\"For Jira, the audience parameter is key (and must be set to a specific fixed value). Google prefers to handle this through different scopes but really cares about the prompt parameter. Meanwhile, somebody at Microsoft discovered the response_mode parameter and demands that you always set it to query. 对于 Jira 来说，受众参数是关键（并且必须设置为特定的固定值）。谷歌更喜欢通过不同的范围来处理这个问题，但真正关心的是提示参数。与此同时，微软的某人发现了response_mode参数并要求你始终将其设置为查询。\",\"The Notion API takes a radical approach and does away with the ubiquitous scope parameter. In fact, you won’t even find the word “scope” in their API docs. Notion calls them “capabilities,” and you set them when you register the app. It took us 30 confused minutes to understand what was going on. Why did they reinvent this wheel? Notion API 采用了一种激进的方法，取消了无处不在的作用域参数。事实上，您甚至在他们的 API 文档中找不到“范围”这个词。 Notion 将它们称为“功能”，您可以在注册应用程序时设置它们。我们困惑地花了 30 分钟才明白发生了什么事。他们为什么要重新发明这个轮子？\",\"It gets worse with offline_access: Most APIs these days expire access tokens after a short while. To get a refresh token, you need to request “offline_access,” which needs to be done through a parameter, a scope, or something you set when you register your OAuth app. Ask your API or OAuth doctor for details. Offline_access 的情况会变得更糟：现在大多数 API 的访问令牌都会在短时间内过期。要获取刷新令牌，您需要请求“offline_access”，这需要通过参数、范围或注册 OAuth 应用程序时设置的内容来完成。请咨询您的 API 或 OAuth 医生了解详细信息。\",\"What do they want to see in the token request call? 他们希望在令牌请求调用中看到什么？\",\"Some APIs, like Fitbit, insist on getting data in the headers. Most really want it in the body, encoded as x-www-url-form-encoded, except for a few, such as Notion, which prefer to get it as JSON. 一些 API（例如 Fitbit）坚持在标头中获取数据。大多数人确实希望它在正文中，编码为 x-www-url-form-encoded，但少数人（例如 Notion）更喜欢将其编码为 JSON。\",\"Some want you to authenticate this request with Basic auth. Many don’t bother with that. But beware, they may change their mind tomorrow. 有些人希望您使用基本身份验证来验证此请求。许多人对此不屑一顾。但要小心，他们明天可能会改变主意。\",\"Where should I redirect my users to authorize? 我应该将用户重定向到哪里进行授权？\",\"Shopify and Zendesk have a model in which every user gets a subdomain like {subdomain}.myshopify.com. And yes, that includes the OAuth authorization page, so you’d better build dynamic URLs into your model and frontend code. Shopify 和 Zendesk 有一个模型，其中每个用户都会获得一个子域，例如 {subdomain}.myshopify.com。是的，其中包括 OAuth 授权页面，因此您最好将动态 URL 构建到模型和前端代码中。\",\"Zoho Books has different data centers for their customers in different locations. Hopefully, they remember where their data resides: To authorize your app, your U.S. customers should go to https://accounts.zoho.com, Europeans can visit https://accounts.zoho.eu, and Indians are welcome at https://accounts.zoho.in. The list goes on. Zoho Books 在不同地点为客户提供不同的数据中心。希望他们记住数据所在的位置：要授权您的应用程序，您的美国客户应访问 https://accounts.zoho.com，欧洲客户可以访问 https://accounts.zoho.eu，欢迎印度客户访问 https://accounts.zoho.in。这样的例子还在继续。\",\"But at least I can pick my callback URL, no? 但至少我可以选择我的回调 URL，不是吗？\",\"If you enter http://localhost:3003/callback as a callback for the Slack API, they kindly remind you to “Please use https for security.” Yes, also for localhost. Luckily there are solutions for OAuth redirects on localhost. 如果您输入 http://localhost:3003/callback 作为 Slack API 的回调，他们会善意地提醒您“为了安全起见，请使用 https”。是的，也适用于本地主机。幸运的是，本地主机上有 OAuth 重定向的解决方案。\",\"We could go on for a long time, but we think you probably get the point by now. 我们可以继续说很长时间，但我们认为您现在可能已经明白了要点。\",\"OAuth is too complex; let’s make a simpler version of OAuth that has everything we need! ©XKCDOAuth太复杂；让我们制作一个更简单的 OAuth 版本，其中包含我们需要的一切！ ©XKCD\"]},\"80\":{\"h\":\"问题 3：许多 API 向 OAuth 添加非标准扩展 Problem 3: Many APIs add nonstandard extensions to OAuth\",\"t\":[\"Even though the OAuth standard is vast, many APIs still seem to find gaps in it for features they need. A common issue we see is that you need some data in addition to the access_token to work with the API. Wouldn’t it be neat if this additional data could be returned to you together with the access_token in the OAuth flow? 尽管 OAuth 标准很庞大，但许多 API 似乎仍然在其中找到了它们所需功能的空白。我们看到的一个常见问题是，除了 access_token 之外，您还需要一些数据才能使用 API。如果这些附加数据可以与 OAuth 流程中的 access_token 一起返回给您，岂不是很完美？\",\"We actually think this is a good idea — orr at least it’s better than forcing users to do quirky additional API requests afterward to fetch this information (looking at you, Jira). But it does mean more nonstandard behavior that you specifically need to implement for every API. 我们实际上认为这是一个好主意 - 或者至少它比强迫用户随后执行奇怪的额外 API 请求来获取此信息要好（看着你，Jira）。但这确实意味着您特别需要为每个 API 实现更多非标准行为。\",\"Here’s a small list of nonstandard extensions we have seen: 以下是我们见过的一小部分非标准扩展：\",\"Quickbooks employs a realmID, which you need to pass in with every API request. The only time they tell you this realmID is as an additional parameter in the OAuth callback. Better store it somewhere safe! Quickbooks 使用realmID，您需要在每个API 请求中传递该realmID。他们唯一一次告诉您此 RealmID 是作为 OAuth 回调中的附加参数。最好将其存放在安全的地方！\",\"Braintree does the same with a companyID Braintree 对 companyID 执行同样的操作\",\"Salesforce uses a different API base URL for each customer; they call this the instance_url. Thankfully, they return the instance_url of the user together with the access token in the token response, but you do need to parse it out from there and store it. Salesforce 为每个客户使用不同的 API 基本 URL；他们称之为instance_url。值得庆幸的是，它们返回用户的 instance_url 以及令牌响应中的访问令牌，但您确实需要从那里解析它并存储它。\",\"Unfortunately, the Salesforce API also does even more annoying things: Access tokens expire after a preset period of time, which can be customized by the user. Fine so far, but for some reason they don’t tell you in the token response when the access token you just received will expire (everybody else does this). Instead, you need to query an additional token details endpoint to get the (current) expiration date of the token. Why, Salesforce, why? 不幸的是，Salesforce API 还做了更烦人的事情：访问令牌会在预设时间段后过期，该时间段可以由用户自定义。到目前为止还好，但由于某种原因，他们不会在令牌响应中告诉您刚刚收到的访问令牌何时过期（其他人都会这样做）。相反，您需要查询额外的令牌详细信息端点以获取令牌的（当前）到期日期。为什么，Salesforce，为什么？\",\"Slack has two different types of scopes: scopes you hold as a Slack bot and scopes that allow you to take action on behalf of the user who authorized your app. Smart, but instead of just adding different scopes for each, they implemented a separate user_scopes parameter that you need to pass in the authorization call. You’d better be aware of this, and good luck finding support for this in your OAuth library. Slack 有两种不同类型的范围：您作为 Slack 机器人持有的范围和允许您代表授权您的应用程序的用户采取操作的范围。很聪明，但他们不是仅仅为每个范围添加不同的范围，而是实现了一个单独的 user_scopes 参数，您需要在授权调用中传递该参数。您最好意识到这一点，并祝您好运在您的 OAuth 库中找到对此的支持。\",\"For the sake of brevity and simplicity, we’re skipping the many not-really-standard OAuth flows we have encountered. 为了简洁起见，我们跳过了我们遇到的许多不真正标准的 OAuth 流程。\"]},\"81\":{\"h\":\"问题 4：“invalid_request”——调试 OAuth 流程很困难 Problem 4: “invalid_request” — debugging OAuth flows is hard\",\"t\":[\"Debugging distributed systems is always hard. It’s harder when the service you’re working with uses broad, generic error messages. 调试分布式系统总是很困难。当您使用的服务使用广泛的通用错误消息时，事情会变得更加困难。\",\"OAuth2 has standardized error messages, but they’re about as useful in telling you what’s going on as the example in the title above (which, by the way, is one of the recommended error messages from the OAuth standard). OAuth2 具有标准化的错误消息，但它们在告诉您正在发生的情况方面与上面标题中的示例一样有用（顺便说一下，这是 OAuth 标准中推荐的错误消息之一）。\",\"You could argue that OAuth is a standard and that there are docs for every API, so what is there to debug? 您可能会说 OAuth 是一个标准，每个 API 都有文档，那么有什么可调试的呢？ A lot. I cannot tell you how often the docs are wrong. Or missing a detail. Or have not been updated for the latest change. Or you missed something when you first looked at them. A good 80% of the OAuth flows we implement have some problem upon first implementation and require debugging. 很多。我无法告诉你文档出错的频率有多少。或者遗漏了一个细节。或者尚未更新最新的更改。或者当你第一次看到它们时你错过了一些东西。我们实现的 OAuth 流程中有 80% 在首次实现时都存在一些问题，需要调试。\",\"How did Randall observe me while I was debugging OAuth flows? ©XKCD当我调试 OAuth 流程时，Randall 如何观察我？ ©XKCD\",\"Some flows also break for, what seem to be, random reasons: LinkedIn OAuth, for instance, breaks if you pass in PKCE parameters. The error you get? “client error - invalid OAuth request.” That is … telling? It took us an hour to understand that passing in (optional, usually disregarded) PKCE parameters is what breaks the flow. 有些流程也会因随机原因而中断：例如，如果您传入 PKCE 参数，LinkedIn OAuth 就会中断。你得到的错误是？ “客户端错误 - OAuth 请求无效。”这就是……告诉我们？我们花了一个小时才明白传入（可选的，通常被忽略的）PKCE 参数是破坏流程的原因。\",\"Another common mistake is sending scopes that don’t match the ones you preregistered with the app. (Preregister scopes? Yes, a lot of APIs these days demand that.) This often results in a generic error message about there being an issue with scopes. Duh. 另一个常见的错误是发送的范围与您在应用程序中预先注册的范围不匹配。 （预注册范围？是的，现在很多 API 都要求这样做。）这通常会导致出现有关范围存在问题的通用错误消息。\"]},\"82\":{\"h\":\"问题 5：基于 API 构建的审批繁琐 Problem 5: Cumbersome approvals to build on top of APIs\",\"t\":[\"The truth is, if you build toward some other system by using their API, you’re probably in the weaker position. Your customers are asking for the integration because they’re already using the other system. Now you need to make them happy. 事实是，如果您使用其他系统的 API 进行构建，您可能会处于较弱的位置。您的客户要求集成，因为他们已经在使用其他系统。现在你需要让他们开心。\",\"To be fair, many APIs are liberal and provide easy self-service signup flows for developers to register their apps and start using OAuth. But some of the most popular APIs out there require reviews before your app becomes public and can be used by any of their users. Again, to be fair, most review processes are sane and can be completed in a few days. They’re probably a net gain in terms of security and quality for end users. 公平地说，许多 API 都是自由的，并为开发人员提供简单的自助注册流程来注册他们的应用程序并开始使用 OAuth。但一些最流行的 API 在您的应用程序公开并可供任何用户使用之前需要经过审核。再次强调，公平地说，大多数审核流程都是合理的，并且可以在几天内完成。对于最终用户来说，它们可能在安全性和质量方面带来净收益。\",\"But some notorious examples can take months to complete, and some even require you to enter into revenue-share agreements: 但一些臭名昭著的例子可能需要几个月的时间才能完成，有些甚至要求您签订收入分成协议：\",\"Google requires a “security review” if you want to access scopes with more sensitive user data, such as email contents. We have heard these reviews can take days or weeks to pass and require a nontrivial amount of work on your side. 如果您想访问包含更敏感用户数据（例如电子邮件内容）的范围，Google 需要进行“安全审查”。我们听说这些审核可能需要几天或几周的时间才能通过，并且需要您做大量的工作。\",\"Looking to integrate with Rippling? Get ready for their 30-plus questions and security preproduction screening. We hear access takes months (if you are approved). 想要与 Ripple 集成吗？准备好接受 30 多个问题和安全预生产筛查。我们听说访问需要几个月的时间（如果您获得批准）。\",\"HubSpot, Notion, Atlassian, Shopify, and pretty much everybody else who has an integrations marketplace or app store requires a review to get listed there. Some reviews are mild, and some ask you for demo logins, video walkthroughs, blog posts (yes!), and more. However, listing on the marketplace or store is often optional. HubSpot、Notion、Atlassian、Shopify 以及几乎所有拥有集成市场或应用程序商店的其他人都需要经过审核才能在其中列出。有些评论很温和，有些则要求您提供演示登录、视频演练、博客文章（是的！）等等。然而，在市场或商店上列出通常是可选的。\",\"Ramp, Brex, Twitter, and a good number of others don’t have a self-service signup flow for developers and require that you fill in forms for manual access. Many are quick to process requests, but we’re still waiting to hear back from some after weeks. Ramp、Brex、Twitter 和许多其他网站没有为开发人员提供自助注册流程，需要您填写表格才能手动访问。许多人都会很快处理请求，但我们仍在等待几周后的回复。\",\"Xero is a particularly drastic example of a monetized API: If you want to exceed a limit of 25 connected accounts, you have to become a Xero partner and list your app in their app store. They will then take (as of the time of this writing) a 15% revenue cut from every lead generated from that store. Xero 是货币化 API 的一个特别激烈的例子：如果您想超过 25 个连接帐户的限制，您必须成为 Xero 合作伙伴并在他们的应用商店中列出您的应用程序。然后，他们将从该商店产生的每条销售线索中扣除 15% 的收入（截至撰写本文时）。\"]},\"83\":{\"h\":\"问题 6：OAuth 安全性很困难且目标不断变化 Problem 6: OAuth security is hard and a moving target\",\"t\":[\"As attacks have been uncovered, and the available web technologies have evolved, the OAuth standard has changed as well. If you’re looking to implement the current security best practices, the OAuth working group has a rather lengthy guide for you. And if you’re working with an API that is still using OAuth 1.0a today, you realize that backwards compatibility is a never-ending struggle. 随着攻击的被发现以及可用的 Web 技术的发展，OAuth 标准也发生了变化。如果您希望实施当前的安全最佳实践，OAuth 工作组为您提供了相当冗长的指南。如果您现在使用的 API 仍在使用 OAuth 1.0a，您就会意识到向后兼容性是一场永无休止的斗争。\",\"Luckily, security is getting better with every iteration, but it often comes at the cost of more work for developers. The upcoming OAuth 2.1 standard will make some current best practices mandatory and includes mandatory PKCE (today only a handful of APIs require this) and additional restrictions for refresh tokens. 幸运的是，安全性随着每次迭代而变得越来越好，但这通常是以开发人员付出更多工作为代价的。即将推出的 OAuth 2.1 标准将强制执行一些当前的最佳实践，并包括强制的 PKCE（目前只有少数 API 需要此）以及刷新令牌的附加限制。\",\"At least OAuth already implements a two-factor auth model. ©XKCD至少 OAuth 已经实现了双因素身份验证模型。 ©XKCD\",\"The biggest change has probably been ushered in with expiring access tokens and the rise of refresh tokens. On the surface, the process seems simple: Whenever an access token expires, refresh it with the refresh token and store the new access token and refresh token. 最大的变化可能是随着访问令牌的过期和刷新令牌的兴起而带来的。从表面上看，该过程似乎很简单：每当访问令牌过期时，使用刷新令牌刷新它并存储新的访问令牌和刷新令牌。\",\"In reality, when we implemented this we had to consider: 事实上，当我们实现这一点时，我们必须考虑：\",\"Race conditions: How can we make sure no other requests run while we refresh the current access token? 竞争条件：如何确保在刷新当前访问令牌时没有其他请求运行？\",\"Some APIs also expire the refresh token if you don’t use it for a certain number of days (or if the user has revoked the access). Expect some refreshes to fail. 如果您在一定天数内不使用刷新令牌（或者用户已撤销访问权限），某些 API 也会使刷新令牌过期。预计某些刷新会失败。\",\"Some APIs issue you a new refresh token with every refresh request … 有些 API 在每次刷新请求时都会向您发出一个新的刷新令牌……\",\"… but some also silently assume that you will keep the old refresh token and keep on using it. …但有些人也默默地假设您将保留旧的刷新令牌并继续使用它。\",\"Some APIs will tell you the access token expiration time in absolute values. Others only in relative “seconds from now.” And some, like Salesforce, don’t divulge this kind of information easily. 某些 API 会以绝对值形式告诉您访问令牌过期时间。其他的则仅在相对“从现在开始的几秒钟内”发生。有些公司（例如 Salesforce）不会轻易泄露此类信息。\"]},\"84\":{\"h\":\"最后但并非最不重要的一点：有些事情我们还没有讨论过 Last but not least: Some things we haven’t talked about yet\",\"t\":[\"Sadly, we have only just scratched the surface of your OAuth implementation. Now that your OAuth flow runs and you get access tokens, it’s time to think about: 遗憾的是，我们仅仅触及了 OAuth 实现的皮毛。现在您的 OAuth 流程已运行并且您获得了访问令牌，是时候考虑以下问题了：\",\"How to securely store these access tokens and refresh tokens. They are like passwords to your users’ accounts. But hashing is not an option; you need secure, reversible encryption. 如何安全地存储这些访问令牌和刷新令牌。它们就像用户帐户的密码。但散列不是一种选择；而是一种选择。您需要安全、可逆的加密。\",\"Checking that the granted scopes match the requested scopes (some APIs allow users to change the scopes they grant in the authorize flow). 检查授予的范围是否与请求的范围匹配（某些 API 允许用户更改他们在授权流程中授予的范围）。\",\"Avoiding race conditions when refreshing tokens. 刷新令牌时避免竞争条件。\",\"Detecting access tokens revoked by the user on the provider side. 检测提供商端用户撤销的访问令牌。\",\"Letting users know that access tokens have expired, so they can re-authorize your app if needed. 让用户知道访问令牌已过期，以便他们可以在需要时重新授权您的应用程序。\",\"How to revoke access tokens you no longer need (or that the user has requested you delete under GDPR). 如何撤销您不再需要的访问令牌（或者用户根据 GDPR 要求删除的访问令牌）。\",\"Changes in available OAuth scopes, provider bugs, missing documentation, and so on. 可用 OAuth 范围的更改、提供程序错误、缺少文档等。\"]},\"85\":{\"h\":\"有更好的方法吗？ A better way?\",\"t\":[\"If you’ve read this far, you might be thinking, “There must be a better way!” 如果您读到这里，您可能会想：“一定有更好的方法！”\",\"We think there is, which is why we’re building Nango: An open-source, self-contained service that comes with prebuilt OAuth flows, secure token storage, and automatic token refreshes for more than 90 OAuth APIs. 我们认为是存在的，这就是我们构建 Nango 的原因：一种开源、独立的服务，附带预构建的 OAuth 流程、安全令牌存储以及针对 90 多个 OAuth API 的自动令牌刷新。\",\"If you give it a try, we’d love to hear your feedback. And if you want to share your worst OAuth horror story with us, we’d love to hear about it in our Slack community. 如果您尝试一下，我们很乐意听到您的反馈。如果您想与我们分享您最糟糕的 OAuth 恐怖故事，我们很乐意在 Slack 社区中听到它。\",\"Thanks for reading and happy authorizing!\\n感谢您的阅读并快乐授权！\"]},\"86\":{\"c\":[\"杂谈\"]},\"87\":{\"c\":[\"杂谈\"]},\"88\":{\"h\":\"分片并不意味着分布式\"},\"89\":{\"h\":\"写在前头\",\"t\":[\"本篇是 Sharded Does Not Imply Distributed 一文的翻译。对于后端人员来说，分片的概念并不陌生，诸如 ElasticSearch、Redis、MySQL 等数据库都有针对于分片的实现方案来解决某些业务场景。文中对数据库分片与分布式数据库的主要区别做了说明，但请注意：分片数据库也是分布式系统。\",\"以下是太长不看版（由 AI 整理）：\",\"文章《分片并不意味着分布式》主要讨论了数据库分片（Sharding）与分布式数据库（Distributed Databases）之间的区别：\",\"分片（Sharding）：分片是一种技术，它通过将原始数据集拆分为多个分片（shards），并将这些分片分布在多个独立的数据库实例上来实现水平可扩展性。分片解决方案的关键组件是协调器（coordinator），它负责了解数据分布并映射客户端请求到特定的分片和数据库实例。分片数据库实例不相互通信，它们存在于孤立的环境中。\",\"分布式数据库：分布式数据库采用分片技术在数据库节点集群中分布数据和负载，但它们建立在无共享架构之上，不依赖于协调器组件。集群中的所有节点都了解彼此和数据分布，可以直接路由客户端请求到适当的分片所有者，并执行多节点事务。分布式数据库在扩展时会自动重新平衡和拆分分片，节点维护数据的冗余副本，即使部分节点故障也能继续操作。\",\"分片与分布式的区别：分片涉及将数据拆分到多个独立实例，但这并不意味着系统是分布式的（单机多实例）。分布式数据库则没有中央协调器，其节点相互了解，管理数据分布，并无缝处理客户端请求。\",\"数据库设计选择：理解分片和分布式数据库的细微差别对于数据库的设计和选择至关重要，因为它们各自有不同的优点和适用场景。\",\"文章也提到，如果读者对分片数据库架构感兴趣，可以考虑探索 CitusData 或 Azure CosmosDB for PostgreSQL、Vitess for MySQL、Oracle Distributed Autonomous Database 和 MongoDB Sharded Cluster。而对于真正的分布式数据库架构，可以考虑研究 Google Spanner、YugabyteDB、CockroachDB、Apache Cassandra 或 Apache Ignite。\",\"以下是原本+翻译：\"]},\"90\":{\"h\":\"分片并不意味着分布式 Sharded Does Not Imply Distributed\",\"t\":[\"Sharding is a technique that distributes data and load across several standalone database instances. This method leverages horizontal scalability by splitting the original dataset into shards, which are then distributed across multiple database instances. 分片是一种在多个独立数据库实例之间分配数据和负载的技术。此方法通过将原始数据集拆分为分片，然后将其分布在多个数据库实例中来利用水平可扩展性。\",\"But, even though the verb “distributes” appears in the definition of sharding, a sharded database is not a distributed one. 但是，即使分片的定义中出现了动词“分布”，分片数据库也不是分布式数据库。\"]},\"91\":{\"h\":\"分片解决方案 Sharding Solutions\",\"t\":[\"Every sharding solution has one critical component in its architecture. This component can go by various names, including coordinator, router, or director: 每一种分片解决方案的架构中都有一个关键组件。该组件可以有各种名称，包括协调器、路由器或导向器：\",\"The coordinator is the sole component aware of data distribution. It maps client requests to specific shards and then to the corresponding database instance. This is why clients must always route their requests through the coordinator. 协调器是唯一了解数据分布的组件。它将客户端请求映射到特定的分片，然后映射到相应的数据库实例。这就是为什么客户端必须始终通过协调器路由其请求。\",\"For example, if a client wants to insert a new record into the Cartable, the request first goes to the coordinator. The coordinator maps the record’s primary key to one of the shards and then forwards the request to the database instance responsible for that shard. 例如，如果客户端想要将新记录插入 Car 表中，则请求首先发送到协调器。协调器将记录的主键映射到其中一个分片，然后将请求转发到负责该分片的数据库实例。\",\"In the schema above, first, the coordinator maps key 121 to shard 10 and, second, inserts the record into table car_10 that is stored on the database instance owning shard 10 在上面的架构中，首先，协调器将键 121 映射到分片 10 ，然后将记录插入到存储在数据库实例上的表 car_10 中拥有分片 10\",\"However, one question remains: Why is the coordinator even needed in sharding solutions? The answer is straightforward. The shards are stored on database instances designed for single-server deployments. 然而，仍然存在一个问题：为什么分片解决方案中甚至需要协调器？答案很简单。分片存储在专为单服务器部署而设计的数据库实例上。\",\"These database instances do not communicate with each other, nor do they support any protocols that would facilitate such communication. Unaware of each other, they exist in their own isolated environments, oblivious to the fact that they are part of a larger system. 这些数据库实例不相互通信，也不支持任何促进此类通信的协议。他们彼此不知情，存在于自己孤立的环境中，没有意识到自己是一个更大系统的一部分。\",\"Consequently, the coordinator is indispensable in sharding solutions. If you’re interested in delving deeper into sharded database architectures, consider exploring CitusData or Azure CosmosDB for PostgreSQL, Vitess for MySQL, Oracle Distributed Autonomous Database, and MongoDB Sharded Cluster. 因此，协调器在分片解决方案中是不可或缺的。如果您有兴趣深入研究分片数据库架构，请考虑探索 CitusData 或 Azure CosmosDB for PostgreSQL、Vitess for MySQL、Oracle 分布式自治数据库和 MongoDB 分片集群。\"]},\"92\":{\"h\":\"分布式数据库 Distributed Databases\",\"t\":[\"Much like sharded database solutions, distributed databases also employ similar sharding techniques to distribute data and load across a cluster of database nodes. However, unlike sharding solutions, distributed databases do not rely on a coordinator component. 与分片数据库解决方案非常相似，分布式数据库也采用类似的分片技术来跨数据库节点集群分布数据和加载。然而，与分片解决方案不同，分布式数据库不依赖于协调器组件。\",\"Distributed databases are built on a shared-nothing architecture, which doesn’t have a single component, like the coordinator, burdened with making numerous decisions:分布式数据库建立在无共享架构之上，该架构没有像协调器这样的单一组件，需要做出大量决策：\",\"All nodes in the cluster are aware of each other and, consequently, the data distribution. By communicating directly, each node can route a client request to the appropriate shard owner. Additionally, they can execute and coordinate multi-node transactions. When scaling to more nodes, the cluster automatically rebalances and splits shards. The nodes maintain redundant copies of data (based on a configured replication factor) and can continue operations without downtime, even if some nodes fail. 集群中的所有节点都了解彼此，从而了解数据分布。通过直接通信，每个节点都可以将客户端请求路由到适当的分片所有者。此外，它们还可以执行和协调多节点交易。当扩展到更多节点时，集群会自动重新平衡并拆分分片。节点维护数据的冗余副本（基于配置的复制因子），并且即使某些节点出现故障，也可以在不停机的情况下继续操作。\",\"All of this operates transparently for the client, who simply needs to establish a connection with any of the nodes and allow that node to manage the distributed aspects. 所有这些对客户端来说都是透明的，客户端只需与任何节点建立连接并允许该节点管理分布式方面。\",\"For example, a client might connect to node1 and insert a new Car record with the id 121. If node1 is the owner of the record’s shard, then it will store the record locally and employ a consensus algorithm to replicate the change to a subset of other nodes. If not, node1 will forward the record to the shard’s owner, which might be node4. 例如，客户端可能连接到 node1 并插入 ID 为 121 的新 Car 记录。如果 node1 是记录分片的所有者，那么它将在本地存储该记录，并采用共识算法将更改复制到其他节点的子集。如果不是， node1 会将记录转发给分片的所有者，该所有者可能是 node4 。\",\"If you’re interested in exploring the architectures of genuine distributed databases, consider looking into Google Spanner, YugabyteDB, CockroachDB, Apache Cassandra, or Apache Ignite. 如果您有兴趣探索真正的分布式数据库的架构，请考虑研究 Google Spanner、YugabyteDB、CockroachDB、Apache Cassandra 或 Apache Ignite。\",\"In the realm of databases, sharding and distribution are often conflated, but they serve distinct purposes. 在数据库领域，分片和分布经常被混为一谈，但它们有不同的目的。\",\"While sharding involves splitting data across multiple standalone instances, it doesn’t inherently mean the system is distributed. The presence of a coordinator in sharding solutions, which directs client requests to the appropriate shard, underscores this distinction. 虽然分片涉及将数据拆分到多个独立实例中，但这并不意味着系统本质上是分布式的。分片解决方案中协调器的存在，将客户端请求引导到适当的分片，强调了这种区别。\",\"On the other hand, distributed databases, built on a shared-nothing architecture, lack this centralized coordinator. Nodes in these systems are aware of each other, manage data distribution, and handle client requests seamlessly. 另一方面，建立在无共享架构之上的分布式数据库缺乏这种集中的协调器。这些系统中的节点相互了解、管理数据分发并无缝处理客户端请求。\",\"Both architectures have their merits, and understanding their nuances is crucial for informed database design and selection.\\n两种架构都有其优点，了解它们的细微差别对于明智的数据库设计和选择至关重要。\"]},\"93\":{\"c\":[\"杂谈\"]},\"94\":{\"c\":[\"杂谈\"]},\"95\":{\"h\":\"J2Cache 缓存框架：快速上手指南\"},\"96\":{\"h\":\"介绍\",\"t\":[\"J2Cache 是 OSChina 研发的两级缓存框架。第一级缓存 L1 使用内存（同时支持 Ehcache 2.x、Ehcache 3.x 和 Caffeine），第二级缓存 L2 使用 Redis（推荐）/Memcached。我们知道像 Redis 此类远端缓存的性能瓶颈主要在于网络，因此 L1 的加入目标是降低对 L2 的读取次数。该缓存框架主要用于集群环境中，单机也可以使用，用于避免应用重启导致的缓存冷启动后对后端业务的冲击。\",\"官方仓库：https://gitee.com/ld/J2Cache\"]},\"97\":{\"h\":\"实现背景\",\"t\":[\"目前缓存的解决方案一般有两种：\",\"内存缓存（如 Ehcache）：速度快，进程内可用\",\"集中式缓存（如 Redis）：可同时为多节点提供服务\",\"J2Cache 主要解决的问题如下：\",\"使用内存缓存时，一旦应用重启后，由于缓存数据丢失，缓存雪崩，给数据库造成巨大压力，导致应用堵塞\",\"使用内存缓存时，多个应用节点无法共享缓存数据\",\"使用集中式缓存，由于大量的数据通过缓存获取，导致缓存服务的数据吞吐量太大，带宽跑满。现象就是 Redis 服务负载不高，但是由于机器网卡带宽跑满，导致数据读取非常慢\",\"在遭遇 1、2 问题时，采用 Redis 此类分布式缓存就势必会带来问题 3 的发生（Redis 的瓶颈之一在于网络 IO），而针对问题 3 的处理一般会采用集群来降低缓存服务的（带宽）压力。可实际上，此时的分布式缓存可能数据量不大，仅仅是数据吞吐量大而已。\",\"J2Cache 本身并非一个缓存框架，而是缓存框架的桥梁，利用现有优秀的内存缓存缓存（Caffeine、Ehcache）作为一级缓存，把 Redis/Memcache 作为二级缓存。所有数据的读取先从一级缓存中读取，不存在时再从二级缓存读取，这样来确保对二级缓存 Redis（远端缓存） 的访问次数降到最低。\",\"而使用内存缓存导致的应用节点内存占用提升问题，对现在的企业（云）服务器配置而言不算有压力（动则几十 G 起步）。其次一级缓存框架可以通过配置控制在内存中存储的数据量，无需担心 OOM 问题。\"]},\"98\":{\"h\":\"使用场景\",\"t\":[\"在集群环境，使用 J2Cache 可以有效降低节点间的数据传输量\",\"单节点使用 J2Cache 可以避免应用重启后对后端业务系统的冲击\"]},\"99\":{\"h\":\"Region\",\"t\":[\"在 Redis 中可以针对每一个 Key 来设置超时时间，但像 Java 的内存缓存框架（Ehcache、Caffeine、Guava Cache）是无法为每个 Key 设置不同的 TTL，因为这样管理起来非常复杂，而且在检查缓存数据是否失效时性能极差，所以一般内存缓存框架会把一组相同 TTL 策略的缓存数据放在一起进行管理，即 Region。\",\"J2Cache 的 Region 来源于 Ehcache 的 Region 概念，而在 Caffeine、Guava Cache 中则是通过构建 Cache 对象来设置缓存的时间策略。\",\"默认 Region 为 default，由于 J2Cache 默认使用 Caffeine 作为一级缓存，会在其 caffeine.properties 配置文件设置 Region，若保存数据时指定的 Region 在配置文件中不存在，则会自动创建，并且可缓存数量的大小和超时时间与 default 保持一致。\",\"因此可以根据不同的业务场景来规划不同的 Region 来存放不同的数据。\"]},\"100\":{\"h\":\"应用\"},\"101\":{\"h\":\"静态配置\",\"t\":[\"基础使用看仓库 README.md 即可，这里以 Caffeine、Redis 为例，先从代码仓库 /resources 中拷贝 caffeine.properties、j2cache.properties，后者是 J2Cache 核心配置，主要包含了 1、2 级缓存的连接配置、缓存广播信息等。\",\"####### caffeine.properties # region 名称 = region 可缓存的数量，有效期（s|m|h|d） default = 1000, 30m custom = 500, 20m \",\"####### j2cache.properties # 这里选择了 Redis lettuce 连接方式，PS：lettuce 是基于 Netty 构建的连接，支持同步异步调用，多个线程可共享同一个 RedisConnection # 但在此与 Jedis 相比没区别，都是通过 Redis pun/sub 来实现广播，其它广播方式看配置文件即可 j2cache.broadcast = lettuce # 1、2 缓存实现类名称，CacheChannel 初始化时会通过名称去获取两级缓存的 CacheProvider 实现 j2cache.L1.provider_class = caffeine j2cache.L2.provider_class = lettuce # 此处要注意：broadcast 选择了 lettuce 后，此处的 L2.provider_class 得保持一致，否则在配置 pubsub 时，会因为取不到连接而抛出 NPE # 这是因为二级缓存、广播两者都会创建相应的 CacheProvider，但前者会调用其 start 方法创建连接，而后者仅仅是 new 了个对象并保存了二级缓存的 holder，执行 pubsub 时是取的自身建立的连接，但由于广播操作的 cacheProvider 没有进行 start 自然就不会有连接。 # 设置 Redis key 是否有过期时间，默认 true，false 则 key 永不过期 j2cache.sync_ttl_to_redis = true # 默认情况下是否缓存 null 对象，默认 false j2cache.default_cache_null_object = true # 缓存序列化方式，有多种：fst（官方推荐）、kryo、fastjson、java、fse j2cache.serialization = json # Redis 配置，默认采用 jedis，如果时使用 lettuce，则会有前缀为 luttuce 的相同设置参数，想看配置文件即可 # 单节点，可填：sentinel、cluster、sharded redis.mode = single # redis 存储模式，分为 generic、hash，使用 hash 模式，会导致 sync_ttl_to_redis 无效，因为 hash 存储结构不能为单独的属性（KV）设置过期时间 redis.storage = generic # redis pub/sub channel 名称 redis.channel = j2cache # redis pub/sub server 地址，为空则与 hosts 相同 redis.channel.host = redis.hosts = 127.0.0.1:6379 redis.timeout = 2000 redis.password = 123456 redis.database = 0 redis.ssl = false \",\"静态配置的使用需要在代码中手动使用 J2Cache 对象去获取 CacheChannel\",\"public class Config { private final static cacheChannel = null; /** * 以下代码是随便写写，主要知道 CacheChannel 从何而来以及静态配置如何生效即可 */ static { cacheChannel = J2Cache.getChannel(); } public CacheChannel getChannel() { return this.cacheChannel; } } \"]},\"102\":{\"h\":\"动态配置\",\"t\":[\"@Configuration public class CacheConfig { @Bean(\\\"cacheChannel\\\") public CacheChannel init() { // 这个 config 的信息配置都是 Properties 方式，具体的参数可以参考 getChannel() 方法执行流程所取的字段 // 而缓存本身的配置字段，如 host、password 等则可参考配置文件去填写即可 J2CacheConfig config = new J2CacheConfig(); //填充 config 变量所需的配置信息 J2CacheBuilder builder = J2CacheBuilder.init(config); CacheChannel channel = builder.getChannel(); return channel; // close 操作就是断开（boardcast）集群连接、清空一、二级缓存的内存数据、断开二级缓存的连接 // channel.close(); } } \"]},\"103\":{\"h\":\"代码示例\",\"t\":[\"@RestController @RequestMapping(\\\"/demo\\\") public class DemoController{ @Resource private CacheChannel cache /** * 静态配置与动态配置读取 */ @GetMapping(\\\"/source\\\") public void source(){ // 这一段的配置是指使用 j2cache.properties 的配置初始化 CacheChannel，也就是静态配置 // 而若配置了 CacheConfig 动态配置，由 SpringBoot 动态加载注入，那么 j2cache.properties 的配置就不会去读取了 CacheChannel channel = J2Cache.getChannel(); channel.set(CacheNameConstant.DEFAULT, \\\"GUEST\\\", \\\"3288\\\"); System.out.println(channel.get(CacheNameConstant.DEFAULT, \\\"GUEST\\\")); } @GetMapping public void test() { // 缓存操作，region - key - value，保存到一二级缓存 cache.set(\\\"default\\\", \\\"1\\\", \\\"Hello J2Cache\\\"); System.out.println(\\\"============\\\" + cache.get(\\\"default\\\", \\\"1\\\")); // 清除操作，region - key，会将一二级缓存该数据都删掉 cache.evict(\\\"default\\\", \\\"1\\\"); System.out.println(\\\"============\\\" + cache.get(\\\"default\\\", \\\"1\\\")); } /** * 手动构建 Command 对象发布更新通知 */ @GetMapping(\\\"/publish\\\") public void publish(){ // Command 是 J2Cache 内部对象，使用 Redis 发布通知，便是包装该对象后，订阅者接收进行解析从而确定执行的命令 LettuceCacheProvider l2Provider = (LettuceCacheProvider) cache.getL2Provider(); Command cmd = new Command(); String[] a = new String[1]; a[0] = \\\"USER\\\"; cmd.setKeys(a); // Operator 有四种，详看 Command 对象定义 cmd.setOperator(2); cmd.setRegion(\\\"default\\\"); // 发布后的被订阅者接收只会清除一级缓存，因为在 J2Cache 内部发起通知都是因为二级缓存（Redis）被修改 // 所以只需要清除一级缓存即可 l2Provider.publish(cmd); } } \"]},\"104\":{\"h\":\"实现原理\",\"t\":[\"以 Caffeine / Redis 更新数据为例，实现思路如下：\",\"当 set 更新时，会调用 publish 方法，初始化一个 Command 对象，该对象保存了 Region、keys、操作标识（1-加入集群，2-删除缓存，3-清空缓存，4-退出集群），然后发给指定的 Channel\",\"而订阅 Channel 的一方收到消息后，会解析 Command 对象，由于 set 的命令操作标识为 2，因为会根据 Region、keys 删除本地缓存，待下次读取数据时，则会从二级缓存获取最新数据\",\"纵观下来，整体思路其实就是 L1 在更新数据后，将数据同步到 L2，并发送通知给到其它节点，其它节点直接删除 L1 缓存，下次从 L2 读取数据并更新至 L1。\",\"J2Cache 支持的节点间数据同步方案除了 Redis 外还包括以下几种，各种方案在 j2cache.properties 都可看到描述信息：\",\"Redis（lettuce） Pub/Sub\",\"JGroups\",\"RabbitMQ\",\"RocketMQ\",\"自定义实现，需实现 net.oschina.j2cache.cluster.ClusterPolicy 接口\",\"J2Cache 并不复杂，追踪源码后很快就能理解。\"]},\"105\":{\"h\":\"小故事\",\"t\":[\"还记得第一次学习 Redis 后，了解到存在与 MySQL 数据库的数据同步问题时，我就想过 JVM 内存与 Redis 缓存是否也可存在此种做法，优先访问 JVM 内存，次之是远端缓存 Redis。但当时对缓存概念理解浅薄，认为收益不大，便未深入研究。如今在公司看到其它系统项目引入 J2Cache，又勾起了我的兴趣。查看了 J2Cache 官方仓库后，发现它早于我最初构想时就已存在。然而，J2Cache 似乎并不活跃，虽然有 3.x 版本的开发计划，但最近一次版本更新还是两年前的 2.8.4。\",\"而且 J2Cache 官方还提到了它与 JetCache 的区别（原文戳此）。JetCache 是阿里开源的一款缓存框架，旨在对 Java 缓存进行抽象，为不同缓存解决方案提供统一的使用方式。J2Cache 解释 JetCache 是对缓存设计的封装，而 J2Cache 则是全新的两级缓存框架。然而在查看了下 JetCache 官方仓库，其实 JetCache 也已提供二级缓存功能了。因此，与 JetCache 相比，J2Cache 的特点便不复存在，逐渐变得不活跃也就不足为奇了。\"]},\"106\":{\"c\":[\"Cache\"]},\"107\":{\"c\":[\"Cache\",\"Redis\"]},\"108\":{\"h\":\"Spring 事务同步\"},\"109\":{\"h\":\"前言\",\"t\":[\"事务功能在日常开发中使用并不少，本质上是为了保证一次业务请求处理过程中涉及多次 DB 数据操作时的原子性。而本篇主要讲述的事务功能是实现在事务执行的某个阶段去做某些事，即事务同步。在常规的 Web 应用中，大多是直接使用@Transactional注解方法来完成事务操作，但也有一些特殊情况，需要在事务提交前、提交后等情况下执行某些操作，如资源准备、清理、自定义操作等。\"]},\"110\":{\"h\":\"事务同步接口\",\"t\":[\"事务同步回调接口是TransactionSynchronization，其抽象实现TransactionSynchronizationAdapter源码如下：\",\"public abstract class TransactionSynchronizationAdapter implements TransactionSynchronization, Ordered { // 事务同步回调顺序，当存在多个事务同步且有顺序要去时可指定 @Override public int getOrder() { return Ordered.LOWEST_PRECEDENCE; } // 事务挂起 @Override public void suspend() { } // 事务回复 @Override public void resume() { } // 底层数据会话刷新，需要事务管理器有刷新概念，否则无操作 @Override public void flush() { } // 事务提交前 @Override public void beforeCommit(boolean readOnly) { } // 事务完成前（包括异常回滚） @Override public void beforeCompletion() { } // 事务提交后 @Override public void afterCommit() { } // 事务完成后（包括异常回滚） @Override public void afterCompletion(int status) { } } \",\"从源码可看到事务同步作用就是在事务执行的各个阶段进行方法回调，并可通过Ordered接口控制多个事务同步的执行顺序，在下方事务同步的两种使用方式本质都是利用了该抽象类来实现。 在afterCompletion方法的入参status有三种状态（在TransactionSynchronization接口有定义）：\",\"0：事务完成\",\"1：事务回滚\",\"2：未知错误\"]},\"111\":{\"h\":\"使用方式\"},\"112\":{\"h\":\"基于接口\",\"t\":[\"需要继承TransactionSynchronizationAdapte抽象类，在相应的事务阶段回调方法中实现业务逻辑\",\"在事务方法中通过TransactionSynchronizationManager事务同步管理器注册事务同步\",\"// 创建 public class TxSyncDemo extends TransactionSynchronizationAdapter { private String txName; public TxSyncDemo(String txName) { this.txName = txName; } @Override public void afterCommit() { System.out.println(\\\"事务提交后回调...\\\") } @Override public void afterCompletion(int status) { System.out.println(\\\"事务完成后回调...\\\") System.out.println(\\\"事务名称：\\\" + txName); System.out.println(\\\"事务状态：\\\" + status); } } // 事务接口方法 @RestController public class TxController { @GetMapping(\\\"txDemo\\\") @Transactional(rollbackFor = Exception.class) public void txDemo() { // 模拟 DB 操作：更新和新增 update(); save(); // 注册事务同步对象 TransactionSynchronizationManager.registerSynchronization(new TxSyncDemo(\\\"事务同步测试\\\")); // 当然这里也可以直接通过匿名类的方式创建，而无需通过继承对象 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() { @Override public void afterCommit() { System.out.println(\\\"提交后执行\\\"); } }); } } \",\"之后调用事务接口，即可看到如下结果：\",\"控制台结果\"]},\"113\":{\"h\":\"基于注解\",\"t\":[\"注解方式需要通过@TransactionalEventListener与ApplicationEvent事件对象两者搭配使用，先看看注解的源码，如下：\",\"@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @EventListener public @interface TransactionalEventListener { // 指定事务阶段 TransactionPhase phase() default TransactionPhase.AFTER_COMMIT; // 不存在事务时，注解的方法是否依然被调用，true 则表示只要事件发布了就回调 boolean fallbackExecution() default false; // ... @AliasFor(annotation = EventListener.class, attribute = \\\"classes\\\") Class[] value() default { }; // 指定感兴趣的事件类名 @AliasFor(annotation = EventListener.class, attribute = \\\"classes\\\") Class[] classes() default { }; // 事务回调的条件，可通过 SpEL 进行编写 String condition() default \\\"\\\"; } \",\"实现步骤：\",\"创建事件对象\",\"使用注解标记方法，并通过注解属性指定回调时的事务阶段和感兴趣的事件\",\"在事务接口方法里，发布相应的事件\",\"// 步骤 1：创建事件类 // 可在这个事件类里注入其它依赖或声明业务逻辑，因此事务同步回调时可获取该事件的信息 public class TxSyncEvent extends ApplicationEvent { public TxSyncEvent(Object source) { super(source); } } // 步骤 2：使用事务注解 @Component public class TxSyncDemo { @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, classes = TxSyncEvent.class) public void afterCommit() { System.out.println(\\\"事务提交后回调...\\\"); } } // 步骤 3：事务方法里发布事件 @RestController public class TxController { @Resource private ApplicationEventPublisher publisher; @GetMapping(\\\"txDemo\\\") @Transactional(rollbackFor = Exception.class) public void txDemo() { // 模拟 DB 操作：更新和新增 update(); save(); // 发布事件 publisher.publishEvent(new TxSyncEvent(\\\"source\\\")); } } \",\"之后调用事务接口，即可看到注解方法内的内容输出，过于简单不再展示结果图片。\"]},\"114\":{\"h\":\"注意事项\"},\"115\":{\"h\":\"注解方式方法入参问题\",\"t\":[\"按@TransactionalEventListener注解classes属性是否有指定值分情况说明：\",\"无值 \",\"方法入参只能为 0 或 1 个（任意类型）\",\"若方法入参为事件类型，则代表是感兴趣的事件，等同于classes指定了该事件\",\"若方法入参为空或不为事件类型，则表示方法不关心任何事件，任何时候都不会被回调\",\"有值 \",\"只有一个值时，入参必须为该值对应的事件类型，否则抛出参数类型错误异常\",\"多个值时，则入参不需要指定\",\"经过实际测试，classes指定多个值时，入参依然可指定为某个事件类型，若事务方法发布的事件刚好与参数的事件类型一致，则可以正确回调。比如classes={A.class, B.class}，方法入参类型为 A，发布 A 事件时可正确执行，而发布 B 事件则会抛出异常。因此还是推荐不设置参数。\"]},\"116\":{\"h\":\"afterCommit / afterCompletion 事务范围问题\",\"t\":[\"这两个方法在 javadoc 上的描述是：在回调时事务资源可能仍然处于活跃状态并可访问。 经过实际测试，在这两个方法中执行 DB 数据操作，那么操作依旧会参与原事务，会等到方法执行完清理事务资源后，才会真正提交到数据库。可通过TransactionSynchronizationManager.isActualTransactionActive()来判断当前方法是否处于活跃事务中。\"]},\"117\":{\"h\":\"实际场景\",\"t\":[\"举个在我司 IM 系统中的例子，如添加好友，该请求处理步骤如下：\",\"数据库 f_req（好友请求） 表添加记录数据，删除目标好友（target）的 f_req 缓存（Redis）\",\"发送通知给 target，让其拉取最新好友请求记录（通过 Netty 异步发送通知）\",\"事务提交，数据真正落库，返回请求处理结果（success / fail）\",\"由于步骤 2 通过 Netty 的 Channel 异步发送通知，因此不受 Spring 事务管理。若只是使用事务注解标记整个处理流程，那么当执行到步骤 2 时，由于事务未提交（DB 数据未更新），当 target 收到通知后重新来查询 f_req，就只会查到旧数据（即缺少最新的请求记录），下图展示过程：假设 A + B 为好友\",\"场景示例\",\"结合上图梳理流程如下：\",\"A 发起好友请求（Request 1），服务端开启事务，DB 新增数据，删除 B 的 f_req 缓存\",\"服务端发送通知给 B，通知 B 来查询最新的 f_req 数据\",\"当服务端接收 B 的查询请求（Request 2）后，先查询缓存，由于缓存被删除，则查询 DB；因为 Request 1 的事务未提交，所以肯定只会查到旧的 f_req 记录，即 A 发送的 f_req 没了\",\"Request 1 的请求处理完成，事务提交，所有数据落库\",\"从 B 的视角来看，虽然被通知要拉取 f_req，但拿到的却都是旧数据，根本就没有 A 发出的 f_req，属实是“虚空好友请求”了。更糟糕的是，由于旧数据的查询，缓存重新被添加回来，导致图中步骤 1 的缓存删了等于没删，出现缓存与 DB 数据不一致情况，并且至少得等到下一次有用户对 B 发起 f_req，才能将本次的 f_req 数据刷新到缓存。\",\"为避免出现这种情况，就需要保证 B 发起查询请求时，A 的添加好友请求已处理完毕，数据已落库；因此便可利用事务同步来控制步骤 2 在事务完成后执行。\",\"（PS：可能读者会有疑惑，添加请求在流程中明明只有一次 DB 操作，为何还要加事务？原因是流程做了简化，添加好友的流程除了处理好友请求记录外，还会判断用户好友历史记录是否添加过目标用户，若有也会去修改 DB 数据。）\"]},\"118\":{\"h\":\"思考题\",\"t\":[\"上方说到事务同步注解方式若classes指定了多个值，方法入参推荐不指定，那么在方法体里如果获取本次事务监听的事件信息呢？\",\"afterCommit/afterCompletion方法回调时若有 DB 数据操作，在事务明明已经提交的情况下，为何还会参与原始事务，并且得等到清理资源时才提交？\",\"（PS：想想再看答案，也可以先带着问题去阅读下源码）\"]},\"119\":{\"h\":\"问题一\",\"t\":[\"第一个问题比较简单，由于事件类都需要继承ApplicationEvent作为父类，因此方法参数指定为ApplicationEvent类型即可，然后通过instanceof或Class.isAssignableForm()判断类型，再搭配上策略模式优雅代码。\",\"@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, classes = {AEvent.class, BEvent.class}) public void afterCommit(ApplicationEvent event) { if (event instanceof AEvent) { // do something... } else if (event instanceof BEvent) { // do something... } // 觉得多重 if 丑陋就使用策略模式 } \"]},\"120\":{\"h\":\"问题二\",\"t\":[\"之所以事务提交还会参与原始事务，是跟 Spring 的事务机制有关，Spring 事务的本质是获取到 DB 的连接（Connection）后修改连接的自动提交autoCommit为false（默认是true），然后由 Spring 自己控制提交的时机，从而实现事务的功能。\",\"既然修改了连接的autoCommit，那么事务执行完后就得将连接恢复到初始状态，即修改autoCommit=true。而偏偏这个操作，是在执行事务回调完成后，清理资源时才会去执行，也就导致了事务回调期间的 DB 操作都没有被提交，最后只能依赖连接的autoCommit恢复后，由连接本身去做提交操作（因为 Spring 不会再有提交操作）。\",\"连接获取后autoCommit的修改源码如下：\",\"@Override protected void doBegin(Object transaction, TransactionDefinition definition) { // 省略其它代码... Connection con = null; // 这里是从连接池获取连接的操作 try { if (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) { // 这一步从数据库连接池里获取连接 Connection newCon = obtainDataSource().getConnection(); if (logger.isDebugEnabled()) { logger.debug(\\\"Acquired Connection [\\\" + newCon + \\\"] for JDBC transaction\\\"); } // 保存连接在 ConnectionHolder 对象中 txObject.setConnectionHolder(new ConnectionHolder(newCon), true); } txObject.getConnectionHolder().setSynchronizedWithTransaction(true); con = txObject.getConnectionHolder().getConnection(); // 隔离级别与只读设置 Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition); txObject.setPreviousIsolationLevel(previousIsolationLevel); txObject.setReadOnly(definition.isReadOnly()); // Switch to manual commit if necessary. This is very expensive in some JDBC drivers, // so we don't want to do it unnecessarily (for example if we've explicitly // configured the connection pool to set it already). // 当连接默认为自动提交时，才设置为手动提交 if (con.getAutoCommit()) { // mustRestoreAutoCommit 这个变量后面恢复连接自动提交时会用到 txObject.setMustRestoreAutoCommit(true); if (logger.isDebugEnabled()) { logger.debug(\\\"Switching JDBC Connection [\\\" + con + \\\"] to manual commit\\\"); } con.setAutoCommit(false); } } catch (Throwable ex) { // 省略... } } \",\"事务完成后连接autoCommit修改源码如下：\",\"@Override protected void doCleanupAfterCompletion(Object transaction) { DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; // Remove the connection holder from the thread, if exposed. // 解绑资源 if (txObject.isNewConnectionHolder()) { TransactionSynchronizationManager.unbindResource(obtainDataSource()); } // 获取连接进行重置 Connection con = txObject.getConnectionHolder().getConnection(); try { // mustRestoreAutoCommit 变量在修改 autoCommit 为 false 时便设置为 true if (txObject.isMustRestoreAutoCommit()) { // 恢复为自动提交，执行完这一步，事务回调中的 DB 操作就会提交 con.setAutoCommit(true); } DataSourceUtils.resetConnectionAfterTransaction( con, txObject.getPreviousIsolationLevel(), txObject.isReadOnly()); } catch (Throwable ex) { logger.debug(\\\"Could not reset JDBC Connection after transaction\\\", ex); } if (txObject.isNewConnectionHolder()) { if (logger.isDebugEnabled()) { logger.debug(\\\"Releasing JDBC Connection [\\\" + con + \\\"] after transaction\\\"); } // 释放连接，将连接回收到数据库连接池 DataSourceUtils.releaseConnection(con, this.dataSource); } txObject.getConnectionHolder().clear(); } \",\"如上即为连接获取后autoCommit的修改操作。\",\"注意其中事务完成后释放连接这一步（DataSourceUtils.releaseConnection），Spring 同样会持有 DB 连接直到事务回调执行完成后清理资源才释放，所以尽量不要在事务回调中执行耗时较久的操作，否则可能导致 DB 连接无意义占用而引发连接池溢出。\"]},\"121\":{\"h\":\"总结\",\"t\":[\"Spring 事务在日常开发中应用不少，对事务的特性和使用需有所理解，避免因使用不当而带来开发问题。并且利用事务同步功能，也可达到缩小事务范围的效果。同时在事务回调中，尽量不要有 DB 操作和执行耗时较长的操作。若有必要，就新开事务执行 DB 操作，若只是代码执行耗时，则善用线程池异步处理。\"]},\"122\":{\"c\":[\"Spring\"]},\"123\":{\"c\":[\"Spring\",\"Transaction\"]},\"124\":{\"h\":\"WebSocket 集成（一）\"},\"125\":{\"h\":\"介绍\",\"t\":[\"WebSocket 协议 是基于 TCP 协议的全双工通信协议，是通过单个 TCP 连接在客户端和服务器之间建立全双工、双向通信通道，可让客户端与服务端建立持久连接，并实时互传数据。它与 HTTP 同为应用层协议，但相比于 HTTP 的请求 - 响应模型，WebSocket 则提供了实时、低延迟的数据传输能力和长连接功能，旨在解决 HTTP 协议在实时通信方面的局限性，如请求 - 响应模式的单向性以及频繁的连接、断开开销。WebSocket 的特性，使得其在即时通讯、游戏同步、IOT 设备实时监控等应用场景大放异彩，已成为现代 Web 应用中常用的通讯协议之一。\",\"在 Spring Boot 中整合 WebSocket 方式有两种：\",\"使用 Jakarta EE 规范提供的 API\",\"使用 Spring 本身提供的模块依赖\",\"本篇是 Spring Boot 整合 WebSocket 系列的第一篇，介绍第一种方式。\",\"题外话：Jakarta EE 前身是 Java EE，因为后者在 2017 年被 Oracle 公司捐赠给了 Eclipse Foundation，之后 2018 年 Eclipse 基金会便发布了 Jakarta EE 9，之所以改名，是因为「Java」这个名字的商标归 Oracle 所有，Eclipse 基金会无法继续使用 javax.*、java.*等名称，因此将其改为「Jakarta（雅加达）」。值得一提的是，Jakarta（雅加达）是 Java 岛（爪洼岛）上最大的城市，也是印度尼西亚的首都。\"]},\"126\":{\"h\":\"集成 Jakarta WebSocket\"},\"127\":{\"h\":\"项目依赖\",\"t\":[\"首先创建 Spring Boot 项目，笔者使用的版本：3.2.2，然后在pom.xml添加如下依赖：\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-websocket</artifactId> </dependency> \"]},\"128\":{\"h\":\"端点\",\"t\":[\"根据 Jakarta WebSocket 规范（见参考资料 1），服务器端点的创建有两种方式：一是实现规范所提供的接口，如Endpoint，并实现其相关方法来处理新连接建立、消息接收、连接断开等时间；二是通过注解，较为便捷与灵活。接下来的所有代码示例也是基于注解方式实现。\",\"首先创建一个服务器端点，如下：\",\"@ServerEndpoint(value = \\\"/channel/call/{uid}\\\") public class CallChannel { private static final Logger LOGGER = LoggerFactory.getLogger(CallChannel.class); private Session session; // 存储客户端连接 private static final Map<String, CallChannel> wsMap = new ConcurrentHashMap<>(); @OnMessage(maxMessageSize = 1000) public void onMessage(String message, boolean last) throws IOException { // ID 是标识连接的唯一字符，每个连接仅此一个，Tomcat 下是从 0 递增，undertow 则为类似 UUID 的字符串 LOGGER.info(\\\"收到来自客户端的消息:{} - {}\\\", this.session.getId(), message); // 发送消息给客户端，此处使用异步发送 this.session.getAsyncRemote().sendText(message); // 这个是同步发送，会阻塞至消息发送成功 // RemoteEndpoint.Basic basicRemote = this.session.getBasicRemote(); if (last) { // do something... } // 发送 bye 则关闭连接 if (\\\"bye\\\".equalsIgnoreCase(message)) { this.session.close(new CloseReason(CloseReason.CloseCodes.NORMAL_CLOSURE, \\\"Bye\\\")) } } @OnOpen public void onOpen(Session session, @PathParam(\\\"uid\\\") String uid, EndpointConfig endpointConfig) { // 保存在实例变量中，Jakarta WS 每建立一个连接便会创建一个端点，因此该变量是线程安全的 this.session = session; LOGGER.info(\\\"新的连接：id={}\\\", this.session.getId()); // session 可获取连接请求的查询参数，路径参数则需要在 WS 的端点路径上（@ServerEndpoint）配置 Map<String, List<String>> requestParameterMap = session.getRequestParameterMap(); LOGGER.info(\\\"获取到请求参数：{}\\\", requestParameterMap); LOGGER.info(\\\"获取到路径参数：{}\\\", uid); // 配置信息 PojoMethodMapping mapping = (PojoMethodMapping) endpointConfig.getUserProperties().get(\\\"org.apache.tomcat.websocket.pojo.PojoEndpoint.methodMapping\\\"); LOGGER.info(\\\"[websocket] 连接路径：id={}, path={}\\\", this.session.getId(), mapping.getWsPath()); } @OnClose public void onClose(CloseReason reason) { LOGGER.info(\\\"连接断开：id={}，reason={}\\\", this.session.getId(), reason); } @OnError public void onError(Throwable throwable) throws IOException { LOGGER.info(\\\"连接异常：id={}，throwable={}\\\", this.session.getId(), throwable.getMessage()); // 关闭连接。状态码为 UNEXPECTED_CONDITION（非预期异常） this.session.close(new CloseReason(CloseReason.CloseCodes.UNEXPECTED_CONDITION, throwable.getMessage())); } public int clientSize() { return wsMap.size(); } } \",\"@ServerEndpoint注解用于声明此类是一个 WebSocket 端点，value 属性必填，其表明了 WebSocket 连接路由，注解还包括subprotocols、decoders、encoders等属性可以定义子协议、数据编解码器等。\"]},\"129\":{\"h\":\"@OnOpen\",\"t\":[\"@OnOpen注解的方法会监听客户端的连接事件，方法参数一session必填，表示连接对象（其实所有方法都支持使用 session 作为参数）。而uid是通过端点路径配置的路径参数。想必大家也能意识到，通过端点路径是可以传递查询参数或路径参数的，如代码所示去获取参数即可。\",\"每当有新的客户端连接接入时，服务器便会创建一个新的端点实例，所以 session 的获取是线程安全的，同时也可以在端点类中声明静态缓存（如代码示例中的wsMap），用于存储所有的客户端连接。\",\"最后一个参数则为端点配置信息对象，可获取当前 WebSocket 端点的信息，通过 Debug 可得到其属性 Key 从而获取数据。\"]},\"130\":{\"h\":\"@OnClose\",\"t\":[\"@OnClose注解的方法则用于监听连接的关闭，并且方法带有一个CloseReason对象，封装了连接关闭原因、状态码等。\"]},\"131\":{\"h\":\"@OnError\",\"t\":[\"@OnError方法则用于处理异常事件，该方法必须要有一个Throwable对象来表示发生的异常，否则启动服务时会提示该方法缺少Throwable参数对象。根据异常可针对性的执行某些操作。也可在此对 session 进行关闭，关闭需要传递CloseReason对象，而CloseReason.CloseCodes也已定义了一些常见的枚举原因，可直接使用。\"]},\"132\":{\"h\":\"@OnMessage\",\"t\":[\"@OnMessage方法自然是用来接收客户端消息，通过字符串类型的 message 接收，但 WebSocket 本身也是支持二进制消息的，参数类型可以是String、byte[]或Reader、InputStream。并且该注解还提供了属性maxMessageSize用于控制接收的消息大小，若超出则会断开连接，默认 -1 无限制。\",\"参数二last用于判断获取到的消息是否为数据的最后一部分，当数据内容过大，WebSocket 会将其分割为多份传递。\"]},\"133\":{\"h\":\"配置端点扫描\",\"t\":[\"定义好 WebSocket 端点后，需要创建ServerEndpointExporter对@ServerEndpoint注解的端点进行扫描注册。\",\"@Configuration public class WebSocketConfig implements ServletContextInitializer { /** * 创建 ServerEndpointExporter 实例，扫描 WS 端点， * ServerEndpointExporter 用于检测带有 @ServerEndpoint 注解的类，并为其注册一个 WebSocket 运行时 * @return ServerEndpointExporter */ @Bean public ServerEndpointExporter serverEndpointExporter() { // 显式注册应该在启动时注册的带注释的端点类型 // exporter.setAnnotatedEndpointClasses(CallChannel.class); // 实际只需在端点类上加 @Component 注解，因为 exporter 会扫描带有 @ServerEndpoint 注解的 Bean // 详细可见 ServerEndpointExporter#afterSingletonsInstantiated 方法 return new ServerEndpointExporter(); } } \"]},\"134\":{\"h\":\"JS 连接测试\",\"t\":[\"在项目中的src/main/resources下创建public目录，并创建文件index.html，Spring Boot 默认将此作为应用主页，如下：\",\"<!DOCTYPE html> <html lang=\\\"\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>WebSocket</title> </head> <body> <script type=\\\"text/javascript\\\"> let websocket = new WebSocket(\\\"ws://localhost:8080/channel/call/9527\\\"); // 连接断开 websocket.onclose = e => { console.log(`连接关闭: code=${e.code}, reason=${e.reason}`) } // 收到消息 websocket.onmessage = e => { console.log(`收到消息：${e.data}`); } // 异常 websocket.onerror = e => { console.log(\\\"连接异常\\\") console.error(e) } // 连接打开 websocket.onopen = e => { console.log(\\\"连接打开\\\"); // 创建连接后，往服务器连续写入 3 条消息 websocket.send(\\\"这是第一条消息\\\"); websocket.send(\\\"这是第二条消息\\\"); websocket.send(\\\"这是第三条消息\\\"); // 最后发送 bye，由服务器断开连接 websocket.send(\\\"bye\\\"); // 也可以由客户端主动断开 // websocket.close(); } </script> </body> </html> \",\"首先与服务端点建立 webSocket 连接：ws://localhost:8080/channel/call/9527，9527是路径参数\",\"连接接入后，在onopen函数中打印日志并向服务端发送三条数据，最后发送bye给服务端关闭连接\",\"连接关闭后，onclose方法也能得到回调并输出日志\",\"onmessage自然是接收服务端推送的内容，实际应用中也是在此处根据消息来执行业务逻辑\",\"然后启动服务，在浏览器访问应用地址即可，记得打开浏览器控制台：\",\"浏览器控制台信息\",\"IDEA 控制台信息\"]},\"135\":{\"h\":\"在端点中注入 Bean\",\"t\":[\"在端点中注入 Spring Bean，并不能直接通过@Autowired等注解注入依赖，因为端点并非由 Spring 创建，而是由服务器（Spring Boot 默认是 Tomcat）创建。因此，在端点上添加@Component注解只是表示会由 Spring IOC 管理而已，所以可通过ApplicationContextAware接口得到ApplicationContext来获取 Bean。\",\"@ServerEndpoint(value = \\\"/channel/call/{uid}\\\") @Component public class CallChannel implements ApplicationContextAware { private static ApplicationContext springContext; private UserService userService; // 假设 UserService 是其它 Bean 依赖 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { springContext = applicationContext; } @OnOpen public void onOpen(Session session, @PathParam(\\\"uid\\\") String uid, EndpointConfig endpointConfig){ this.session = session; // 注入 Bean 对象 this.userService = springContext.getBean(UserService.class); } } \",\"由于@OnOpen方法在整个连接的生命周期中，只会执行一次，所以该方式不会带来性能损耗。\"]},\"136\":{\"h\":\"关于 onMessage 方法的 last 参数\",\"t\":[\"上方提到@OnMessage方法的last参数是 WebSocket 自动根据消息内容大小从而确定是否分割数据传递，若分为多份，那么没拿到最后一份数据时，last自然为false。其实这里正确来说，是否将数据分割，是根据 Tomcat 系统配置参数来决定的，即：org.apache.tomcat.websocket.DEFAULT_BUFFER_SIZE，默认8*1024字节。\",\"Tomcat 服务器下的 WebSocket 在读取数据时，会用到三个Buffer，分别是：\",\"ByteBuffer readBuffer：读缓冲区，用于读取传递的数据，作为中间缓冲区暂存数据，该区默认大小即为DEFAULT_BUFFER_SIZE\",\"ByteBuffer messageBufferBinary：字节缓冲区，大小默认8*1024字节\",\"CharBuffer messageBufferText：文本缓冲区,大小默认8*1024字节\",\"假设客户端此时发送了一条数据，那么会由messageBufferBinary接收，没错，WebSocket 默认将所有数据都用字节缓冲区接收，再根据@OnMessage方法的参数类型来决定是否转化为对应类型。而由字节缓冲区接收后，会利用readBuffer读取数据，从而判断数据是否超出了缓冲区大小，决定是否需要对数据进行切分。也就是说，若传递数据超过8*1024字节，那么当回调@OnMessage方法时，便能看到last参数为false，具体源码可以看：WsFrameBase.java类下的processDataText()与processDataBinary()方法。\",\"至于上述三个缓冲区的大小设置方式，如下：\",\"@SpringBootApplication public class WsSummaryApplication { public static void main(String[] args) { // 设置 Tomcat 关于 WebSocket readBuffer 缓存区的大小，默认是 8*1024，单位：byte System.setProperty(\\\"org.apache.tomcat.websocket.DEFAULT_BUFFER_SIZE\\\", \\\"32\\\"); SpringApplication.run(WsSummaryApplication.class, args); } } @Configuration public class WebSocketConfig implements ServletContextInitializer { @Override public void onStartup(ServletContext servletContext) throws ServletException { servletContext.addListener(WebAppRootListener.class); servletContext.setInitParameter(\\\"org.apache.tomcat.websocket.textBufferSize\\\",\\\"1024\\\"); servletContext.setInitParameter(\\\"org.apache.tomcat.websocket.binaryBufferSize\\\",\\\"1024\\\"); } } \"]},\"137\":{\"h\":\"关于心跳\",\"t\":[\"Jakarta WebSocket 关于 ping/pong 有对应的规范描述，不过在实际应用中，前后端可约定好ping发送的消息内容，这样服务端可通过@OnMessage来做对应的处理，并不麻烦。或者由服务端开启定时任务主动发送ping消息给客户端也是可以的。网上参考资料不少，在此就不多赘述。\"]},\"138\":{\"h\":\"后续\",\"t\":[\"此篇内容大量借鉴于参考资料 2 的博客内容，因对 WebSocket 较有兴趣，便学习了一番，不过在查看了其博客站点，发现只是介绍了 Jakarta WebSocket 的整合方式，也没有深入讲解原理。因此笔者在此记录并做了补充，后续再补充 Spring 自身提供的 WebSocket 整合实现。\"]},\"139\":{\"h\":\"参考资料\",\"t\":[\"Jakarta WebSocket 2.0 规范\",\"在 Spring Boot 中整合、使用 WebSocket\"]},\"140\":{\"c\":[\"Spring\"]},\"141\":{\"c\":[\"Spring Boot\",\"WebSocket\"]},\"142\":{\"h\":\"Dev Experience\"},\"143\":{\"h\":\"Posts\"},\"144\":{\"h\":\"Java\"},\"145\":{\"h\":\"Reprint\"},\"146\":{\"h\":\"Cache\"},\"147\":{\"h\":\"Framework\"},\"148\":{\"h\":\"Spring\"}},\"dirtCount\":0,\"index\":[[\"较有兴趣\",{\"1\":{\"138\":1}}],[\"较为便捷与灵活\",{\"1\":{\"128\":1}}],[\"网上参考资料不少\",{\"1\":{\"137\":1}}],[\"决定是否需要对数据进行切分\",{\"1\":{\"136\":1}}],[\"读缓冲区\",{\"1\":{\"136\":1}}],[\"读取数据并更新至\",{\"1\":{\"104\":1}}],[\"控制台信息\",{\"1\":{\"134\":1}}],[\"控制台结果\",{\"1\":{\"112\":1}}],[\"记得打开浏览器控制台\",{\"1\":{\"134\":1}}],[\"记录\",{\"1\":{\"11\":1,\"92\":1,\"117\":1}}],[\"条消息\",{\"1\":{\"134\":1}}],[\"往服务器连续写入\",{\"1\":{\"134\":1}}],[\"$\",{\"1\":{\"134\":1}}],[\"`收到消息\",{\"1\":{\"134\":1}}],[\"`\",{\"1\":{\"134\":2}}],[\"`连接关闭\",{\"1\":{\"134\":1}}],[\"详细可见\",{\"1\":{\"133\":1}}],[\"详看\",{\"1\":{\"103\":1}}],[\"显式注册应该在启动时注册的带注释的端点类型\",{\"1\":{\"133\":1}}],[\"显著提高了查询效率\",{\"1\":{\"26\":1}}],[\"扫描\",{\"1\":{\"133\":1}}],[\"状态码等\",{\"1\":{\"130\":1}}],[\"状态码为\",{\"1\":{\"128\":1}}],[\"封装了连接关闭原因\",{\"1\":{\"130\":1}}],[\"封装为\",{\"1\":{\"14\":1}}],[\"非预期异常\",{\"1\":{\"128\":1}}],[\"非标准行为和扩展\",{\"1\":{\"75\":1}}],[\"收到消息\",{\"1\":{\"134\":1}}],[\"收到来自客户端的消息\",{\"1\":{\"128\":1}}],[\"收到通知后重新来查询\",{\"1\":{\"117\":1}}],[\"递增\",{\"1\":{\"128\":1}}],[\"二是通过注解\",{\"1\":{\"128\":1}}],[\"二级缓存的内存数据\",{\"1\":{\"102\":1}}],[\"消息接收\",{\"1\":{\"128\":1}}],[\"见参考资料\",{\"1\":{\"128\":1}}],[\"端点后\",{\"1\":{\"133\":1}}],[\"端点的信息\",{\"1\":{\"129\":1}}],[\"端点\",{\"0\":{\"128\":1},\"1\":{\"128\":1,\"133\":1}}],[\"笔者使用的版本\",{\"1\":{\"127\":1}}],[\"项目\",{\"1\":{\"127\":1}}],[\"项目依赖\",{\"0\":{\"127\":1}}],[\"爪洼岛\",{\"1\":{\"125\":1}}],[\"岛\",{\"1\":{\"125\":1}}],[\"雅加达\",{\"1\":{\"125\":2}}],[\"9527是路径参数\",{\"1\":{\"134\":1}}],[\"9527\",{\"1\":{\"134\":2}}],[\"9\",{\"1\":{\"125\":1}}],[\"90\",{\"1\":{\"75\":1,\"85\":2}}],[\"公司捐赠给了\",{\"1\":{\"125\":1}}],[\"公平地说\",{\"1\":{\"82\":2}}],[\"题外话\",{\"1\":{\"125\":1}}],[\"系列的第一篇\",{\"1\":{\"125\":1}}],[\"系统配置参数来决定的\",{\"1\":{\"136\":1}}],[\"系统中的例子\",{\"1\":{\"117\":1}}],[\"系统才会读取该类对应的二进制数据\",{\"1\":{\"48\":1}}],[\"系统变量指定路径中的类库\",{\"1\":{\"47\":1}}],[\"游戏同步\",{\"1\":{\"125\":1}}],[\"响应模式的单向性以及频繁的连接\",{\"1\":{\"125\":1}}],[\"响应模型\",{\"1\":{\"125\":1}}],[\"旨在解决\",{\"1\":{\"125\":1}}],[\"旨在对\",{\"1\":{\"105\":1}}],[\"低延迟的数据传输能力和长连接功能\",{\"1\":{\"125\":1}}],[\"双向通信通道\",{\"1\":{\"125\":1}}],[\"双亲委派模型\",{\"0\":{\"48\":1}}],[\"协议在实时通信方面的局限性\",{\"1\":{\"125\":1}}],[\"协议的全双工通信协议\",{\"1\":{\"125\":1}}],[\"协议\",{\"1\":{\"125\":1}}],[\"协调器在分片解决方案中是不可或缺的\",{\"1\":{\"91\":1}}],[\"协调器将键\",{\"1\":{\"91\":1}}],[\"协调器将记录的主键映射到其中一个分片\",{\"1\":{\"91\":1}}],[\"协调器是唯一了解数据分布的组件\",{\"1\":{\"91\":1}}],[\"尽量不要有\",{\"1\":{\"121\":1}}],[\"尽管\",{\"1\":{\"75\":1,\"80\":1}}],[\"尽管不是所有\",{\"1\":{\"75\":1}}],[\"尽管有一个通用的共识关于如何实现\",{\"1\":{\"75\":1}}],[\"避免因使用不当而带来开发问题\",{\"1\":{\"121\":1}}],[\"同为应用层协议\",{\"1\":{\"125\":1}}],[\"同样会持有\",{\"1\":{\"120\":1}}],[\"同时也可以在端点类中声明静态缓存\",{\"1\":{\"129\":1}}],[\"同时也被用来处理动态链接\",{\"1\":{\"61\":1}}],[\"同时在事务回调中\",{\"1\":{\"121\":1}}],[\"同时支持\",{\"1\":{\"96\":1}}],[\"释放连接\",{\"1\":{\"120\":1}}],[\"恢复为自动提交\",{\"1\":{\"120\":1}}],[\"省略\",{\"1\":{\"120\":1}}],[\"省略其它代码\",{\"1\":{\"120\":1}}],[\"隔离级别与只读设置\",{\"1\":{\"120\":1}}],[\"既然修改了连接的autocommit\",{\"1\":{\"120\":1}}],[\"丑陋就使用策略模式\",{\"1\":{\"119\":1}}],[\"觉得多重\",{\"1\":{\"119\":1}}],[\"思考题\",{\"0\":{\"118\":1}}],[\"才设置为手动提交\",{\"1\":{\"120\":1}}],[\"才能将本次的\",{\"1\":{\"117\":1}}],[\"才会真正提交到数据库\",{\"1\":{\"116\":1}}],[\"才会尝试执行加载任务\",{\"1\":{\"48\":1}}],[\"出现缓存与\",{\"1\":{\"117\":1}}],[\"出入参返回皆会自动转为枚举和增加相应字段\",{\"1\":{\"3\":1}}],[\"虚空好友请求\",{\"1\":{\"117\":1}}],[\"虚拟机规范中对本地方法栈中的方法使用的语言\",{\"1\":{\"63\":1}}],[\"虚拟机规范的\",{\"1\":{\"45\":1}}],[\"虚拟机栈\",{\"0\":{\"60\":1},\"1\":{\"58\":1}}],[\"虚拟机后\",{\"1\":{\"56\":1}}],[\"虚拟机\",{\"1\":{\"56\":1,\"63\":1,\"66\":2,\"70\":1}}],[\"虚拟机认可\",{\"1\":{\"47\":1}}],[\"虚拟机启动时被标明为启动类的类\",{\"1\":{\"46\":1}}],[\"属实是\",{\"1\":{\"117\":1}}],[\"属性必填\",{\"1\":{\"128\":1}}],[\"属性又指向\",{\"1\":{\"19\":1}}],[\"属性指向\",{\"1\":{\"19\":1}}],[\"属性\",{\"0\":{\"11\":1},\"1\":{\"44\":1}}],[\"根本就没有\",{\"1\":{\"117\":1}}],[\"根据异常可针对性的执行某些操作\",{\"1\":{\"131\":1}}],[\"根据异常决定返回什么信息给前端即可\",{\"1\":{\"3\":1}}],[\"根据我们的经验\",{\"1\":{\"78\":1}}],[\"根据key\",{\"1\":{\"26\":1}}],[\"根据上方源码总结下步骤\",{\"1\":{\"14\":1}}],[\"根据\",{\"1\":{\"3\":1,\"128\":1}}],[\"没错\",{\"1\":{\"136\":1}}],[\"没了\",{\"1\":{\"117\":1}}],[\"没有进行\",{\"1\":{\"101\":1}}],[\"没有意识到自己是一个更大系统的一部分\",{\"1\":{\"91\":1}}],[\"没有连结成知识网\",{\"1\":{\"71\":1}}],[\"没有对应的枚举\",{\"1\":{\"3\":1}}],[\"场景示例\",{\"1\":{\"117\":1}}],[\"异步发送通知\",{\"1\":{\"117\":2}}],[\"异常问题\",{\"1\":{\"66\":1}}],[\"异常情况的区域\",{\"1\":{\"59\":1}}],[\"异常处理\",{\"1\":{\"59\":1}}],[\"异常到底涉及了运行时数据内存哪块区域\",{\"1\":{\"57\":1}}],[\"异常\",{\"0\":{\"62\":1,\"65\":1},\"1\":{\"18\":1,\"66\":1,\"67\":1,\"134\":1}}],[\"好友请求\",{\"1\":{\"117\":1}}],[\"好处是分配内存效率高\",{\"1\":{\"64\":1}}],[\"好处是可以对字典做成页面配置\",{\"1\":{\"2\":1}}],[\"举个在我司\",{\"1\":{\"117\":1}}],[\"举个例子\",{\"1\":{\"33\":1}}],[\"任何时候都不会被回调\",{\"1\":{\"115\":1}}],[\"任意类型\",{\"1\":{\"115\":1}}],[\"任由其碰撞了\",{\"1\":{\"33\":1}}],[\"过于简单不再展示结果图片\",{\"1\":{\"113\":1}}],[\"过程理解起来也不难\",{\"1\":{\"16\":1}}],[\"指定感兴趣的事件类名\",{\"1\":{\"113\":1}}],[\"指定事务阶段\",{\"1\":{\"113\":1}}],[\"注入\",{\"1\":{\"135\":1}}],[\"注解\",{\"1\":{\"133\":1}}],[\"注解的\",{\"1\":{\"133\":1}}],[\"注解的类\",{\"1\":{\"133\":1}}],[\"注解的方法是否依然被调用\",{\"1\":{\"113\":1}}],[\"注解还包括subprotocols\",{\"1\":{\"128\":1}}],[\"注解方式方法入参问题\",{\"0\":{\"115\":1}}],[\"注解方式需要通过\",{\"1\":{\"113\":1}}],[\"注册事务同步对象\",{\"1\":{\"112\":1}}],[\"注意其中事务完成后释放连接这一步\",{\"1\":{\"120\":1}}],[\"注意事项\",{\"0\":{\"114\":1}}],[\"注意\",{\"1\":{\"8\":1}}],[\"模拟\",{\"1\":{\"112\":1,\"113\":1}}],[\"模式\",{\"1\":{\"101\":1}}],[\"底层数据会话刷新\",{\"1\":{\"110\":1}}],[\"底层结构新增红黑树\",{\"1\":{\"35\":1}}],[\"底层结构变为\",{\"1\":{\"26\":1}}],[\"底层结构变化为\",{\"1\":{\"24\":1}}],[\"逐渐变得不活跃也就不足为奇了\",{\"1\":{\"105\":1}}],[\"虽然被通知要拉取\",{\"1\":{\"117\":1}}],[\"虽然有\",{\"1\":{\"105\":1}}],[\"虽然分片涉及将数据拆分到多个独立实例中\",{\"1\":{\"92\":1}}],[\"似乎并不活跃\",{\"1\":{\"105\":1}}],[\"似乎仍然在其中找到了它们所需功能的空白\",{\"1\":{\"80\":1}}],[\"又勾起了我的兴趣\",{\"1\":{\"105\":1}}],[\"又是如何操作\",{\"1\":{\"57\":1}}],[\"认为收益不大\",{\"1\":{\"105\":1}}],[\"优先访问\",{\"1\":{\"105\":1}}],[\"优先分配在\",{\"1\":{\"64\":1}}],[\"小故事\",{\"0\":{\"105\":1}}],[\"追踪源码后很快就能理解\",{\"1\":{\"104\":1}}],[\"需实现\",{\"1\":{\"104\":1}}],[\"需要创建serverendpointexporter对\",{\"1\":{\"133\":1}}],[\"需要继承transactionsynchronizationadapte抽象类\",{\"1\":{\"112\":1}}],[\"需要事务管理器有刷新概念\",{\"1\":{\"110\":1}}],[\"需要在事务提交前\",{\"1\":{\"109\":1}}],[\"需要在application\",{\"1\":{\"3\":1}}],[\"需要做出大量决策\",{\"1\":{\"92\":1}}],[\"需要此\",{\"1\":{\"83\":1}}],[\"需要您填写表格才能手动访问\",{\"1\":{\"82\":1}}],[\"需要进行\",{\"1\":{\"82\":1}}],[\"需要调试\",{\"1\":{\"81\":1}}],[\"需要开发者提交审核\",{\"1\":{\"75\":1}}],[\"需要改变位置的链表头节点\",{\"1\":{\"33\":1}}],[\"需要利用到\",{\"1\":{\"3\":1}}],[\"需要依赖字典做条件判断\",{\"1\":{\"2\":1}}],[\"外还包括以下几种\",{\"1\":{\"104\":1}}],[\"下是从\",{\"1\":{\"128\":1}}],[\"下图展示过程\",{\"1\":{\"117\":1}}],[\"下次从\",{\"1\":{\"104\":1}}],[\"下面会讲到\",{\"1\":{\"44\":1}}],[\"下面是源码\",{\"1\":{\"29\":1}}],[\"纵观下来\",{\"1\":{\"104\":1}}],[\"待下次读取数据时\",{\"1\":{\"104\":1}}],[\"退出集群\",{\"1\":{\"104\":1}}],[\"删除\",{\"1\":{\"117\":1}}],[\"删除目标好友\",{\"1\":{\"117\":1}}],[\"删除本地缓存\",{\"1\":{\"104\":1}}],[\"删除缓存\",{\"1\":{\"104\":1}}],[\"删除元素和扩容等方法增加了对红黑树节点的判断\",{\"1\":{\"35\":1}}],[\"被修改\",{\"1\":{\"103\":1}}],[\"订阅者接收进行解析从而确定执行的命令\",{\"1\":{\"103\":1}}],[\"手动构建\",{\"1\":{\"103\":1}}],[\"清理资源时才会去执行\",{\"1\":{\"120\":1}}],[\"清理\",{\"1\":{\"109\":1}}],[\"清除操作\",{\"1\":{\"103\":1}}],[\"清空缓存\",{\"1\":{\"104\":1}}],[\"清空一\",{\"1\":{\"102\":1}}],[\"清空\",{\"1\":{\"12\":1}}],[\"保存在实例变量中\",{\"1\":{\"128\":1}}],[\"保存连接在\",{\"1\":{\"120\":1}}],[\"保存到一二级缓存\",{\"1\":{\"103\":1}}],[\"保持一致\",{\"1\":{\"99\":1}}],[\"代码示例\",{\"0\":{\"103\":1}}],[\"代码生成器之类的案例\",{\"1\":{\"49\":1}}],[\"断开开销\",{\"1\":{\"125\":1}}],[\"断开二级缓存的连接\",{\"1\":{\"102\":1}}],[\"断言和登录提示\",{\"1\":{\"78\":1}}],[\"填充\",{\"1\":{\"102\":1}}],[\"地址\",{\"1\":{\"101\":1}}],[\"想必大家也能意识到\",{\"1\":{\"129\":1}}],[\"想想再看答案\",{\"1\":{\"118\":1}}],[\"想看配置文件即可\",{\"1\":{\"101\":1}}],[\"想要与\",{\"1\":{\"82\":1}}],[\"想要强化个人的技术\",{\"1\":{\"69\":1}}],[\"官方还提到了它与\",{\"1\":{\"105\":1}}],[\"官方推荐\",{\"1\":{\"101\":1}}],[\"官方仓库后\",{\"1\":{\"105\":1}}],[\"官方仓库\",{\"1\":{\"96\":1,\"105\":1}}],[\"永不过期\",{\"1\":{\"101\":1}}],[\"永久代则被替换为\",{\"1\":{\"66\":1}}],[\"永久代\",{\"1\":{\"66\":1}}],[\"了\",{\"1\":{\"117\":1}}],[\"了个对象并保存了二级缓存的\",{\"1\":{\"101\":1}}],[\"了解到存在与\",{\"1\":{\"105\":1}}],[\"了解它们的细微差别对于明智的数据库设计和选择至关重要\",{\"1\":{\"92\":1}}],[\"了解所需的参数\",{\"1\":{\"75\":1}}],[\"广播两者都会创建相应的\",{\"1\":{\"101\":1}}],[\"得保持一致\",{\"1\":{\"101\":1}}],[\"选择了\",{\"1\":{\"101\":1}}],[\"支持的节点间数据同步方案除了\",{\"1\":{\"104\":1}}],[\"支持同步异步调用\",{\"1\":{\"101\":1}}],[\"支持超过\",{\"1\":{\"75\":1}}],[\"名称\",{\"1\":{\"101\":2}}],[\"级缓存的连接配置\",{\"1\":{\"101\":1}}],[\"核心配置\",{\"1\":{\"101\":1}}],[\"静态配置与动态配置读取\",{\"1\":{\"103\":1}}],[\"静态配置的使用需要在代码中手动使用\",{\"1\":{\"101\":1}}],[\"静态配置\",{\"0\":{\"101\":1}}],[\"静态变量\",{\"1\":{\"66\":1}}],[\"应用中常用的通讯协议之一\",{\"1\":{\"125\":1}}],[\"应用中\",{\"1\":{\"109\":1}}],[\"应用\",{\"0\":{\"100\":1}}],[\"应用程序时设置的内容来完成\",{\"1\":{\"79\":1}}],[\"应用程序类加载器\",{\"1\":{\"47\":1}}],[\"配置端点扫描\",{\"0\":{\"133\":1}}],[\"配置信息\",{\"1\":{\"128\":1}}],[\"配置\",{\"1\":{\"101\":1,\"128\":1}}],[\"配置文件设置\",{\"1\":{\"99\":1}}],[\"配备客户端库后\",{\"1\":{\"76\":1}}],[\"策略的缓存数据放在一起进行管理\",{\"1\":{\"99\":1}}],[\"单位\",{\"1\":{\"136\":1}}],[\"单节点\",{\"1\":{\"101\":1}}],[\"单节点使用\",{\"1\":{\"98\":1}}],[\"单机也可以使用\",{\"1\":{\"96\":1}}],[\"单机多实例\",{\"1\":{\"89\":1}}],[\"无限制\",{\"1\":{\"132\":1}}],[\"无值\",{\"1\":{\"115\":1}}],[\"无效\",{\"1\":{\"101\":1}}],[\"无需担心\",{\"1\":{\"97\":1}}],[\"无论方法是正常完成还是异常完成\",{\"1\":{\"61\":1}}],[\"起步\",{\"1\":{\"97\":1}}],[\"云\",{\"1\":{\"97\":1}}],[\"远端缓存\",{\"1\":{\"97\":1}}],[\"把\",{\"1\":{\"97\":1}}],[\"把常量池内的符号引用转换为直接引用\",{\"0\":{\"45\":1}}],[\"利用现有优秀的内存缓存缓存\",{\"1\":{\"97\":1}}],[\"仅仅是数据吞吐量大而已\",{\"1\":{\"97\":1}}],[\"仅第一次\",{\"1\":{\"33\":1}}],[\"压力\",{\"1\":{\"97\":1}}],[\"带宽\",{\"1\":{\"97\":1}}],[\"带宽跑满\",{\"1\":{\"97\":1}}],[\"给数据库造成巨大压力\",{\"1\":{\"97\":1}}],[\"进程内可用\",{\"1\":{\"97\":1}}],[\"进行关闭\",{\"1\":{\"131\":1}}],[\"进行编写\",{\"1\":{\"113\":1}}],[\"进行构建\",{\"1\":{\"82\":1}}],[\"进行位运算\",{\"1\":{\"33\":1}}],[\"进行\",{\"1\":{\"33\":1}}],[\"进行异或运算\",{\"1\":{\"32\":1}}],[\"速度快\",{\"1\":{\"97\":1}}],[\"推荐\",{\"1\":{\"96\":1}}],[\"推荐使用\",{\"1\":{\"18\":1}}],[\"研发的两级缓存框架\",{\"1\":{\"96\":1}}],[\"介绍第一种方式\",{\"1\":{\"125\":1}}],[\"介绍\",{\"0\":{\"96\":1,\"125\":1}}],[\"快速上手指南\",{\"0\":{\"95\":1}}],[\"缓存区的大小\",{\"1\":{\"136\":1}}],[\"缓存重新被添加回来\",{\"1\":{\"117\":1}}],[\"缓存进行抽象\",{\"1\":{\"105\":1}}],[\"缓存是否也可存在此种做法\",{\"1\":{\"105\":1}}],[\"缓存\",{\"1\":{\"104\":1,\"117\":2}}],[\"缓存操作\",{\"1\":{\"103\":1}}],[\"缓存序列化方式\",{\"1\":{\"101\":1}}],[\"缓存实现类名称\",{\"1\":{\"101\":1}}],[\"缓存广播信息等\",{\"1\":{\"101\":1}}],[\"缓存雪崩\",{\"1\":{\"97\":1}}],[\"缓存框架\",{\"0\":{\"95\":1}}],[\"缓存机制将会保证所有加载过的\",{\"1\":{\"48\":1}}],[\"缓存机制\",{\"1\":{\"48\":1}}],[\"两种架构都有其优点\",{\"1\":{\"92\":1}}],[\"两者区别主要在于\",{\"1\":{\"66\":1}}],[\"建立在无共享架构之上的分布式数据库缺乏这种集中的协调器\",{\"1\":{\"92\":1}}],[\"另一方面\",{\"1\":{\"92\":1}}],[\"另一个常见的错误是发送的范围与您在应用程序中预先注册的范围不匹配\",{\"1\":{\"81\":1}}],[\"另一个是因为复制数据是在\",{\"1\":{\"25\":1}}],[\"强调了这种区别\",{\"1\":{\"92\":1}}],[\"客户端可能连接到\",{\"1\":{\"92\":1}}],[\"客户端只需与任何节点建立连接并允许该节点管理分布式方面\",{\"1\":{\"92\":1}}],[\"客户端错误\",{\"1\":{\"81\":1}}],[\"答案很简单\",{\"1\":{\"91\":1}}],[\"映射到分片\",{\"1\":{\"91\":1}}],[\"路径参数则需要在\",{\"1\":{\"128\":1}}],[\"路由器或导向器\",{\"1\":{\"91\":1}}],[\"路漫漫其修远兮\",{\"1\":{\"71\":1}}],[\"诸如\",{\"1\":{\"89\":1}}],[\"杂谈\",{\"2\":{\"86\":1,\"87\":1,\"93\":1,\"94\":1}}],[\"感谢您的阅读并快乐授权\",{\"1\":{\"85\":1}}],[\"感兴趣的同学可自己追踪源码\",{\"1\":{\"3\":1}}],[\"社区中听到它\",{\"1\":{\"85\":1}}],[\"恐怖故事\",{\"1\":{\"85\":1}}],[\"附带预构建的\",{\"1\":{\"85\":1}}],[\"独立的服务\",{\"1\":{\"85\":1}}],[\"让其拉取最新好友请求记录\",{\"1\":{\"117\":1}}],[\"让用户知道访问令牌已过期\",{\"1\":{\"84\":1}}],[\"让我们制作一个更简单的\",{\"1\":{\"79\":1}}],[\"让我们看一下许多\",{\"1\":{\"78\":1}}],[\"让我们只关注可能与典型\",{\"1\":{\"78\":1}}],[\"让我们深入了解一下\",{\"1\":{\"77\":1}}],[\"让我们来粗浅的聊聊它吧\",{\"1\":{\"8\":1}}],[\"检测提供商端用户撤销的访问令牌\",{\"1\":{\"84\":1}}],[\"检查授予的范围是否与请求的范围匹配\",{\"1\":{\"84\":1}}],[\"刷新令牌时避免竞争条件\",{\"1\":{\"84\":1}}],[\"刷新令牌也是一种授予类型\",{\"1\":{\"78\":1}}],[\"允许用户更改他们在授权流程中授予的范围\",{\"1\":{\"84\":1}}],[\"允许为\",{\"1\":{\"18\":1}}],[\"遗憾的是\",{\"1\":{\"84\":1}}],[\"发起查询请求时\",{\"1\":{\"117\":1}}],[\"发起\",{\"1\":{\"117\":1}}],[\"发起好友请求\",{\"1\":{\"117\":1}}],[\"发出的\",{\"1\":{\"117\":1}}],[\"发送\",{\"1\":{\"128\":1}}],[\"发送消息给客户端\",{\"1\":{\"128\":1}}],[\"发送的\",{\"1\":{\"117\":1}}],[\"发送通知给\",{\"1\":{\"117\":1}}],[\"发现只是介绍了\",{\"1\":{\"138\":1}}],[\"发现它早于我最初构想时就已存在\",{\"1\":{\"105\":1}}],[\"发现并解决这些问题\",{\"1\":{\"50\":1}}],[\"发布\",{\"1\":{\"115\":1}}],[\"发布事件\",{\"1\":{\"113\":1}}],[\"发布相应的事件\",{\"1\":{\"113\":1}}],[\"发布后的被订阅者接收只会清除一级缓存\",{\"1\":{\"103\":1}}],[\"发布通知\",{\"1\":{\"103\":1}}],[\"发生\",{\"1\":{\"83\":1}}],[\"预计某些刷新会失败\",{\"1\":{\"83\":1}}],[\"预注册范围\",{\"1\":{\"81\":1}}],[\"某些\",{\"1\":{\"83\":2,\"84\":1}}],[\"竞争条件\",{\"1\":{\"83\":1}}],[\"竞用条件\",{\"1\":{\"19\":1}}],[\"仍在使用\",{\"1\":{\"83\":1}}],[\"仍然存在一个问题\",{\"1\":{\"91\":1}}],[\"仍然被一些人使用\",{\"1\":{\"78\":1}}],[\"仍然是一团糟\",{\"1\":{\"76\":1}}],[\"仍然很难\",{\"0\":{\"76\":1}}],[\"仍然觉得需要添加一些非标准的功能\",{\"1\":{\"75\":1}}],[\"技术的发展\",{\"1\":{\"83\":1}}],[\"技术博客\",{\"1\":{\"70\":1}}],[\"截至撰写本文时\",{\"1\":{\"82\":1}}],[\"合作伙伴并在他们的应用商店中列出您的应用程序\",{\"1\":{\"82\":1}}],[\"视频演练\",{\"1\":{\"82\":1}}],[\"多个值时\",{\"1\":{\"115\":1}}],[\"多个线程可共享同一个\",{\"1\":{\"101\":1}}],[\"多个应用节点无法共享缓存数据\",{\"1\":{\"97\":1}}],[\"多个\",{\"1\":{\"85\":1}}],[\"多个问题和安全预生产筛查\",{\"1\":{\"82\":1}}],[\"多线程操作\",{\"1\":{\"19\":1}}],[\"集成\",{\"0\":{\"124\":1,\"126\":1}}],[\"集成吗\",{\"1\":{\"82\":1}}],[\"集中式缓存\",{\"1\":{\"97\":1}}],[\"集群连接\",{\"1\":{\"102\":1}}],[\"集群会自动重新平衡并拆分分片\",{\"1\":{\"92\":1}}],[\"集群中的所有节点都了解彼此\",{\"1\":{\"92\":1}}],[\"集群中的所有节点都了解彼此和数据分布\",{\"1\":{\"89\":1}}],[\"集合\",{\"1\":{\"12\":2},\"2\":{\"22\":1,\"37\":1}}],[\"通知\",{\"1\":{\"117\":1}}],[\"通常被忽略的\",{\"1\":{\"81\":1}}],[\"通过字符串类型的\",{\"1\":{\"132\":1}}],[\"通过端点路径是可以传递查询参数或路径参数的\",{\"1\":{\"129\":1}}],[\"通过直接通信\",{\"1\":{\"92\":1}}],[\"通过该计数器\",{\"1\":{\"59\":1}}],[\"通过class\",{\"1\":{\"46\":1}}],[\"通过类名获取\",{\"1\":{\"46\":1}}],[\"通过子类引用父类的静态字段\",{\"1\":{\"46\":1}}],[\"通过数据流和控制流分析\",{\"1\":{\"43\":1}}],[\"通过元素原\",{\"1\":{\"33\":1}}],[\"通过源码可知是因为内部方法都加上了\",{\"1\":{\"18\":1}}],[\"通过\",{\"1\":{\"14\":1,\"24\":1,\"117\":2,\"129\":1}}],[\"通过key\",{\"1\":{\"26\":1}}],[\"通过key删除元素\",{\"1\":{\"12\":1}}],[\"通过key获取value`\",{\"1\":{\"12\":1}}],[\"通过一张图来简单理解下\",{\"1\":{\"10\":1}}],[\"通过文本获取值\",{\"1\":{\"3\":1}}],[\"告诉我们\",{\"1\":{\"81\":1}}],[\"你得到的错误是\",{\"1\":{\"81\":1}}],[\"顺便说一下\",{\"1\":{\"81\":1}}],[\"事件则会抛出异常\",{\"1\":{\"115\":1}}],[\"事件时可正确执行\",{\"1\":{\"115\":1}}],[\"事务在日常开发中应用不少\",{\"1\":{\"121\":1}}],[\"事务的本质是获取到\",{\"1\":{\"120\":1}}],[\"事务管理\",{\"1\":{\"117\":1}}],[\"事务范围问题\",{\"0\":{\"116\":1}}],[\"事务方法里发布事件\",{\"1\":{\"113\":1}}],[\"事务接口方法\",{\"1\":{\"112\":1}}],[\"事务状态\",{\"1\":{\"112\":1}}],[\"事务名称\",{\"1\":{\"112\":1}}],[\"事务回调中的\",{\"1\":{\"120\":1}}],[\"事务回调的条件\",{\"1\":{\"113\":1}}],[\"事务回滚\",{\"1\":{\"110\":1}}],[\"事务回复\",{\"1\":{\"110\":1}}],[\"事务完成\",{\"1\":{\"110\":1}}],[\"事务完成后连接autocommit修改源码如下\",{\"1\":{\"120\":1}}],[\"事务完成后回调\",{\"1\":{\"112\":1}}],[\"事务完成后\",{\"1\":{\"110\":1}}],[\"事务完成前\",{\"1\":{\"110\":1}}],[\"事务提交\",{\"1\":{\"117\":2}}],[\"事务提交后回调\",{\"1\":{\"112\":1,\"113\":1}}],[\"事务提交后\",{\"1\":{\"110\":1}}],[\"事务提交前\",{\"1\":{\"110\":1}}],[\"事务挂起\",{\"1\":{\"110\":1}}],[\"事务功能在日常开发中使用并不少\",{\"1\":{\"109\":1}}],[\"事务同步测试\",{\"1\":{\"112\":1}}],[\"事务同步回调顺序\",{\"1\":{\"110\":1}}],[\"事务同步回调接口是transactionsynchronization\",{\"1\":{\"110\":1}}],[\"事务同步接口\",{\"0\":{\"110\":1}}],[\"事务同步\",{\"0\":{\"108\":1}}],[\"事实是\",{\"1\":{\"82\":1}}],[\"事实上\",{\"1\":{\"79\":1,\"83\":1}}],[\"事情会变得更加困难\",{\"1\":{\"81\":1}}],[\"库中找到对此的支持\",{\"1\":{\"80\":1}}],[\"机器人持有的范围和允许您代表授权您的应用程序的用户采取操作的范围\",{\"1\":{\"80\":1}}],[\"机械工业出版社\",{\"1\":{\"51\":1,\"70\":2}}],[\"访问令牌会在预设时间段后过期\",{\"1\":{\"80\":1}}],[\"访问某个类或接口的静态变量\",{\"1\":{\"46\":1}}],[\"回调中的附加参数\",{\"1\":{\"80\":1}}],[\"看着你\",{\"1\":{\"80\":1}}],[\"岂不是很完美\",{\"1\":{\"80\":1}}],[\"向\",{\"0\":{\"80\":1}}],[\"©xkcd至少\",{\"1\":{\"83\":1}}],[\"©xkcd当我调试\",{\"1\":{\"81\":1}}],[\"©xkcd\",{\"1\":{\"79\":1,\"81\":1,\"83\":1}}],[\"©xkcdoauth太复杂\",{\"1\":{\"79\":1}}],[\"幸运的是\",{\"1\":{\"79\":1,\"83\":1}}],[\"欢迎印度客户访问\",{\"1\":{\"79\":1}}],[\"欢迎读者尝试使用并提供反馈\",{\"1\":{\"75\":1}}],[\"欧洲客户可以访问\",{\"1\":{\"79\":1}}],[\"希望他们记住数据所在的位置\",{\"1\":{\"79\":1}}],[\"zoho\",{\"1\":{\"79\":8}}],[\"zendesk\",{\"1\":{\"79\":2}}],[\"zero\",{\"1\":{\"33\":1}}],[\"构建的连接\",{\"1\":{\"101\":1}}],[\"构建的审批繁琐\",{\"0\":{\"82\":1}}],[\"构建到模型和前端代码中\",{\"1\":{\"79\":1}}],[\"构造函数\",{\"1\":{\"10\":1}}],[\"编码为\",{\"1\":{\"79\":1}}],[\"编译语言层面的概念\",{\"1\":{\"67\":1}}],[\"编译器编译后的代码等\",{\"1\":{\"66\":1}}],[\"编译器有栈上分配\",{\"1\":{\"64\":1}}],[\"编译器会自动收集类中的类变量赋值操作和静态代码块的语句合并而成\",{\"1\":{\"46\":1}}],[\"坚持在标头中获取数据\",{\"1\":{\"79\":1}}],[\"医生了解详细信息\",{\"1\":{\"79\":1}}],[\"功能\",{\"1\":{\"79\":1}}],[\"取消了无处不在的作用域参数\",{\"1\":{\"79\":1}}],[\"取值\",{\"1\":{\"13\":1,\"16\":1}}],[\"微软的某人发现了response\",{\"1\":{\"79\":1}}],[\"谷歌更喜欢通过不同的范围来处理这个问题\",{\"1\":{\"79\":1}}],[\"question\",{\"1\":{\"91\":1}}],[\"questions\",{\"1\":{\"82\":1}}],[\"query\",{\"1\":{\"79\":1,\"80\":1}}],[\"quality\",{\"1\":{\"82\":1}}],[\"quick\",{\"1\":{\"82\":1}}],[\"quickbooks\",{\"1\":{\"80\":2}}],[\"quickly\",{\"1\":{\"79\":1}}],[\"quirky\",{\"1\":{\"80\":1}}],[\"quirks\",{\"1\":{\"77\":1}}],[\"quite\",{\"1\":{\"77\":1}}],[\"子\",{\"1\":{\"78\":1}}],[\"子集\",{\"1\":{\"78\":1}}],[\"子集不同\",{\"1\":{\"75\":1}}],[\"步流程的清晰视觉效果呢\",{\"1\":{\"78\":1}}],[\"步骤\",{\"1\":{\"113\":3}}],[\"步骤若是反复验证影响了加载效率该如何做\",{\"1\":{\"50\":1}}],[\"步骤如下\",{\"1\":{\"15\":1,\"31\":1}}],[\"授权页面\",{\"1\":{\"79\":1}}],[\"授权代码\",{\"1\":{\"78\":1}}],[\"授权类型\",{\"1\":{\"78\":1}}],[\"他们彼此不知情\",{\"1\":{\"91\":1}}],[\"他们将从该商店产生的每条销售线索中扣除\",{\"1\":{\"82\":1}}],[\"他们不会在令牌响应中告诉您刚刚收到的访问令牌何时过期\",{\"1\":{\"80\":1}}],[\"他们称之为instance\",{\"1\":{\"80\":1}}],[\"他们唯一一次告诉您此\",{\"1\":{\"80\":1}}],[\"他们会善意地提醒您\",{\"1\":{\"79\":1}}],[\"他们明天可能会改变主意\",{\"1\":{\"79\":1}}],[\"他们希望在令牌请求调用中看到什么\",{\"1\":{\"79\":1}}],[\"他们为什么要重新发明这个轮子\",{\"1\":{\"79\":1}}],[\"他们在授权调用中需要哪些参数\",{\"1\":{\"79\":1}}],[\"他们对\",{\"1\":{\"78\":1}}],[\"他们没有实现完整的\",{\"1\":{\"78\":1}}],[\"工作组为您提供了相当冗长的指南\",{\"1\":{\"83\":1}}],[\"工作\",{\"1\":{\"78\":1}}],[\"部分\",{\"1\":{\"78\":1}}],[\"然而在查看了下\",{\"1\":{\"105\":1}}],[\"然而\",{\"1\":{\"78\":1,\"82\":1,\"91\":1,\"92\":1,\"105\":1}}],[\"然后启动服务\",{\"1\":{\"134\":1}}],[\"然后由\",{\"1\":{\"120\":1}}],[\"然后发给指定的\",{\"1\":{\"104\":1}}],[\"然后映射到相应的数据库实例\",{\"1\":{\"91\":1}}],[\"然后将记录插入到存储在数据库实例上的表\",{\"1\":{\"91\":1}}],[\"然后将请求转发到负责该分片的数据库实例\",{\"1\":{\"91\":1}}],[\"然后将其分布在多个数据库实例中来利用水平可扩展性\",{\"1\":{\"90\":1}}],[\"然后将key和value作为entry<k\",{\"1\":{\"10\":1}}],[\"然后\",{\"1\":{\"82\":1}}],[\"然后系统加以运行\",{\"1\":{\"57\":1}}],[\"然后编写加载的具体逻辑代码即可\",{\"1\":{\"49\":1}}],[\"然后进入putval\",{\"1\":{\"30\":1}}],[\"然后确定数组下标\",{\"1\":{\"26\":1}}],[\"然后通过instanceof或class\",{\"1\":{\"119\":1}}],[\"然后通过key\",{\"1\":{\"31\":1}}],[\"然后通过\",{\"1\":{\"20\":1}}],[\"然后在pom\",{\"1\":{\"127\":1}}],[\"然后在堆区创建一个java\",{\"1\":{\"39\":1}}],[\"然后在\",{\"1\":{\"3\":1}}],[\"资源\",{\"1\":{\"78\":1}}],[\"受众参数是关键\",{\"1\":{\"79\":1}}],[\"受众\",{\"1\":{\"78\":1}}],[\"范围的更改\",{\"1\":{\"84\":1}}],[\"范围或注册\",{\"1\":{\"79\":1}}],[\"范围\",{\"1\":{\"78\":1,\"79\":1}}],[\"具体源码可以看\",{\"1\":{\"136\":1}}],[\"具体的参数可以参考\",{\"1\":{\"102\":1}}],[\"具体如何避免该问题\",{\"1\":{\"49\":1}}],[\"具有标准化的错误消息\",{\"1\":{\"81\":1}}],[\"具有定义含义和行为的官方\",{\"1\":{\"78\":1}}],[\"准确地说是\",{\"1\":{\"78\":1}}],[\"准备好接受\",{\"1\":{\"82\":1}}],[\"准备\",{\"0\":{\"44\":1}}],[\"稍后会详细介绍\",{\"1\":{\"78\":1}}],[\"旁注\",{\"1\":{\"78\":1}}],[\"什么时候应该使用它们\",{\"1\":{\"78\":1}}],[\"什么是\",{\"0\":{\"55\":1}}],[\"什么是类的加载\",{\"0\":{\"39\":1}}],[\"什么是红黑树\",{\"1\":{\"34\":1}}],[\"吗\",{\"1\":{\"78\":1}}],[\"肯定不是所有这些\",{\"1\":{\"78\":1}}],[\"令牌到威胁模型和私钥\",{\"1\":{\"78\":1}}],[\"框架和\",{\"1\":{\"78\":1}}],[\"框架到威胁模型和私钥\",{\"1\":{\"75\":1}}],[\"问题二\",{\"0\":{\"120\":1}}],[\"问题一\",{\"0\":{\"119\":1}}],[\"问题时\",{\"1\":{\"97\":1}}],[\"问题在于\",{\"1\":{\"78\":1}}],[\"问题\",{\"0\":{\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1},\"1\":{\"97\":1}}],[\"那就很有趣了\",{\"1\":{\"77\":1}}],[\"那么当回调\",{\"1\":{\"136\":1}}],[\"那么当执行到步骤\",{\"1\":{\"117\":1}}],[\"那么会由messagebufferbinary接收\",{\"1\":{\"136\":1}}],[\"那么没拿到最后一份数据时\",{\"1\":{\"136\":1}}],[\"那么事务执行完后就得将连接恢复到初始状态\",{\"1\":{\"120\":1}}],[\"那么在方法体里如果获取本次事务监听的事件信息呢\",{\"1\":{\"118\":1}}],[\"那么操作依旧会参与原事务\",{\"1\":{\"116\":1}}],[\"那么\",{\"1\":{\"103\":1}}],[\"那么它将在本地存储该记录\",{\"1\":{\"92\":1}}],[\"那么有什么可调试的呢\",{\"1\":{\"81\":1}}],[\"那么编译器可以不为这个类生成构造器方法\",{\"1\":{\"46\":1}}],[\"那么类加载器就不会报告错误\",{\"1\":{\"39\":1}}],[\"那么执行\",{\"1\":{\"3\":1}}],[\"那么使用参数时也可以更灵活\",{\"1\":{\"3\":1}}],[\"体验可与\",{\"1\":{\"77\":1}}],[\"现象就是\",{\"1\":{\"97\":1}}],[\"现在您的\",{\"1\":{\"84\":1}}],[\"现在您已准备好接收请求\",{\"1\":{\"78\":1}}],[\"现在你需要让他们开心\",{\"1\":{\"82\":1}}],[\"现在很多\",{\"1\":{\"81\":1}}],[\"现在大多数\",{\"1\":{\"79\":1}}],[\"现在是默认值\",{\"1\":{\"78\":1}}],[\"现在明白平常用\",{\"1\":{\"60\":1}}],[\"现实世界的\",{\"1\":{\"77\":1}}],[\"日历\",{\"1\":{\"77\":1}}],[\"例如电子邮件内容\",{\"1\":{\"82\":1}}],[\"例如\",{\"1\":{\"77\":1,\"79\":3,\"81\":1,\"83\":1,\"91\":1,\"92\":1}}],[\"‍\",{\"1\":{\"77\":1}}],[\"请考虑研究\",{\"1\":{\"92\":1}}],[\"请考虑探索\",{\"1\":{\"91\":1}}],[\"请使用\",{\"1\":{\"79\":1}}],[\"请咨询您的\",{\"1\":{\"79\":1}}],[\"请尝试\",{\"1\":{\"78\":1}}],[\"请继续\",{\"1\":{\"78\":1}}],[\"请给我们发电子邮件\",{\"1\":{\"76\":1}}],[\"请求无效\",{\"1\":{\"81\":1}}],[\"请求中传递该realmid\",{\"1\":{\"80\":1}}],[\"请求来获取此信息要好\",{\"1\":{\"80\":1}}],[\"请求方式\",{\"1\":{\"75\":1}}],[\"请求只需指定数值\",{\"1\":{\"3\":1}}],[\"请求\",{\"1\":{\"3\":1}}],[\"您就会意识到向后兼容性是一场永无休止的斗争\",{\"1\":{\"83\":1}}],[\"您必须成为\",{\"1\":{\"82\":1}}],[\"您的客户要求集成\",{\"1\":{\"82\":1}}],[\"您的美国客户应访问\",{\"1\":{\"79\":1}}],[\"您最好意识到这一点\",{\"1\":{\"80\":1}}],[\"您作为\",{\"1\":{\"80\":1}}],[\"您还需要一些数据才能使用\",{\"1\":{\"80\":1}}],[\"您可能会想\",{\"1\":{\"85\":1}}],[\"您可能会处于较弱的位置\",{\"1\":{\"82\":1}}],[\"您可能会说\",{\"1\":{\"81\":1}}],[\"您可能会得出结论\",{\"1\":{\"76\":1}}],[\"您可以在注册应用程序时设置它们\",{\"1\":{\"79\":1}}],[\"您甚至在他们的\",{\"1\":{\"79\":1}}],[\"您需要安全\",{\"1\":{\"84\":1}}],[\"您需要在授权调用中传递该参数\",{\"1\":{\"80\":1}}],[\"您需要在每个api\",{\"1\":{\"80\":1}}],[\"您需要查询额外的令牌详细信息端点以获取令牌的\",{\"1\":{\"80\":1}}],[\"您需要请求\",{\"1\":{\"79\":1}}],[\"您需要阅读一本小书\",{\"1\":{\"78\":1}}],[\"您需要\",{\"1\":{\"78\":1}}],[\"您将能够在大约\",{\"1\":{\"76\":1}}],[\"正确的\",{\"1\":{\"76\":1}}],[\"安全令牌存储以及针对\",{\"1\":{\"85\":1}}],[\"安全审查\",{\"1\":{\"82\":1}}],[\"安全的令牌存储和自动令牌刷新功能\",{\"1\":{\"75\":1}}],[\"安全性随着每次迭代而变得越来越好\",{\"1\":{\"83\":1}}],[\"安全性很困难且目标不断变化\",{\"0\":{\"83\":1}}],[\"安全性难以把握且不断变化\",{\"1\":{\"75\":1}}],[\"安全性\",{\"1\":{\"75\":1}}],[\"它与\",{\"1\":{\"125\":1}}],[\"它与虚拟机实现的布局无关\",{\"1\":{\"45\":1}}],[\"它将客户端请求映射到特定的分片\",{\"1\":{\"91\":1}}],[\"它负责了解数据分布并映射客户端请求到特定的分片和数据库实例\",{\"1\":{\"89\":1}}],[\"它通过将原始数据集拆分为多个分片\",{\"1\":{\"89\":1}}],[\"它们还可以执行和协调多节点交易\",{\"1\":{\"92\":1}}],[\"它们存在于孤立的环境中\",{\"1\":{\"89\":1}}],[\"它们就像用户帐户的密码\",{\"1\":{\"84\":1}}],[\"它们可能在安全性和质量方面带来净收益\",{\"1\":{\"82\":1}}],[\"它们返回用户的\",{\"1\":{\"80\":1}}],[\"它们的工作方式是标准化的\",{\"1\":{\"78\":1}}],[\"它们有什么作用\",{\"1\":{\"78\":1}}],[\"它们涵盖了从\",{\"1\":{\"78\":1}}],[\"它们共同定义了\",{\"1\":{\"78\":1}}],[\"它提供了预构建的\",{\"1\":{\"75\":1}}],[\"甚至要求开发者与他们签订收入分成协议\",{\"1\":{\"75\":1}}],[\"导致图中步骤\",{\"1\":{\"117\":1}}],[\"导致数据读取非常慢\",{\"1\":{\"97\":1}}],[\"导致缓存服务的数据吞吐量太大\",{\"1\":{\"97\":1}}],[\"导致应用堵塞\",{\"1\":{\"97\":1}}],[\"导致\",{\"1\":{\"75\":1}}],[\"导致旧数据复制到新数组产生死循环\",{\"1\":{\"19\":1}}],[\"缺少文档等\",{\"1\":{\"84\":1}}],[\"缺失细节或未更新的情况很常见\",{\"1\":{\"75\":1}}],[\"缺点是需要网络调用接口\",{\"1\":{\"2\":1}}],[\"流程已运行并且您获得了访问令牌\",{\"1\":{\"84\":1}}],[\"流程时\",{\"1\":{\"81\":1}}],[\"流程中有\",{\"1\":{\"81\":1}}],[\"流程中的\",{\"1\":{\"80\":1}}],[\"流程很困难\",{\"0\":{\"81\":1}}],[\"流程\",{\"1\":{\"75\":1,\"78\":1,\"80\":1,\"85\":1}}],[\"流程在首次实施时经常遇到问题\",{\"1\":{\"75\":1}}],[\"流程困难\",{\"1\":{\"75\":1}}],[\"流行程度\",{\"1\":{\"71\":1}}],[\"许多人都会很快处理请求\",{\"1\":{\"82\":1}}],[\"许多人对此不屑一顾\",{\"1\":{\"79\":1}}],[\"许多流行的\",{\"1\":{\"75\":1}}],[\"许多\",{\"0\":{\"80\":1},\"1\":{\"75\":1,\"82\":1}}],[\"定义好\",{\"1\":{\"133\":1}}],[\"定义标准的文档\",{\"1\":{\"75\":1,\"78\":1}}],[\"定义数组对象\",{\"1\":{\"46\":1}}],[\"标准将强制执行一些当前的最佳实践\",{\"1\":{\"83\":1}}],[\"标准也发生了变化\",{\"1\":{\"83\":1}}],[\"标准也在不断变化\",{\"1\":{\"75\":1}}],[\"标准中推荐的错误消息之一\",{\"1\":{\"81\":1}}],[\"标准很庞大\",{\"1\":{\"80\":1}}],[\"标准太大且复杂\",{\"0\":{\"78\":1}}],[\"标准\",{\"1\":{\"75\":1,\"78\":1}}],[\"标准已经非常广泛\",{\"1\":{\"75\":1}}],[\"标准包含了\",{\"1\":{\"75\":1}}],[\"标准过于庞大和复杂\",{\"1\":{\"75\":1}}],[\"标量替换等优化技术的实现导致部分对象实例数据不存在\",{\"1\":{\"64\":1}}],[\"浏览器控制台信息\",{\"1\":{\"134\":1}}],[\"浏览器\",{\"1\":{\"75\":1,\"77\":1}}],[\"年被\",{\"1\":{\"125\":1}}],[\"年\",{\"0\":{\"76\":1},\"1\":{\"125\":1}}],[\"年的\",{\"1\":{\"75\":1,\"77\":1}}],[\"年仍然难以实现\",{\"0\":{\"74\":1},\"1\":{\"75\":1}}],[\"个连接帐户的限制\",{\"1\":{\"82\":1}}],[\"个最流行的\",{\"1\":{\"76\":1,\"77\":1}}],[\"个最受欢迎的\",{\"1\":{\"75\":1}}],[\"个\",{\"1\":{\"75\":1,\"78\":1,\"115\":1}}],[\"个不同的\",{\"1\":{\"75\":1,\"78\":1}}],[\"个人实际使用经验\",{\"1\":{\"71\":1}}],[\"个人\",{\"1\":{\"2\":1}}],[\"整合实现\",{\"1\":{\"138\":1}}],[\"整合\",{\"1\":{\"125\":1}}],[\"整体思路其实就是\",{\"1\":{\"104\":1}}],[\"整体的实现逻辑描述\",{\"1\":{\"34\":1}}],[\"整理\",{\"1\":{\"75\":1,\"89\":1}}],[\"文本缓冲区\",{\"1\":{\"136\":1}}],[\"文中对数据库分片与分布式数据库的主要区别做了说明\",{\"1\":{\"89\":1}}],[\"文档中找不到\",{\"1\":{\"79\":1}}],[\"文档的情况\",{\"1\":{\"79\":1}}],[\"文档错误\",{\"1\":{\"75\":1}}],[\"文档\",{\"1\":{\"75\":1}}],[\"文章也提到\",{\"1\":{\"89\":1}}],[\"文章\",{\"1\":{\"89\":1}}],[\"文章最后提到\",{\"1\":{\"75\":1}}],[\"文章中提到的问题包括\",{\"1\":{\"75\":1}}],[\"文章内容翔实\",{\"1\":{\"75\":1}}],[\"文件的常量池\",{\"1\":{\"67\":1}}],[\"文件的字节流信息是否符合当前\",{\"1\":{\"43\":1}}],[\"文件信息是如何被\",{\"1\":{\"57\":1}}],[\"文件编写后\",{\"1\":{\"50\":1}}],[\"文件格式中\",{\"1\":{\"45\":1}}],[\"文件格式的规范\",{\"1\":{\"43\":1}}],[\"文件格式验证\",{\"1\":{\"43\":1}}],[\"文件进行加载\",{\"1\":{\"41\":1}}],[\"文件中的二进制数据读入到内存中\",{\"1\":{\"39\":1}}],[\"由服务器断开连接\",{\"1\":{\"134\":1}}],[\"由连接本身去做提交操作\",{\"1\":{\"120\":1}}],[\"由于事件类都需要继承applicationevent作为父类\",{\"1\":{\"119\":1}}],[\"由于事务未提交\",{\"1\":{\"117\":1}}],[\"由于旧数据的查询\",{\"1\":{\"117\":1}}],[\"由于缓存被删除\",{\"1\":{\"117\":1}}],[\"由于缓存数据丢失\",{\"1\":{\"97\":1}}],[\"由于步骤\",{\"1\":{\"117\":1}}],[\"由于\",{\"1\":{\"99\":1,\"104\":1,\"135\":1}}],[\"由于大量的数据通过缓存获取\",{\"1\":{\"97\":1}}],[\"由于每个\",{\"1\":{\"75\":1,\"79\":1}}],[\"由于主流\",{\"1\":{\"64\":1}}],[\"由\",{\"1\":{\"75\":1,\"89\":1,\"103\":1}}],[\"由沉浸式翻译提供并优化了下排版\",{\"1\":{\"75\":1}}],[\"吾将上下而求索\",{\"1\":{\"71\":1}}],[\"总的来说\",{\"1\":{\"71\":1}}],[\"总结下步骤\",{\"1\":{\"30\":1}}],[\"总结\",{\"0\":{\"20\":1,\"50\":1,\"69\":1,\"121\":1}}],[\"更糟糕的是\",{\"1\":{\"117\":1}}],[\"更新和新增\",{\"1\":{\"112\":1,\"113\":1}}],[\"更新时\",{\"1\":{\"104\":1}}],[\"更新数据为例\",{\"1\":{\"104\":1}}],[\"更新迭代等\",{\"1\":{\"71\":1}}],[\"更喜欢将其编码为\",{\"1\":{\"79\":1}}],[\"更专注地学习各项技术\",{\"1\":{\"0\":1}}],[\"尤其是技术类\",{\"1\":{\"71\":1}}],[\"博客文章\",{\"1\":{\"82\":1}}],[\"博客的编写\",{\"1\":{\"71\":1}}],[\"博客刚切换\",{\"1\":{\"0\":1}}],[\"知识为开头\",{\"1\":{\"71\":1}}],[\"知道这个即可\",{\"1\":{\"3\":1}}],[\"之后\",{\"1\":{\"125\":1}}],[\"之后调用事务接口\",{\"1\":{\"112\":1,\"113\":1}}],[\"之所以改名\",{\"1\":{\"125\":1}}],[\"之所以事务提交还会参与原始事务\",{\"1\":{\"120\":1}}],[\"之所以以\",{\"1\":{\"71\":1}}],[\"之间的区别\",{\"1\":{\"89\":1}}],[\"之外\",{\"1\":{\"80\":1}}],[\"之前原本是直接\",{\"1\":{\"32\":1}}],[\"之前\",{\"1\":{\"29\":1}}],[\"之前只是用链表解决冲突问题\",{\"1\":{\"26\":1}}],[\"之前的\",{\"1\":{\"25\":1}}],[\"花絮\",{\"0\":{\"71\":1}}],[\"爱飞翔\",{\"1\":{\"70\":1}}],[\"译者\",{\"1\":{\"70\":1}}],[\"yugabytedb\",{\"1\":{\"89\":1,\"92\":2}}],[\"yet\",{\"0\":{\"84\":1}}],[\"yes\",{\"1\":{\"79\":2,\"81\":1,\"82\":1}}],[\"yellin\",{\"1\":{\"70\":1}}],[\"your\",{\"1\":{\"78\":2,\"79\":5,\"80\":2,\"82\":4,\"84\":4,\"85\":2}}],[\"you\",{\"1\":{\"76\":5,\"78\":12,\"79\":14,\"80\":14,\"81\":9,\"82\":10,\"83\":8,\"84\":4,\"85\":4,\"91\":1,\"92\":1}}],[\"yml中配置如下信息\",{\"1\":{\"3\":1}}],[\"意在让大伙了解\",{\"1\":{\"69\":1}}],[\"意在让读者明白\",{\"1\":{\"50\":1}}],[\"xero\",{\"1\":{\"82\":4}}],[\"x\",{\"1\":{\"79\":2,\"96\":2,\"105\":1}}],[\"xss\",{\"1\":{\"68\":1}}],[\"xx\",{\"1\":{\"68\":6}}],[\"xml添加如下依赖\",{\"1\":{\"127\":1}}],[\"xmx\",{\"1\":{\"68\":1}}],[\"xms\",{\"1\":{\"68\":1}}],[\"xbootclasspath\",{\"1\":{\"47\":1}}],[\"栈内存的大小设置\",{\"1\":{\"68\":1}}],[\"栈帧随着方法调用而创建\",{\"1\":{\"61\":1}}],[\"栈帧是用来存储数据和部分过程结果的数据结构\",{\"1\":{\"61\":1}}],[\"栈帧\",{\"0\":{\"61\":1}}],[\"包括异常回滚\",{\"1\":{\"110\":2}}],[\"包括协调器\",{\"1\":{\"91\":1}}],[\"包括以下三类\",{\"1\":{\"67\":1}}],[\"包含文本字符串\",{\"1\":{\"67\":1}}],[\"包含运行时常量池\",{\"1\":{\"58\":1}}],[\"声明为\",{\"1\":{\"67\":1}}],[\"声明类变量时指定值\",{\"1\":{\"46\":1}}],[\"增多导致类膨胀\",{\"1\":{\"66\":1}}],[\"增加了前端计算量\",{\"1\":{\"3\":1}}],[\"老年代\",{\"1\":{\"64\":1}}],[\"区开辟了一小块内存区域\",{\"1\":{\"64\":1}}],[\"区\",{\"1\":{\"64\":3}}],[\"区别只在于\",{\"1\":{\"63\":1}}],[\"新的连接\",{\"1\":{\"128\":1}}],[\"新的安全最佳实践\",{\"1\":{\"75\":1}}],[\"新增数据\",{\"1\":{\"117\":1}}],[\"新增树节点\",{\"1\":{\"30\":1}}],[\"新生代\",{\"1\":{\"64\":1}}],[\"角度来看\",{\"1\":{\"64\":1}}],[\"采用\",{\"1\":{\"97\":1}}],[\"采用了一种激进的方法\",{\"1\":{\"79\":1}}],[\"采用分代收集算法\",{\"1\":{\"64\":1}}],[\"采用两个头节点和两个尾节点保存元素构成链表\",{\"1\":{\"33\":1}}],[\"垃圾收集\",{\"1\":{\"64\":1}}],[\"垃圾回收\",{\"1\":{\"57\":1}}],[\"共享\",{\"0\":{\"64\":1,\"66\":1}}],[\"服务器下的\",{\"1\":{\"136\":1}}],[\"服务器便会创建一个新的端点实例\",{\"1\":{\"129\":1}}],[\"服务器端点的创建有两种方式\",{\"1\":{\"128\":1}}],[\"服务器配置而言不算有压力\",{\"1\":{\"97\":1}}],[\"服务端发送通知给\",{\"1\":{\"117\":1}}],[\"服务端开启事务\",{\"1\":{\"117\":1}}],[\"服务负载不高\",{\"1\":{\"97\":1}}],[\"服务\",{\"1\":{\"63\":2}}],[\"抛出了在方法内未被捕获的异常\",{\"1\":{\"61\":1}}],[\"随着攻击的被发现以及可用的\",{\"1\":{\"83\":1}}],[\"随着攻击手段的发现和网络技术的发展\",{\"1\":{\"75\":1}}],[\"随着方法结束而销毁\",{\"1\":{\"61\":1}}],[\"随时增删查改\",{\"1\":{\"2\":1}}],[\"额外附加信息\",{\"1\":{\"61\":1}}],[\"动则几十\",{\"1\":{\"97\":1}}],[\"动态加载注入\",{\"1\":{\"103\":1}}],[\"动态配置\",{\"0\":{\"102\":1},\"1\":{\"103\":1}}],[\"动态扩展到无法申请足够内存时抛出\",{\"1\":{\"62\":1}}],[\"动态链接\",{\"1\":{\"61\":1}}],[\"动作能正确执行\",{\"1\":{\"43\":1}}],[\"局部变量表\",{\"1\":{\"61\":1}}],[\"◡\",{\"1\":{\"60\":1}}],[\"●\",{\"1\":{\"60\":2}}],[\"●ˇ∀ˇ●\",{\"1\":{\"0\":1,\"34\":1}}],[\"调试分布式系统总是很困难\",{\"1\":{\"81\":1}}],[\"调试\",{\"0\":{\"81\":1},\"1\":{\"75\":1}}],[\"调试时点击\",{\"1\":{\"60\":1}}],[\"调用类的静态方法反射\",{\"1\":{\"46\":1}}],[\"调用treenode\",{\"1\":{\"33\":1}}],[\"调用父类\",{\"1\":{\"29\":1}}],[\"调用父类的构造方法\",{\"1\":{\"29\":1}}],[\"调用get\",{\"1\":{\"20\":1}}],[\"调用相应转化器器进行转化\",{\"1\":{\"3\":1}}],[\"调用\",{\"1\":{\"2\":1}}],[\"跳转\",{\"1\":{\"59\":1}}],[\"互不影响\",{\"1\":{\"59\":1}}],[\"私有\",{\"0\":{\"59\":1,\"60\":1,\"63\":1}}],[\"橙色私有\",{\"1\":{\"58\":1}}],[\"绿色共享\",{\"1\":{\"58\":1}}],[\"销毁\",{\"1\":{\"58\":2}}],[\"依赖\",{\"1\":{\"135\":1}}],[\"依赖用户线程的启动\",{\"1\":{\"58\":1}}],[\"依旧是从put\",{\"1\":{\"30\":1}}],[\"依旧实现map\",{\"1\":{\"29\":1}}],[\"去管理\",{\"1\":{\"58\":1}}],[\"去获取\",{\"1\":{\"31\":1}}],[\"管理而已\",{\"1\":{\"135\":1}}],[\"管理数据分发并无缝处理客户端请求\",{\"1\":{\"92\":1}}],[\"管理数据分布\",{\"1\":{\"89\":1}}],[\"管理的最大的一块内存\",{\"1\":{\"64\":1}}],[\"管理\",{\"1\":{\"57\":1}}],[\"平常编写的\",{\"1\":{\"57\":1}}],[\"平常或多或少会有这样的疑问\",{\"1\":{\"57\":1}}],[\"分布式自治数据库和\",{\"1\":{\"91\":1}}],[\"分布式数据库建立在无共享架构之上\",{\"1\":{\"92\":1}}],[\"分布式数据库不依赖于协调器组件\",{\"1\":{\"92\":1}}],[\"分布式数据库也采用类似的分片技术来跨数据库节点集群分布数据和加载\",{\"1\":{\"92\":1}}],[\"分布式数据库则没有中央协调器\",{\"1\":{\"89\":1}}],[\"分布式数据库在扩展时会自动重新平衡和拆分分片\",{\"1\":{\"89\":1}}],[\"分布式数据库采用分片技术在数据库节点集群中分布数据和负载\",{\"1\":{\"89\":1}}],[\"分布式数据库\",{\"0\":{\"92\":1},\"1\":{\"89\":1}}],[\"分布\",{\"1\":{\"90\":1}}],[\"分片和分布经常被混为一谈\",{\"1\":{\"92\":1}}],[\"分片集群\",{\"1\":{\"91\":1}}],[\"分片存储在专为单服务器部署而设计的数据库实例上\",{\"1\":{\"91\":1}}],[\"分片解决方案中协调器的存在\",{\"1\":{\"92\":1}}],[\"分片解决方案\",{\"0\":{\"91\":1}}],[\"分片解决方案的关键组件是协调器\",{\"1\":{\"89\":1}}],[\"分片是一种在多个独立数据库实例之间分配数据和负载的技术\",{\"1\":{\"90\":1}}],[\"分片是一种技术\",{\"1\":{\"89\":1}}],[\"分片涉及将数据拆分到多个独立实例\",{\"1\":{\"89\":1}}],[\"分片与分布式的区别\",{\"1\":{\"89\":1}}],[\"分片数据库也不是分布式数据库\",{\"1\":{\"90\":1}}],[\"分片数据库也是分布式系统\",{\"1\":{\"89\":1}}],[\"分片数据库实例不相互通信\",{\"1\":{\"89\":1}}],[\"分片\",{\"1\":{\"89\":1}}],[\"分片的概念并不陌生\",{\"1\":{\"89\":1}}],[\"分片并不意味着分布式\",{\"0\":{\"88\":1,\"90\":1},\"1\":{\"89\":1}}],[\"分钟才明白发生了什么事\",{\"1\":{\"79\":1}}],[\"分钟内为任何\",{\"1\":{\"76\":1}}],[\"分代收集扩展至方法区\",{\"1\":{\"66\":1}}],[\"分配缓冲区\",{\"1\":{\"64\":1}}],[\"分别是\",{\"1\":{\"63\":1,\"136\":1}}],[\"分别为以下三个部分\",{\"1\":{\"42\":1}}],[\"分为\",{\"1\":{\"58\":1,\"101\":1}}],[\"分析\",{\"1\":{\"57\":1}}],[\"算法\",{\"1\":{\"57\":1}}],[\"算法确定key\",{\"1\":{\"9\":1}}],[\"guest\",{\"1\":{\"103\":2}}],[\"guava\",{\"1\":{\"99\":2}}],[\"guide\",{\"1\":{\"83\":1}}],[\"g\",{\"1\":{\"97\":1}}],[\"gitee\",{\"1\":{\"96\":1}}],[\"give\",{\"1\":{\"85\":1}}],[\"gdpr\",{\"1\":{\"84\":2}}],[\"groupid>\",{\"1\":{\"127\":1}}],[\"group\",{\"1\":{\"83\":1}}],[\"granted\",{\"1\":{\"84\":1}}],[\"grant\",{\"1\":{\"78\":2,\"84\":1}}],[\"gain\",{\"1\":{\"82\":1}}],[\"gaps\",{\"1\":{\"80\":1}}],[\"garbage\",{\"1\":{\"64\":1}}],[\"good\",{\"1\":{\"80\":2,\"81\":1,\"82\":1}}],[\"google\",{\"1\":{\"77\":2,\"79\":1,\"82\":2,\"89\":1,\"92\":2}}],[\"goes\",{\"1\":{\"79\":1,\"91\":1}}],[\"go\",{\"1\":{\"79\":2,\"91\":1}}],[\"going\",{\"1\":{\"79\":1,\"81\":1}}],[\"gmail\",{\"1\":{\"77\":2}}],[\"gc\",{\"1\":{\"57\":2,\"64\":4,\"66\":4}}],[\"genuine\",{\"1\":{\"92\":1}}],[\"generic\",{\"1\":{\"81\":2,\"101\":2}}],[\"generated\",{\"1\":{\"82\":1}}],[\"generation\",{\"1\":{\"66\":1}}],[\"general\",{\"1\":{\"77\":1}}],[\"gendername\",{\"1\":{\"3\":1}}],[\"gender\",{\"1\":{\"3\":5}}],[\"genderenum\",{\"1\":{\"3\":4}}],[\"gen\",{\"1\":{\"3\":5}}],[\"getbean\",{\"1\":{\"135\":1}}],[\"getbasicremote\",{\"1\":{\"128\":1}}],[\"getmessage\",{\"1\":{\"128\":2}}],[\"getmapping\",{\"1\":{\"103\":3,\"112\":1,\"113\":1}}],[\"getwspath\",{\"1\":{\"128\":1}}],[\"getuserproperties\",{\"1\":{\"128\":1}}],[\"getrequestparametermap\",{\"1\":{\"128\":1}}],[\"getasyncremote\",{\"1\":{\"128\":1}}],[\"getautocommit\",{\"1\":{\"120\":1}}],[\"getid\",{\"1\":{\"128\":5}}],[\"getintvalue\",{\"1\":{\"3\":1}}],[\"getlogger\",{\"1\":{\"128\":1}}],[\"getl2provider\",{\"1\":{\"103\":1}}],[\"getpreviousisolationlevel\",{\"1\":{\"120\":1}}],[\"getparsingcontext\",{\"1\":{\"3\":1}}],[\"gets\",{\"1\":{\"79\":2}}],[\"getnode\",{\"1\":{\"31\":2}}],[\"getnullableresult\",{\"1\":{\"3\":6}}],[\"getvalue\",{\"1\":{\"15\":1}}],[\"getentry\",{\"1\":{\"15\":2}}],[\"getenumconstants\",{\"1\":{\"3\":1}}],[\"getfornullkey\",{\"1\":{\"15\":1}}],[\"get\",{\"0\":{\"15\":1,\"31\":1},\"1\":{\"3\":2,\"12\":1,\"15\":2,\"24\":1,\"31\":1,\"79\":4,\"80\":1,\"81\":1,\"82\":2,\"84\":1,\"103\":3,\"128\":1}}],[\"getgender\",{\"1\":{\"3\":2}}],[\"getting\",{\"1\":{\"79\":1,\"83\":1}}],[\"gettreenode\",{\"1\":{\"31\":2}}],[\"getter\",{\"1\":{\"3\":2}}],[\"gettype\",{\"1\":{\"3\":1}}],[\"getorder\",{\"1\":{\"110\":1}}],[\"getoutputcontext\",{\"1\":{\"3\":1}}],[\"getobject\",{\"1\":{\"3\":3}}],[\"getconnection\",{\"1\":{\"120\":3}}],[\"getconnectionholder\",{\"1\":{\"120\":5}}],[\"getchannel\",{\"1\":{\"101\":2,\"102\":2,\"103\":1}}],[\"getcurrentname\",{\"1\":{\"3\":2}}],[\"getcurrentvalue\",{\"1\":{\"3\":2}}],[\"getclass\",{\"1\":{\"3\":2}}],[\"学习\",{\"1\":{\"57\":1}}],[\"到期日期\",{\"1\":{\"80\":1}}],[\"到目前为止还好\",{\"1\":{\"80\":1}}],[\"到了解掌握\",{\"1\":{\"71\":1}}],[\"到处运行\",{\"1\":{\"57\":1}}],[\"到这里所有操作就已完成\",{\"1\":{\"3\":1}}],[\"到这里基本配置就已经完成\",{\"1\":{\"3\":1}}],[\"到这一步关于枚举类型数据的出参就搞定了\",{\"1\":{\"3\":1}}],[\"摘自维基百科\",{\"1\":{\"56\":1}}],[\"上方提到\",{\"1\":{\"136\":1}}],[\"上方说到事务同步注解方式若classes指定了多个值\",{\"1\":{\"118\":1}}],[\"上最大的城市\",{\"1\":{\"125\":1}}],[\"上的描述是\",{\"1\":{\"116\":1}}],[\"上的类库\",{\"1\":{\"47\":1}}],[\"上\",{\"1\":{\"64\":1}}],[\"上运行的字节码\",{\"1\":{\"56\":1}}],[\"使得其在即时通讯\",{\"1\":{\"125\":1}}],[\"使得\",{\"1\":{\"56\":1}}],[\"使用事务注解\",{\"1\":{\"113\":1}}],[\"使用注解标记方法\",{\"1\":{\"113\":1}}],[\"使用方式\",{\"0\":{\"111\":1}}],[\"使用场景\",{\"0\":{\"98\":1}}],[\"使用集中式缓存\",{\"1\":{\"97\":1}}],[\"使用内存缓存时\",{\"1\":{\"97\":2}}],[\"使用内存\",{\"1\":{\"96\":1}}],[\"使用刷新令牌刷新它并存储新的访问令牌和刷新令牌\",{\"1\":{\"83\":1}}],[\"使用realmid\",{\"1\":{\"80\":1}}],[\"使用哪一个\",{\"1\":{\"78\":1}}],[\"使用是非常频繁的\",{\"1\":{\"35\":1}}],[\"使用\",{\"1\":{\"0\":1,\"40\":1,\"96\":1,\"98\":1,\"101\":1,\"103\":1,\"125\":2,\"139\":1}}],[\"屏蔽了与具体操作系统平台相关的信息\",{\"1\":{\"56\":1}}],[\"语言层面的常量概念相近\",{\"1\":{\"67\":1}}],[\"语言开发的程序在不同平台上运行时不需要重新编译\",{\"1\":{\"56\":1}}],[\"语言规范的要求\",{\"1\":{\"43\":1}}],[\"寄存器等\",{\"1\":{\"56\":1}}],[\"堆中\",{\"1\":{\"66\":1}}],[\"堆保持一致\",{\"1\":{\"66\":1}}],[\"堆可分为\",{\"1\":{\"64\":1}}],[\"堆\",{\"0\":{\"64\":1},\"1\":{\"58\":1,\"64\":2}}],[\"堆内存大小如何设置等等\",{\"1\":{\"57\":1}}],[\"堆内存空间应当设置多大\",{\"1\":{\"57\":1}}],[\"堆栈设置\",{\"1\":{\"68\":1}}],[\"堆栈\",{\"1\":{\"56\":1}}],[\"堆区只是提供了一个入口去调用相应的对象数据\",{\"1\":{\"39\":1}}],[\"拥有自己完善的硬体架构\",{\"1\":{\"56\":1}}],[\"能够运行\",{\"1\":{\"56\":1}}],[\"能够理想地解决查询效率变低的问题\",{\"1\":{\"26\":1}}],[\"概念\",{\"0\":{\"56\":1},\"1\":{\"99\":1}}],[\"周志明等\",{\"1\":{\"70\":1}}],[\"周志明\",{\"1\":{\"51\":1,\"70\":1}}],[\"第二级缓存\",{\"1\":{\"96\":1}}],[\"第一个问题比较简单\",{\"1\":{\"119\":1}}],[\"第一级缓存\",{\"1\":{\"96\":1}}],[\"第一种做法比较有利于字典需要频繁变化的场景\",{\"1\":{\"2\":1}}],[\"第三方访问用例相关的内容\",{\"1\":{\"78\":1}}],[\"第2章\",{\"1\":{\"70\":1}}],[\"第7章\",{\"1\":{\"51\":1}}],[\"深入理解java虚拟机\",{\"1\":{\"51\":1,\"70\":1}}],[\"参数二last用于判断获取到的消息是否为数据的最后一部分\",{\"1\":{\"132\":1}}],[\"参数类型可以是string\",{\"1\":{\"132\":1}}],[\"参数是破坏流程的原因\",{\"1\":{\"81\":1}}],[\"参数\",{\"0\":{\"136\":1},\"1\":{\"78\":1,\"80\":1,\"81\":1}}],[\"参数控制\",{\"1\":{\"68\":1}}],[\"参数指定路径中的\",{\"1\":{\"47\":1}}],[\"参考资料\",{\"0\":{\"51\":1,\"70\":1,\"139\":1}}],[\"久而久之\",{\"1\":{\"50\":1}}],[\"很多\",{\"1\":{\"81\":1}}],[\"很多问题都是在某些情况下触发\",{\"1\":{\"50\":1}}],[\"很聪明\",{\"1\":{\"80\":1}}],[\"很清晰易懂\",{\"1\":{\"19\":1}}],[\"有对应的规范描述\",{\"1\":{\"137\":1}}],[\"有值\",{\"1\":{\"115\":1}}],[\"有四种\",{\"1\":{\"103\":1}}],[\"有多种\",{\"1\":{\"101\":1}}],[\"有效期\",{\"1\":{\"101\":1}}],[\"有更好的方法吗\",{\"0\":{\"85\":1}}],[\"有两种不同类型的范围\",{\"1\":{\"80\":1}}],[\"有一个模型\",{\"1\":{\"79\":1}}],[\"有些事情我们还没有讨论过\",{\"0\":{\"84\":1}}],[\"有些公司\",{\"1\":{\"83\":1}}],[\"有些则要求您提供演示登录\",{\"1\":{\"82\":1}}],[\"有些评论很温和\",{\"1\":{\"82\":1}}],[\"有些甚至要求您签订收入分成协议\",{\"1\":{\"82\":1}}],[\"有些流程也会因随机原因而中断\",{\"1\":{\"81\":1}}],[\"有些人希望您使用基本身份验证来验证此请求\",{\"1\":{\"79\":1}}],[\"有些\",{\"1\":{\"75\":1,\"83\":1}}],[\"有标准化的错误消息\",{\"1\":{\"75\":1}}],[\"有的虚拟机实现也将本地方法栈和虚拟机栈合并\",{\"1\":{\"63\":1}}],[\"有兴趣的读者也可了解下\",{\"1\":{\"49\":1}}],[\"有可能会破坏原本的双亲委派模型哦\",{\"1\":{\"49\":1}}],[\"有助于我们在使用时\",{\"1\":{\"35\":1}}],[\"继承\",{\"1\":{\"49\":1}}],[\"继承于\",{\"1\":{\"18\":2}}],[\"程序运行所产生的数据\",{\"1\":{\"69\":1}}],[\"程序中很多对象都是小对象且用过即丢\",{\"1\":{\"64\":1}}],[\"程序计数器是一块较小的内存空间\",{\"1\":{\"59\":1}}],[\"程序计数器\",{\"0\":{\"59\":1},\"1\":{\"58\":1}}],[\"程序的开发\",{\"1\":{\"58\":1}}],[\"程序的修改才会生效\",{\"1\":{\"48\":1}}],[\"程序只需生成在\",{\"1\":{\"56\":1}}],[\"程序直接引用等问题\",{\"1\":{\"50\":1}}],[\"程序员小灰\",{\"1\":{\"34\":1}}],[\"必须重启\",{\"1\":{\"48\":1}}],[\"都可看到描述信息\",{\"1\":{\"104\":1}}],[\"都要求这样做\",{\"1\":{\"81\":1}}],[\"都有文档\",{\"1\":{\"81\":1}}],[\"都有细微的差别\",{\"0\":{\"79\":1}}],[\"都实现\",{\"1\":{\"79\":1}}],[\"都与使用\",{\"1\":{\"78\":1}}],[\"都算作方法结束\",{\"1\":{\"61\":1}}],[\"都是通过\",{\"1\":{\"101\":1}}],[\"都是自由的\",{\"1\":{\"82\":1}}],[\"都是要读者们在实际应用中去注意\",{\"1\":{\"50\":1}}],[\"都是放在链表头节点\",{\"1\":{\"25\":1}}],[\"都会被缓存\",{\"1\":{\"48\":1}}],[\"先查询缓存\",{\"1\":{\"117\":1}}],[\"先看看注解的源码\",{\"1\":{\"113\":1}}],[\"先从代码仓库\",{\"1\":{\"101\":1}}],[\"先让父类加载器试图加载该类\",{\"1\":{\"48\":1}}],[\"先对\",{\"1\":{\"32\":1}}],[\"父类委托\",{\"1\":{\"48\":1}}],[\"父类构造器已经执行完毕\",{\"1\":{\"46\":1}}],[\"除了\",{\"1\":{\"56\":1,\"80\":1}}],[\"除了个别纯后台管理系统才采用了第一种方案\",{\"1\":{\"2\":1}}],[\"除非显示使用另外一个类加载器来载入\",{\"1\":{\"48\":1}}],[\"所有\",{\"1\":{\"125\":1}}],[\"所有数据落库\",{\"1\":{\"117\":1}}],[\"所有数据的读取先从一级缓存中读取\",{\"1\":{\"97\":1}}],[\"所有这些对客户端来说都是透明的\",{\"1\":{\"92\":1}}],[\"所依赖的和引用的其他\",{\"1\":{\"48\":1}}],[\"所以该方式不会带来性能损耗\",{\"1\":{\"135\":1}}],[\"所以该处理器只针对枚举类型字段\",{\"1\":{\"3\":1}}],[\"所以可通过applicationcontextaware接口得到applicationcontext来获取\",{\"1\":{\"135\":1}}],[\"所以尽量不要在事务回调中执行耗时较久的操作\",{\"1\":{\"120\":1}}],[\"所以肯定只会查到旧的\",{\"1\":{\"117\":1}}],[\"所以只需要清除一级缓存即可\",{\"1\":{\"103\":1}}],[\"所以一般内存缓存框架会把一组相同\",{\"1\":{\"99\":1}}],[\"所以容易随着加载的\",{\"1\":{\"66\":1}}],[\"所以小对象通常会被\",{\"1\":{\"64\":1}}],[\"所以也不会触发初始化\",{\"1\":{\"46\":1}}],[\"所以到这里\",{\"1\":{\"39\":1}}],[\"所以直接同\",{\"1\":{\"33\":1}}],[\"所以\",{\"1\":{\"33\":1,\"129\":1}}],[\"所以重新设置阈值后直接返回\",{\"1\":{\"16\":1}}],[\"所以停更\",{\"1\":{\"0\":1}}],[\"全盘负责\",{\"1\":{\"48\":1}}],[\"会利用readbuffer读取数据\",{\"1\":{\"136\":1}}],[\"会用到三个buffer\",{\"1\":{\"136\":1}}],[\"会扫描带有\",{\"1\":{\"133\":1}}],[\"会阻塞至消息发送成功\",{\"1\":{\"128\":1}}],[\"会等到方法执行完清理事务资源后\",{\"1\":{\"116\":1}}],[\"会解析\",{\"1\":{\"104\":1}}],[\"会调用\",{\"1\":{\"104\":1}}],[\"会将其分割为多份传递\",{\"1\":{\"132\":1}}],[\"会将一二级缓存该数据都删掉\",{\"1\":{\"103\":1}}],[\"会将记录转发给分片的所有者\",{\"1\":{\"92\":1}}],[\"会导致\",{\"1\":{\"101\":1}}],[\"会因为取不到连接而抛出\",{\"1\":{\"101\":1}}],[\"会在其\",{\"1\":{\"99\":1}}],[\"会以绝对值形式告诉您访问令牌过期时间\",{\"1\":{\"83\":1}}],[\"会先交给其父类加载器去完成\",{\"1\":{\"48\":1}}],[\"会保证子构造器方法执行前\",{\"1\":{\"46\":1}}],[\"扩展\",{\"1\":{\"75\":1}}],[\"扩展自己的思维\",{\"1\":{\"69\":1}}],[\"扩展类加载器\",{\"1\":{\"47\":1}}],[\"扩容方法实现逻辑重点在于复制数据的\",{\"1\":{\"33\":1}}],[\"扩容计算\",{\"1\":{\"33\":1}}],[\"扩容复制原理后\",{\"1\":{\"16\":1}}],[\"扩容的关键方法\",{\"1\":{\"16\":1}}],[\"扩容\",{\"1\":{\"13\":1}}],[\"扩容时使用\",{\"1\":{\"11\":1}}],[\"按\",{\"1\":{\"115\":1}}],[\"按文件名识别\",{\"1\":{\"47\":1}}],[\"按位与计算出下标\",{\"1\":{\"14\":1}}],[\"且被\",{\"1\":{\"47\":1}}],[\"目前缓存的解决方案一般有两种\",{\"1\":{\"97\":1}}],[\"目前只有少数\",{\"1\":{\"83\":1}}],[\"目前所接触过的实际项目也基本都是前后端自己维护\",{\"1\":{\"2\":1}}],[\"目录中的\",{\"1\":{\"47\":2}}],[\"启动类加载器无法被\",{\"1\":{\"50\":1}}],[\"启动类加载器\",{\"1\":{\"47\":1}}],[\"自身提供的\",{\"1\":{\"138\":1}}],[\"自动根据消息内容大小从而确定是否分割数据传递\",{\"1\":{\"136\":1}}],[\"自己控制提交的时机\",{\"1\":{\"120\":1}}],[\"自己去查看源码学习\",{\"1\":{\"20\":1}}],[\"自定义操作等\",{\"1\":{\"109\":1}}],[\"自定义实现\",{\"1\":{\"104\":1}}],[\"自定义类加载器\",{\"0\":{\"49\":1}}],[\"自然就不会有连接\",{\"1\":{\"101\":1}}],[\"自带的虚拟机实现\",{\"1\":{\"66\":1}}],[\"自行完成\",{\"1\":{\"47\":1}}],[\"始化\",{\"1\":{\"46\":1}}],[\"命令调优\",{\"1\":{\"57\":1}}],[\"命令来运行某个主类\",{\"1\":{\"46\":1}}],[\"命中则直接返回\",{\"1\":{\"31\":1}}],[\"或reader\",{\"1\":{\"132\":1}}],[\"或者由服务端开启定时任务主动发送ping消息给客户端也是可以的\",{\"1\":{\"137\":1}}],[\"或者用户根据\",{\"1\":{\"84\":1}}],[\"或者用户已撤销访问权限\",{\"1\":{\"83\":1}}],[\"或者当你第一次看到它们时你错过了一些东西\",{\"1\":{\"81\":1}}],[\"或者尚未更新最新的更改\",{\"1\":{\"81\":1}}],[\"或者遗漏了一个细节\",{\"1\":{\"81\":1}}],[\"或者至少它比强迫用户随后执行奇怪的额外\",{\"1\":{\"80\":1}}],[\"或者至少一个小时内\",{\"1\":{\"76\":1}}],[\"或者对该静态变量赋值\",{\"1\":{\"46\":1}}],[\"或\",{\"1\":{\"68\":1,\"78\":1,\"79\":1,\"89\":2,\"91\":1,\"92\":1,\"115\":1}}],[\"或通过\",{\"1\":{\"47\":2}}],[\"或翻转\",{\"1\":{\"25\":1}}],[\"触发方式大概有以下几种\",{\"1\":{\"46\":1}}],[\"假如类中有初始化语句\",{\"1\":{\"46\":1}}],[\"假如该类的直接父类还没有被初始化\",{\"1\":{\"46\":1}}],[\"假如这个类还没有被加载和连接\",{\"1\":{\"46\":1}}],[\"假设客户端此时发送了一条数据\",{\"1\":{\"136\":1}}],[\"假设\",{\"1\":{\"117\":1,\"135\":1}}],[\"假设数组长度原本是\",{\"1\":{\"33\":1}}],[\"假设长度为\",{\"1\":{\"32\":1}}],[\"假设有两个线程\",{\"1\":{\"25\":1}}],[\"负责加载用户路径\",{\"1\":{\"47\":1}}],[\"负责加载\",{\"1\":{\"47\":2}}],[\"负责对类进行初始化\",{\"1\":{\"46\":1}}],[\"负载因子\",{\"1\":{\"11\":2}}],[\"相比\",{\"1\":{\"105\":1}}],[\"相比没区别\",{\"1\":{\"101\":1}}],[\"相反\",{\"1\":{\"80\":1}}],[\"相媲美\",{\"1\":{\"77\":1}}],[\"相对偏移量或一个间接定位到目标的句柄\",{\"1\":{\"45\":1}}],[\"相同\",{\"1\":{\"101\":1}}],[\"相同赋值给\",{\"1\":{\"30\":1}}],[\"相同则覆盖并返回旧值\",{\"1\":{\"14\":1}}],[\"各种方案在\",{\"1\":{\"104\":1}}],[\"各种虚拟机实现的内存布局可以各不相同\",{\"1\":{\"45\":1}}],[\"各自存储\",{\"1\":{\"2\":1}}],[\"引入\",{\"1\":{\"56\":1}}],[\"引用的目标并不一定要已经加载到内存中\",{\"1\":{\"45\":1}}],[\"引出了在\",{\"1\":{\"24\":1}}],[\"字节缓冲区\",{\"1\":{\"136\":1}}],[\"字节码的虚拟机\",{\"1\":{\"56\":1}}],[\"字节码验证\",{\"1\":{\"43\":1}}],[\"字面量\",{\"1\":{\"67\":1}}],[\"字符串池和静态变量等则放入到\",{\"1\":{\"66\":1}}],[\"字段的名称和描述符\",{\"1\":{\"67\":1}}],[\"字段\",{\"1\":{\"45\":1}}],[\"主要知道\",{\"1\":{\"101\":1}}],[\"主要包含了\",{\"1\":{\"101\":1}}],[\"主要解决的问题如下\",{\"1\":{\"97\":1}}],[\"主要讨论了数据库分片\",{\"1\":{\"89\":1}}],[\"主要针对的是常量池的回收和类型的卸载\",{\"1\":{\"66\":1}}],[\"主要针对类或接口\",{\"1\":{\"45\":1}}],[\"主要对类变量进行初始化\",{\"1\":{\"46\":1}}],[\"主要是查找并加载类的二进制数据\",{\"1\":{\"41\":1}}],[\"主要是在新增\",{\"1\":{\"35\":1}}],[\"主要是因为红黑树结构\",{\"1\":{\"34\":1}}],[\"生成\",{\"1\":{\"44\":1}}],[\"阶段\",{\"1\":{\"44\":1}}],[\"实例\",{\"1\":{\"133\":1}}],[\"实习生著名的遗言\",{\"1\":{\"78\":1}}],[\"实践\",{\"0\":{\"77\":1}}],[\"实际只需在端点类上加\",{\"1\":{\"133\":1}}],[\"实际场景\",{\"0\":{\"117\":1}}],[\"实际上都有自己对标准的解释\",{\"1\":{\"75\":1}}],[\"实际应用中也是在此处根据消息来执行业务逻辑\",{\"1\":{\"134\":1}}],[\"实际应用中的体验类似于\",{\"1\":{\"75\":1}}],[\"实际应用困难等方面的问题\",{\"1\":{\"75\":1}}],[\"实际值的初始化会在\",{\"1\":{\"44\":1}}],[\"实现步骤\",{\"1\":{\"113\":1}}],[\"实现思路如下\",{\"1\":{\"104\":1}}],[\"实现原理\",{\"0\":{\"104\":1}}],[\"实现背景\",{\"0\":{\"97\":1}}],[\"实现更多非标准行为\",{\"1\":{\"80\":1}}],[\"实现怪癖以及非标准行为和扩展都有自己的解释\",{\"1\":{\"77\":1}}],[\"实现了\",{\"1\":{\"76\":1,\"77\":1}}],[\"实现了出入参的改变\",{\"1\":{\"3\":1}}],[\"实现特定的逻辑\",{\"1\":{\"75\":1}}],[\"实现的皮毛\",{\"1\":{\"84\":1}}],[\"实现的\",{\"1\":{\"75\":1}}],[\"实现都有细微差异\",{\"1\":{\"75\":1}}],[\"实现上的怪癖\",{\"1\":{\"75\":1}}],[\"实现对于\",{\"1\":{\"64\":1}}],[\"实现类\",{\"1\":{\"9\":1}}],[\"实现类有\",{\"1\":{\"8\":1}}],[\"实现\",{\"1\":{\"3\":1,\"57\":1,\"75\":1,\"76\":1,\"78\":1,\"101\":1}}],[\"实现枚举出入参转换\",{\"0\":{\"3\":1}}],[\"解绑资源\",{\"1\":{\"120\":1}}],[\"解释\",{\"1\":{\"105\":1}}],[\"解释器就知道下一步要执行的字节码指令位置\",{\"1\":{\"59\":1}}],[\"解析\",{\"0\":{\"45\":1},\"1\":{\"43\":1}}],[\"解决问题\",{\"1\":{\"35\":1}}],[\"符号引用\",{\"1\":{\"45\":1,\"67\":1}}],[\"符号引用类型常见如下\",{\"1\":{\"45\":1}}],[\"符号引用验证\",{\"1\":{\"43\":1}}],[\"符合逻辑的\",{\"1\":{\"43\":1}}],[\"确保\",{\"1\":{\"43\":1}}],[\"确保被加载的类的正确性\",{\"0\":{\"43\":1}}],[\"确定程序语义是合法的\",{\"1\":{\"43\":1}}],[\"元空间并不在虚拟机中\",{\"1\":{\"66\":1}}],[\"元空间\",{\"1\":{\"66\":1}}],[\"元数据验证\",{\"1\":{\"43\":1}}],[\"元素存放在新数组要么是原位置\",{\"1\":{\"33\":1}}],[\"元素数量\",{\"1\":{\"14\":1}}],[\"大小默认8\",{\"1\":{\"136\":2}}],[\"大小为原来的2倍\",{\"1\":{\"16\":1,\"20\":1}}],[\"大多是直接使用\",{\"1\":{\"109\":1}}],[\"大多数审核流程都是合理的\",{\"1\":{\"82\":1}}],[\"大多数人确实希望它在正文中\",{\"1\":{\"79\":1}}],[\"大多数构建公共\",{\"1\":{\"78\":1}}],[\"大多数\",{\"1\":{\"78\":1}}],[\"大致会进行以下四个部分的验证\",{\"1\":{\"43\":1}}],[\"规范\",{\"1\":{\"128\":1,\"139\":1}}],[\"规范提供的\",{\"1\":{\"125\":1}}],[\"规范规定该区域可抛出异常\",{\"1\":{\"65\":1}}],[\"规范规定该区域有两种异常\",{\"1\":{\"62\":1}}],[\"规范要求\",{\"1\":{\"43\":1}}],[\"规范允许类加载器在预料某个类将要被使用时就预先加载它\",{\"1\":{\"39\":1}}],[\"验证字节流是否符合\",{\"1\":{\"43\":1}}],[\"验证\",{\"0\":{\"43\":1},\"1\":{\"50\":1}}],[\"👈下面有做简单介绍\",{\"1\":{\"41\":1}}],[\"卸载\",{\"1\":{\"40\":1}}],[\"初始化一个\",{\"1\":{\"104\":1}}],[\"初始化时会通过名称去获取两级缓存的\",{\"1\":{\"101\":1}}],[\"初始化某个类的子类\",{\"1\":{\"46\":1}}],[\"初始化的步骤如下\",{\"1\":{\"46\":1}}],[\"初始化\",{\"0\":{\"46\":1},\"1\":{\"40\":1,\"44\":1,\"47\":1}}],[\"连接关闭后\",{\"1\":{\"134\":1}}],[\"连接接入后\",{\"1\":{\"134\":1}}],[\"连接打开\",{\"1\":{\"134\":2}}],[\"连接测试\",{\"0\":{\"134\":1}}],[\"连接路由\",{\"1\":{\"128\":1}}],[\"连接路径\",{\"1\":{\"128\":1}}],[\"连接异常\",{\"1\":{\"128\":1,\"134\":1}}],[\"连接断开\",{\"1\":{\"128\":1,\"134\":1}}],[\"连接断开等时间\",{\"1\":{\"128\":1}}],[\"连接在客户端和服务器之间建立全双工\",{\"1\":{\"125\":1}}],[\"连接无意义占用而引发连接池溢出\",{\"1\":{\"120\":1}}],[\"连接直到事务回调执行完成后清理资源才释放\",{\"1\":{\"120\":1}}],[\"连接获取后autocommit的修改源码如下\",{\"1\":{\"120\":1}}],[\"连接方式\",{\"1\":{\"101\":1}}],[\"连接细化分下来\",{\"1\":{\"42\":1}}],[\"连接\",{\"0\":{\"42\":1},\"1\":{\"40\":1,\"50\":1,\"134\":1}}],[\"加入集群\",{\"1\":{\"104\":1}}],[\"加上本人也想通过搭建一个博客网站\",{\"1\":{\"71\":1}}],[\"加上深感自己对技术的理解还不够深入\",{\"1\":{\"0\":1}}],[\"加载指定类时\",{\"1\":{\"46\":1}}],[\"加载是类加载过程的第一个阶段\",{\"1\":{\"41\":1}}],[\"加载\",{\"0\":{\"41\":1},\"1\":{\"40\":1,\"47\":1}}],[\"纯洁的微笑\",{\"1\":{\"39\":1}}],[\"此篇内容大量借鉴于参考资料\",{\"1\":{\"138\":1}}],[\"此时的分布式缓存可能数据量不大\",{\"1\":{\"97\":1}}],[\"此类分布式缓存就势必会带来问题\",{\"1\":{\"97\":1}}],[\"此类远端缓存的性能瓶颈主要在于网络\",{\"1\":{\"96\":1}}],[\"此外\",{\"1\":{\"92\":1}}],[\"此方法通过将原始数据集拆分为分片\",{\"1\":{\"90\":1}}],[\"此段引用于\",{\"1\":{\"39\":1}}],[\"此处使用异步发送\",{\"1\":{\"128\":1}}],[\"此处的\",{\"1\":{\"101\":1}}],[\"此处要注意\",{\"1\":{\"101\":1}}],[\"此处附上文章\",{\"1\":{\"34\":1}}],[\"此处不再赘述\",{\"1\":{\"3\":1}}],[\"错误\",{\"1\":{\"39\":1}}],[\"运行时\",{\"1\":{\"133\":1}}],[\"运行时常量池除了编译期产生的\",{\"1\":{\"67\":1}}],[\"运行时常量池\",{\"0\":{\"67\":1}}],[\"运行时数据区的方法区内\",{\"1\":{\"39\":1}}],[\"运算判断位置是否需要移动\",{\"1\":{\"33\":1}}],[\"运算效果相当于只跟高位\",{\"1\":{\"33\":1}}],[\"运算\",{\"1\":{\"33\":2}}],[\"运算为\",{\"1\":{\"33\":1}}],[\"运算的一直是哈希值的低\",{\"1\":{\"32\":1}}],[\"运算获取下标\",{\"1\":{\"32\":1}}],[\"我就想过\",{\"1\":{\"105\":1}}],[\"我无法告诉你文档出错的频率有多少\",{\"1\":{\"81\":1}}],[\"我应该将用户重定向到哪里进行授权\",{\"1\":{\"79\":1}}],[\"我应该在明天之前完成\",{\"1\":{\"78\":1}}],[\"我听到您说\",{\"1\":{\"78\":1}}],[\"我崇尚的是从不会\",{\"1\":{\"71\":1}}],[\"我将着重描述\",{\"1\":{\"38\":1}}],[\"我们知道像\",{\"1\":{\"96\":1}}],[\"我们很乐意在\",{\"1\":{\"85\":1}}],[\"我们很乐意听到您的反馈\",{\"1\":{\"85\":1}}],[\"我们很乐意请您享用一顿美味的晚餐\",{\"1\":{\"76\":1}}],[\"我们认为是存在的\",{\"1\":{\"85\":1}}],[\"我们仅仅触及了\",{\"1\":{\"84\":1}}],[\"我们必须考虑\",{\"1\":{\"83\":1}}],[\"我们听说访问需要几个月的时间\",{\"1\":{\"82\":1}}],[\"我们听说这些审核可能需要几天或几周的时间才能通过\",{\"1\":{\"82\":1}}],[\"我们花了一个小时才明白传入\",{\"1\":{\"81\":1}}],[\"我们实现的\",{\"1\":{\"81\":1}}],[\"我们实际上认为这是一个好主意\",{\"1\":{\"80\":1}}],[\"我们跳过了我们遇到的许多不真正标准的\",{\"1\":{\"80\":1}}],[\"我们看到的一个常见问题是\",{\"1\":{\"80\":1}}],[\"我们困惑地花了\",{\"1\":{\"79\":1}}],[\"我们倾向于同意您的观点\",{\"1\":{\"78\":1}}],[\"我们几周前就已经这样做了\",{\"1\":{\"78\":1}}],[\"我们的结论\",{\"1\":{\"77\":1}}],[\"我们为\",{\"1\":{\"76\":1,\"77\":1}}],[\"我们就可以知道\",{\"1\":{\"57\":1}}],[\"我们就以此作为切入点\",{\"1\":{\"24\":1}}],[\"我们也可以自定义类加载器\",{\"1\":{\"49\":1}}],[\"我们也能理解为什么\",{\"1\":{\"39\":1}}],[\"我们先简单了解下\",{\"1\":{\"47\":1}}],[\"我们可以继续说很长时间\",{\"1\":{\"79\":1}}],[\"我们可以使用默认的类加载器\",{\"1\":{\"41\":1}}],[\"我们可以简单看张图理解下\",{\"1\":{\"39\":1}}],[\"我们常见的\",{\"1\":{\"8\":1}}],[\"篇已经详细讲解了\",{\"1\":{\"38\":1}}],[\"篇中\",{\"1\":{\"24\":1}}],[\"内部发起通知都是因为二级缓存\",{\"1\":{\"103\":1}}],[\"内部对象\",{\"1\":{\"103\":1}}],[\"内部定义的几个主要属性如下\",{\"1\":{\"11\":1}}],[\"内存\",{\"1\":{\"105\":1}}],[\"内存与\",{\"1\":{\"105\":1}}],[\"内存缓存\",{\"1\":{\"97\":1}}],[\"内存结构及其概念\",{\"1\":{\"69\":1}}],[\"内存调优从哪里入手\",{\"1\":{\"57\":1}}],[\"内存模型结构图\",{\"1\":{\"58\":1}}],[\"内存模型主要是指运行时内存模型\",{\"1\":{\"58\":1}}],[\"内存模型后\",{\"1\":{\"57\":1}}],[\"内存模型的讲解\",{\"1\":{\"57\":1}}],[\"内存模型的结构\",{\"1\":{\"38\":1}}],[\"内存模型\",{\"0\":{\"54\":1,\"58\":1},\"1\":{\"38\":1,\"57\":1,\"58\":1,\"70\":1}}],[\"掌握原理\",{\"1\":{\"35\":1}}],[\"性能分析和调优方面的思维\",{\"1\":{\"69\":1}}],[\"性能提升影响是比较大的\",{\"1\":{\"35\":1}}],[\"性别枚举\",{\"1\":{\"3\":1}}],[\"结合上图梳理流程如下\",{\"1\":{\"117\":1}}],[\"结合上面对于\",{\"1\":{\"34\":1}}],[\"结果是\",{\"1\":{\"77\":1}}],[\"结束\",{\"1\":{\"58\":1}}],[\"结构是个什么样子\",{\"1\":{\"69\":1}}],[\"结构是数组+链表\",{\"1\":{\"10\":1}}],[\"结构变化\",{\"0\":{\"26\":1}}],[\"结构修改的次数\",{\"1\":{\"11\":1}}],[\"结构图\",{\"1\":{\"10\":1}}],[\"结构\",{\"0\":{\"10\":1,\"61\":1}}],[\"供感兴趣的读者学习下红黑树的相关知识\",{\"1\":{\"34\":1}}],[\"讲解起来会很啰嗦冗余\",{\"1\":{\"34\":1}}],[\"讲解了其原理\",{\"1\":{\"24\":1}}],[\"旧容量\",{\"1\":{\"33\":1}}],[\"旧数组数据复制到新数组\",{\"1\":{\"16\":1}}],[\"说明了\",{\"1\":{\"75\":1}}],[\"说明新位置是原索引\",{\"1\":{\"33\":1}}],[\"说明原索引位置存值\",{\"1\":{\"33\":1}}],[\"尾声\",{\"0\":{\"35\":1}}],[\"尾节点不为空\",{\"1\":{\"33\":1}}],[\"尾节点为空\",{\"1\":{\"33\":1}}],[\"尾插法\",{\"1\":{\"25\":1,\"30\":2}}],[\"处就体现了上面说的元素是否需要移动的判断\",{\"1\":{\"33\":1}}],[\"高位\",{\"1\":{\"33\":1}}],[\"高位多\",{\"1\":{\"33\":1}}],[\"来查询最新的\",{\"1\":{\"117\":1}}],[\"来判断当前方法是否处于活跃事务中\",{\"1\":{\"116\":1}}],[\"来存放不同的数据\",{\"1\":{\"99\":1}}],[\"来源于\",{\"1\":{\"99\":1}}],[\"来设置超时时间\",{\"1\":{\"99\":1}}],[\"来说\",{\"1\":{\"79\":1}}],[\"来总结自己一路学习的技术和知识\",{\"1\":{\"71\":1}}],[\"来实现广播\",{\"1\":{\"101\":1}}],[\"来实现\",{\"1\":{\"57\":1}}],[\"来看下resize\",{\"1\":{\"33\":1}}],[\"来看看\",{\"1\":{\"24\":1}}],[\"来确定是否需要移动即可\",{\"1\":{\"33\":1}}],[\"只会执行一次\",{\"1\":{\"135\":1}}],[\"只会触发父类的初始化\",{\"1\":{\"46\":1}}],[\"只要\",{\"1\":{\"49\":1}}],[\"只有一个值时\",{\"1\":{\"115\":1}}],[\"只有缓存区不存在\",{\"1\":{\"48\":1}}],[\"只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类\",{\"1\":{\"48\":1}}],[\"只有当父类加载器无法完成加载任务时\",{\"1\":{\"48\":1}}],[\"只需要在\",{\"1\":{\"33\":1}}],[\"只是维护了双向链表的应用\",{\"1\":{\"29\":1}}],[\"经过实际测试\",{\"1\":{\"115\":1,\"116\":1}}],[\"经过\",{\"1\":{\"33\":1}}],[\"经验也不够充足\",{\"1\":{\"0\":1}}],[\"红色\",{\"1\":{\"33\":1}}],[\"红黑树根节点\",{\"1\":{\"29\":1}}],[\"红黑树和链表就会频繁转换\",{\"1\":{\"27\":1}}],[\"红黑树和链表就互相转换\",{\"1\":{\"27\":1}}],[\"红黑树的平均查找时间为\",{\"1\":{\"27\":1}}],[\"红黑树又会转换为链表\",{\"1\":{\"27\":1}}],[\"<script\",{\"1\":{\"134\":1}}],[\"<body>\",{\"1\":{\"134\":1}}],[\"<title>websocket<\",{\"1\":{\"134\":1}}],[\"<meta\",{\"1\":{\"134\":1}}],[\"<head>\",{\"1\":{\"134\":1}}],[\"<html\",{\"1\":{\"134\":1}}],[\"<artifactid>spring\",{\"1\":{\"127\":1}}],[\"<groupid>org\",{\"1\":{\"127\":1}}],[\"<dependency>\",{\"1\":{\"127\":1}}],[\"<\",{\"1\":{\"33\":4,\"127\":1,\"134\":5}}],[\"<<\",{\"1\":{\"33\":3}}],[\"<e\",{\"1\":{\"3\":1}}],[\"搭配一张图来看就会很好理解\",{\"1\":{\"33\":1}}],[\"倍\",{\"1\":{\"33\":3}}],[\"倍的新数组\",{\"1\":{\"16\":1}}],[\"次之是远端缓存\",{\"1\":{\"105\":1}}],[\"次幂\",{\"1\":{\"33\":2}}],[\"次幂扩展\",{\"1\":{\"33\":1}}],[\"次方\",{\"1\":{\"32\":1}}],[\"否则启动服务时会提示该方法缺少throwable参数对象\",{\"1\":{\"131\":1}}],[\"否则可能导致\",{\"1\":{\"120\":1}}],[\"否则抛出参数类型错误异常\",{\"1\":{\"115\":1}}],[\"否则无操作\",{\"1\":{\"110\":1}}],[\"否则在配置\",{\"1\":{\"101\":1}}],[\"否则\",{\"1\":{\"33\":1}}],[\"减少碰撞\",{\"1\":{\"32\":1}}],[\"便学习了一番\",{\"1\":{\"138\":1}}],[\"便能看到last参数为false\",{\"1\":{\"136\":1}}],[\"便未深入研究\",{\"1\":{\"105\":1}}],[\"便是包装该对象后\",{\"1\":{\"103\":1}}],[\"便让哈希值与高\",{\"1\":{\"32\":1}}],[\"便于在红黑树和链表之间进行转换\",{\"1\":{\"29\":1}}],[\"位更随机散列\",{\"1\":{\"32\":1}}],[\"位更随机\",{\"1\":{\"32\":1}}],[\"位运算结果取决于低\",{\"1\":{\"32\":1}}],[\"位\",{\"1\":{\"32\":3}}],[\"位甚至更低\",{\"1\":{\"32\":1}}],[\"长度都小于\",{\"1\":{\"32\":1}}],[\"长度始终保持为\",{\"1\":{\"11\":1}}],[\"操作和执行耗时较长的操作\",{\"1\":{\"121\":1}}],[\"操作就会提交\",{\"1\":{\"120\":1}}],[\"操作就是断开\",{\"1\":{\"102\":1}}],[\"操作都没有被提交\",{\"1\":{\"120\":1}}],[\"操作标识\",{\"1\":{\"104\":1}}],[\"操作栈\",{\"1\":{\"61\":1}}],[\"操作实现如下\",{\"1\":{\"32\":1}}],[\"操作\",{\"1\":{\"32\":1,\"112\":1,\"113\":1,\"117\":1,\"121\":1}}],[\"超过则扩容\",{\"1\":{\"30\":1}}],[\"传递\",{\"1\":{\"30\":1}}],[\"覆盖了从\",{\"1\":{\"75\":1}}],[\"覆盖\",{\"1\":{\"30\":1}}],[\"表示连接对象\",{\"1\":{\"129\":1}}],[\"表示是否覆盖已存在的值\",{\"1\":{\"30\":1}}],[\"表添加记录数据\",{\"1\":{\"117\":1}}],[\"表中\",{\"1\":{\"91\":1}}],[\"表格等\",{\"1\":{\"77\":1}}],[\"表只是测试用\",{\"1\":{\"3\":1}}],[\"添加好友的流程除了处理好友请求记录外\",{\"1\":{\"117\":1}}],[\"添加请求在流程中明明只有一次\",{\"1\":{\"117\":1}}],[\"添加非标准扩展\",{\"0\":{\"80\":1}}],[\"添加了非标准的\",{\"1\":{\"75\":1}}],[\"添加\",{\"1\":{\"30\":1}}],[\"执行完这一步\",{\"1\":{\"120\":1}}],[\"执行同样的操作\",{\"1\":{\"80\":1}}],[\"执行\",{\"1\":{\"30\":1,\"101\":1}}],[\"右节点\",{\"1\":{\"29\":1}}],[\"左节点\",{\"1\":{\"29\":1}}],[\"默认将所有数据都用字节缓冲区接收\",{\"1\":{\"136\":1}}],[\"默认将此作为应用主页\",{\"1\":{\"134\":1}}],[\"默认8\",{\"1\":{\"136\":1}}],[\"默认采用\",{\"1\":{\"101\":1}}],[\"默认情况下是否缓存\",{\"1\":{\"101\":1}}],[\"默认使用\",{\"1\":{\"99\":1}}],[\"默认\",{\"1\":{\"99\":1,\"101\":2,\"132\":1}}],[\"默认传递\",{\"1\":{\"30\":1}}],[\"默认的转换为链表的节点阈值\",{\"1\":{\"27\":1}}],[\"默认的转换为红黑树的节点阈值\",{\"1\":{\"27\":1}}],[\"默认是true\",{\"1\":{\"120\":1}}],[\"默认是\",{\"1\":{\"11\":1,\"135\":1,\"136\":1}}],[\"频繁增删\",{\"1\":{\"27\":1}}],[\"徘徊\",{\"1\":{\"27\":1}}],[\"和许多其他网站没有为开发人员提供自助注册流程\",{\"1\":{\"82\":1}}],[\"和其他\",{\"1\":{\"77\":1}}],[\"和\",{\"0\":{\"29\":1},\"1\":{\"27\":1,\"33\":1,\"58\":1,\"63\":1,\"66\":1,\"79\":1,\"89\":1,\"96\":1}}],[\"变量在修改\",{\"1\":{\"120\":1}}],[\"变量所需的配置信息\",{\"1\":{\"102\":1}}],[\"变为\",{\"1\":{\"33\":1}}],[\"变大时\",{\"1\":{\"26\":1}}],[\"变大\",{\"1\":{\"26\":1}}],[\"变成\",{\"1\":{\"25\":1}}],[\"查看了\",{\"1\":{\"105\":1}}],[\"查找匹配的节点\",{\"1\":{\"31\":1}}],[\"查找\",{\"1\":{\"26\":1}}],[\"查询速度就会受到影响\",{\"1\":{\"26\":1}}],[\"查询结果集的遍历处理\",{\"1\":{\"3\":1}}],[\"查询到的枚举\",{\"1\":{\"3\":1}}],[\"再根据\",{\"1\":{\"136\":1}}],[\"再搭配上策略模式优雅代码\",{\"1\":{\"119\":1}}],[\"再次强调\",{\"1\":{\"82\":1}}],[\"再次贴上复制数据的方法源码\",{\"1\":{\"25\":1}}],[\"再到能讲解给别人听让别人理解\",{\"1\":{\"71\":1}}],[\"再去查看关于红黑树操作的源码\",{\"1\":{\"34\":1}}],[\"再将链表头节点存放到新数组的相应位置\",{\"1\":{\"33\":1}}],[\"再进一步计算下标\",{\"1\":{\"32\":1}}],[\"再存入到新数组中\",{\"1\":{\"25\":1}}],[\"循环\",{\"1\":{\"59\":1}}],[\"循环中\",{\"1\":{\"33\":1}}],[\"循环复制数据中\",{\"1\":{\"25\":1}}],[\"循环里遍历一个节点就插入到新的数组位置\",{\"1\":{\"25\":1}}],[\"源码\",{\"1\":{\"25\":1}}],[\"源码如下\",{\"1\":{\"16\":1}}],[\"方式有两种\",{\"1\":{\"125\":1}}],[\"方式\",{\"1\":{\"102\":1}}],[\"方式与数据结构并没有强制规定\",{\"1\":{\"63\":1}}],[\"方志朋\",{\"1\":{\"70\":1}}],[\"方面与\",{\"1\":{\"66\":1}}],[\"方便大家回顾\",{\"1\":{\"25\":1}}],[\"方法参数一session必填\",{\"1\":{\"129\":1}}],[\"方法入参推荐不指定\",{\"1\":{\"118\":1}}],[\"方法入参类型为\",{\"1\":{\"115\":1}}],[\"方法入参只能为\",{\"1\":{\"115\":1}}],[\"方法创建连接\",{\"1\":{\"101\":1}}],[\"方法的\",{\"0\":{\"136\":1}}],[\"方法的名称和描述符\",{\"1\":{\"67\":1}}],[\"方法的源码了\",{\"1\":{\"49\":1}}],[\"方法的源码\",{\"1\":{\"33\":1}}],[\"方法返回值和异常分派\",{\"1\":{\"61\":1}}],[\"方法返回地址\",{\"1\":{\"61\":1}}],[\"方法执行流程所取的字段\",{\"1\":{\"102\":1}}],[\"方法执行过程\",{\"1\":{\"60\":1}}],[\"方法执行的内存模型\",{\"1\":{\"60\":1}}],[\"方法执行时生成的变量\",{\"1\":{\"57\":1}}],[\"方法区也常被称为\",{\"1\":{\"66\":1}}],[\"方法区主要存放的是虚拟机加载的类信息\",{\"1\":{\"66\":1}}],[\"方法区\",{\"0\":{\"66\":1},\"1\":{\"58\":1}}],[\"方法句柄和调用点限定符七类符号引用\",{\"1\":{\"45\":1}}],[\"方法类型\",{\"1\":{\"45\":1}}],[\"方法优化\",{\"1\":{\"35\":1}}],[\"方法进行具体操作\",{\"1\":{\"33\":1}}],[\"方法上有这么一段注释\",{\"1\":{\"33\":1}}],[\"方法开始\",{\"1\":{\"30\":1}}],[\"方法时同样计算key的哈希值然后获取数组下标\",{\"1\":{\"20\":1}}],[\"方法存值时会调用key\",{\"1\":{\"20\":1}}],[\"方法里作了判断\",{\"1\":{\"18\":1}}],[\"方法里计算key的hash值找到下标然后循环遍历判断key的值\",{\"1\":{\"15\":1}}],[\"方法将旧数组数据循环遍历复制到新数组\",{\"1\":{\"16\":1}}],[\"方法就简单多了\",{\"1\":{\"15\":1}}],[\"方法后\",{\"1\":{\"15\":1}}],[\"方法判断是否需要扩容\",{\"1\":{\"14\":1}}],[\"方法实现\",{\"0\":{\"14\":1,\"15\":1,\"16\":1}}],[\"方法原理\",{\"0\":{\"13\":1}}],[\"方法省略\",{\"1\":{\"3\":2}}],[\"方法\",{\"0\":{\"30\":1,\"31\":1,\"32\":1,\"33\":1},\"1\":{\"3\":1,\"30\":1,\"49\":2,\"59\":2,\"63\":2,\"67\":1,\"104\":1,\"133\":1,\"136\":1}}],[\"后续再补充\",{\"1\":{\"138\":1}}],[\"后续\",{\"0\":{\"138\":1}}],[\"后续新篇章也会对\",{\"1\":{\"19\":1}}],[\"后修改连接的自动提交autocommit为false\",{\"1\":{\"120\":1}}],[\"后者是\",{\"1\":{\"101\":1}}],[\"后者依然是基于\",{\"1\":{\"66\":1}}],[\"后有效\",{\"1\":{\"68\":2}}],[\"后无效\",{\"1\":{\"68\":2}}],[\"后\",{\"1\":{\"48\":1,\"66\":1,\"101\":1,\"105\":1,\"117\":1}}],[\"后判断是否等于\",{\"1\":{\"33\":1}}],[\"后就被阻塞\",{\"1\":{\"25\":1}}],[\"后依旧在同一个数组下标位置\",{\"1\":{\"25\":1}}],[\"每建立一个连接便会创建一个端点\",{\"1\":{\"128\":1}}],[\"每一种分片解决方案的架构中都有一个关键组件\",{\"1\":{\"91\":1}}],[\"每当有新的客户端连接接入时\",{\"1\":{\"129\":1}}],[\"每当访问令牌过期时\",{\"1\":{\"83\":1}}],[\"每当添加新元素时\",{\"1\":{\"25\":1}}],[\"每个连接仅此一个\",{\"1\":{\"128\":1}}],[\"每个节点都可以将客户端请求路由到适当的分片所有者\",{\"1\":{\"92\":1}}],[\"每个节点都是一个entry<k\",{\"1\":{\"10\":1}}],[\"每个人的\",{\"0\":{\"79\":1}}],[\"每个人对于\",{\"1\":{\"78\":1}}],[\"每个角落后面都有枪\",{\"1\":{\"77\":1}}],[\"每个\",{\"1\":{\"75\":1,\"81\":1}}],[\"每个方法\",{\"1\":{\"60\":1}}],[\"每个线程都有一个独立的计数器\",{\"1\":{\"59\":1}}],[\"原因是流程做了简化\",{\"1\":{\"117\":1}}],[\"原因之一是链表节点的存储方式引起\",{\"1\":{\"25\":1}}],[\"原文戳此\",{\"1\":{\"105\":1}}],[\"原\",{\"1\":{\"33\":1}}],[\"原索引+原数组容量\",{\"1\":{\"33\":1}}],[\"原理宏观上跟以前的思路差不多\",{\"1\":{\"35\":1}}],[\"原理解析\",{\"0\":{\"28\":1}}],[\"原理并不复杂\",{\"1\":{\"20\":1}}],[\"原头节点就变成新节点的\",{\"1\":{\"25\":1}}],[\"版本的开发计划\",{\"1\":{\"105\":1}}],[\"版本\",{\"1\":{\"79\":1}}],[\"版本有了哪些变化\",{\"1\":{\"24\":1}}],[\"版本开始\",{\"1\":{\"19\":1}}],[\"提交后执行\",{\"1\":{\"112\":1}}],[\"提交后等情况下执行某些操作\",{\"1\":{\"109\":1}}],[\"提供程序错误\",{\"1\":{\"84\":1}}],[\"提供商似乎都像您到目前为止一样忽视了此列表\",{\"1\":{\"78\":1}}],[\"提供的三种类加载器\",{\"1\":{\"47\":1}}],[\"提供的typehandler类型转换器原理并不复杂\",{\"1\":{\"3\":1}}],[\"提高了查询效率\",{\"1\":{\"24\":1}}],[\"最大的变化可能是随着访问令牌的过期和刷新令牌的兴起而带来的\",{\"1\":{\"83\":1}}],[\"最好将其存放在安全的地方\",{\"1\":{\"80\":1}}],[\"最终返回结果\",{\"1\":{\"20\":1}}],[\"最后发送bye给服务端关闭连接\",{\"1\":{\"134\":1}}],[\"最后发送\",{\"1\":{\"134\":1}}],[\"最后一个参数则为端点配置信息对象\",{\"1\":{\"129\":1}}],[\"最后只能依赖连接的autocommit恢复后\",{\"1\":{\"120\":1}}],[\"最后但并非最不重要的一点\",{\"0\":{\"84\":1}}],[\"最后判断容量若大于阈值\",{\"1\":{\"30\":1}}],[\"最后来概括下\",{\"1\":{\"20\":1}}],[\"最后将key\",{\"1\":{\"14\":1}}],[\"作者正在开发一个名为\",{\"1\":{\"75\":1}}],[\"作者们通过为\",{\"1\":{\"75\":1}}],[\"作者\",{\"1\":{\"70\":2}}],[\"作为中间缓冲区暂存数据\",{\"1\":{\"136\":1}}],[\"作为参数\",{\"1\":{\"129\":1}}],[\"作为二级缓存\",{\"1\":{\"97\":1}}],[\"作为一级缓存\",{\"1\":{\"97\":1,\"99\":1}}],[\"作为方法区的一部分\",{\"1\":{\"67\":1}}],[\"作为\",{\"1\":{\"57\":1,\"69\":1,\"79\":1}}],[\"作为入口用于访问该对象在方法区里的数据结构\",{\"1\":{\"41\":1}}],[\"作为下一个节点\",{\"1\":{\"14\":1}}],[\"作下介绍讲解\",{\"1\":{\"19\":1}}],[\"8080\",{\"1\":{\"44\":3,\"134\":2}}],[\"80\",{\"1\":{\"44\":2,\"81\":2}}],[\"8091\",{\"1\":{\"3\":1}}],[\"8\",{\"0\":{\"23\":1},\"1\":{\"19\":3,\"20\":1,\"24\":2,\"25\":3,\"26\":3,\"27\":8,\"29\":2,\"30\":2,\"32\":1,\"35\":2,\"66\":1,\"68\":4,\"105\":1,\"134\":1,\"136\":1}}],[\"疫苗\",{\"1\":{\"19\":1}}],[\"陈皓的\",{\"1\":{\"19\":1}}],[\"简单分为以下几步\",{\"1\":{\"33\":1}}],[\"简单讲就是链表中\",{\"1\":{\"19\":1}}],[\"简单看下其源码\",{\"1\":{\"3\":1}}],[\"刚好需要扩容\",{\"1\":{\"19\":1}}],[\"产生\",{\"1\":{\"19\":1}}],[\"死链就出现了\",{\"1\":{\"25\":1}}],[\"死链原因和解决方法\",{\"0\":{\"25\":1}}],[\"死链是指在\",{\"1\":{\"19\":1}}],[\"死链问题\",{\"0\":{\"19\":1},\"1\":{\"24\":1}}],[\"要求删除的访问令牌\",{\"1\":{\"84\":1}}],[\"要授权您的应用程序\",{\"1\":{\"79\":1}}],[\"要获取刷新令牌\",{\"1\":{\"79\":1}}],[\"要考虑的细节还是挺多\",{\"1\":{\"71\":1}}],[\"要么是原位置加上\",{\"1\":{\"33\":1}}],[\"要高出许多\",{\"1\":{\"18\":1}}],[\"要转化的类型\",{\"1\":{\"3\":1}}],[\"效率将会降低\",{\"1\":{\"27\":1}}],[\"效率比\",{\"1\":{\"18\":1}}],[\"效率较低\",{\"1\":{\"18\":1}}],[\"效率较高\",{\"1\":{\"18\":1}}],[\"其表明了\",{\"1\":{\"128\":1}}],[\"其抽象实现transactionsynchronizationadapter源码如下\",{\"1\":{\"110\":1}}],[\"其次一级缓存框架可以通过配置控制在内存中存储的数据量\",{\"1\":{\"97\":1}}],[\"其节点相互了解\",{\"1\":{\"89\":1}}],[\"其他的则仅在相对\",{\"1\":{\"83\":1}}],[\"其他人都会这样做\",{\"1\":{\"80\":1}}],[\"其中包含我们需要的一切\",{\"1\":{\"79\":1}}],[\"其中包括\",{\"1\":{\"79\":1}}],[\"其中每个用户都会获得一个子域\",{\"1\":{\"79\":1}}],[\"其实这里正确来说\",{\"1\":{\"136\":1}}],[\"其实所有方法都支持使用\",{\"1\":{\"129\":1}}],[\"其实\",{\"1\":{\"105\":1}}],[\"其实在最初的\",{\"1\":{\"47\":1}}],[\"其实有三步\",{\"1\":{\"42\":1}}],[\"其意思大概就是初始化或增加数组大小\",{\"1\":{\"33\":1}}],[\"其采用的是分段锁\",{\"1\":{\"18\":1}}],[\"其它节点直接删除\",{\"1\":{\"104\":1}}],[\"其它广播方式看配置文件即可\",{\"1\":{\"101\":1}}],[\"其它都是由\",{\"1\":{\"47\":1}}],[\"其它代码省略\",{\"1\":{\"10\":1,\"29\":2}}],[\"其它\",{\"0\":{\"4\":1}}],[\"其它操作\",{\"1\":{\"3\":1}}],[\"其它内容\",{\"1\":{\"3\":1}}],[\"容器\",{\"1\":{\"68\":1}}],[\"容易引起线程上下文切换而带来线程调度的开销\",{\"1\":{\"18\":1}}],[\"容量\",{\"1\":{\"11\":1}}],[\"线程恢复等基础功能也都依赖于该计数器来实现\",{\"1\":{\"59\":1}}],[\"线程共享数据区域则随虚拟机的启动\",{\"1\":{\"58\":1}}],[\"线程共享\",{\"1\":{\"58\":2}}],[\"线程私有数据区域生命周期与线程相同\",{\"1\":{\"58\":1}}],[\"线程私有\",{\"1\":{\"58\":2,\"64\":1}}],[\"线程一获取到\",{\"1\":{\"25\":1}}],[\"线程安全\",{\"1\":{\"18\":1}}],[\"线程不安全\",{\"1\":{\"18\":1}}],[\"唯一\",{\"1\":{\"18\":1}}],[\"与processdatabinary\",{\"1\":{\"136\":1}}],[\"与分片解决方案不同\",{\"1\":{\"92\":1}}],[\"与分片数据库解决方案非常相似\",{\"1\":{\"92\":1}}],[\"与分布式数据库\",{\"1\":{\"89\":1}}],[\"与此同时\",{\"1\":{\"79\":1}}],[\"与上面同理\",{\"1\":{\"33\":1}}],[\"与\",{\"0\":{\"18\":1},\"1\":{\"67\":1,\"105\":1}}],[\"补充\",{\"0\":{\"17\":1,\"68\":1}}],[\"理解分片和分布式数据库的细微差别对于数据库的设计和选择至关重要\",{\"1\":{\"89\":1}}],[\"理解\",{\"0\":{\"57\":1}}],[\"理解起来就会比较轻松了\",{\"1\":{\"34\":1}}],[\"理解清楚\",{\"1\":{\"16\":1}}],[\"理解了put\",{\"1\":{\"15\":1}}],[\"关闭需要传递closereason对象\",{\"1\":{\"131\":1}}],[\"关闭连接\",{\"1\":{\"128\":1}}],[\"关闭\",{\"1\":{\"58\":1}}],[\"关键\",{\"1\":{\"16\":1}}],[\"关于心跳\",{\"0\":{\"137\":1}}],[\"关于堆\",{\"1\":{\"68\":1}}],[\"关于\",{\"0\":{\"136\":1},\"1\":{\"41\":1,\"136\":1,\"137\":1}}],[\"关于红黑树\",{\"0\":{\"34\":1}}],[\"关于其逻辑实现在下面会讲到\",{\"1\":{\"25\":1}}],[\"关于死链具体情况\",{\"1\":{\"19\":1}}],[\"关于字典的管理方式可概括为以下两种\",{\"1\":{\"2\":1}}],[\"关于作者\",{\"0\":{\"0\":1}}],[\"头节点指向当前遍历节点\",{\"1\":{\"33\":1}}],[\"头部插入\",{\"1\":{\"16\":1}}],[\"头插法\",{\"1\":{\"16\":1,\"25\":1}}],[\"节点维护数据的冗余副本\",{\"1\":{\"89\":1,\"92\":1}}],[\"节点不为空\",{\"1\":{\"30\":1}}],[\"节点为空直接添加\",{\"1\":{\"30\":1}}],[\"节点以及下一节点\",{\"1\":{\"25\":1}}],[\"节点\",{\"1\":{\"16\":1,\"25\":1}}],[\"链表存储方式变为尾插法\",{\"1\":{\"35\":1}}],[\"链表红黑树互转等则讲解不多\",{\"1\":{\"34\":1}}],[\"链表与红黑树转换时机\",{\"0\":{\"27\":1}}],[\"链表结构\",{\"1\":{\"25\":1}}],[\"链表变成\",{\"1\":{\"25\":1}}],[\"链表头部插入\",{\"1\":{\"16\":1}}],[\"链表节点中的下一个\",{\"1\":{\"10\":1}}],[\"遍历链表\",{\"1\":{\"30\":1}}],[\"遍历当前节点的链表\",{\"1\":{\"16\":1}}],[\"遍历旧数组复制数据\",{\"1\":{\"33\":1}}],[\"遍历旧数组\",{\"1\":{\"16\":1}}],[\"遍历等等\",{\"1\":{\"3\":1}}],[\"^\",{\"1\":{\"16\":1,\"32\":1}}],[\"|=\",{\"1\":{\"16\":1}}],[\"||\",{\"1\":{\"3\":2,\"14\":1,\"15\":1,\"30\":4,\"31\":2,\"120\":1}}],[\"已成为现代\",{\"1\":{\"125\":1}}],[\"已经实现了双因素身份验证模型\",{\"1\":{\"83\":1}}],[\"已经大的夸张\",{\"1\":{\"16\":1}}],[\"已会可忽略\",{\"1\":{\"34\":1}}],[\"已有的节点往后移作为\",{\"1\":{\"16\":1}}],[\"已存储的元素数量\",{\"1\":{\"11\":1}}],[\"获取到路径参数\",{\"1\":{\"128\":1}}],[\"获取到请求参数\",{\"1\":{\"128\":1}}],[\"获取连接进行重置\",{\"1\":{\"120\":1}}],[\"获取数组下标位置第一个节点\",{\"1\":{\"31\":1}}],[\"获取key的\",{\"1\":{\"30\":1}}],[\"获取元素的逻辑还是比较简单\",{\"1\":{\"31\":1}}],[\"获取元素的时间复杂度就变为\",{\"1\":{\"26\":1}}],[\"获取元素可以简单分为以下两步\",{\"1\":{\"26\":1}}],[\"获取\",{\"1\":{\"26\":1,\"30\":1,\"35\":1}}],[\"获取是否需要重新计算\",{\"1\":{\"16\":1}}],[\"获取旧数组长度\",{\"1\":{\"16\":1}}],[\"获取所有entry<k\",{\"1\":{\"12\":1}}],[\"获取所有key的\",{\"1\":{\"12\":1}}],[\"三目表达式判断\",{\"1\":{\"15\":1}}],[\"三大集合框架之一\",{\"1\":{\"8\":1}}],[\"插入到链表头\",{\"1\":{\"14\":1}}],[\"碰撞\",{\"1\":{\"14\":1}}],[\"若传递数据超过8\",{\"1\":{\"136\":1}}],[\"若分为多份\",{\"1\":{\"136\":1}}],[\"若超出则会断开连接\",{\"1\":{\"132\":1}}],[\"若只是代码执行耗时\",{\"1\":{\"121\":1}}],[\"若只是使用事务注解标记整个处理流程\",{\"1\":{\"117\":1}}],[\"若有必要\",{\"1\":{\"121\":1}}],[\"若有也会去修改\",{\"1\":{\"117\":1}}],[\"若有冲突\",{\"1\":{\"31\":1}}],[\"若事务方法发布的事件刚好与参数的事件类型一致\",{\"1\":{\"115\":1}}],[\"若方法入参为空或不为事件类型\",{\"1\":{\"115\":1}}],[\"若方法入参为事件类型\",{\"1\":{\"115\":1}}],[\"若保存数据时指定的\",{\"1\":{\"99\":1}}],[\"若遇到异常\",{\"1\":{\"35\":1}}],[\"若当前遍历的节点元素位置没有冲突\",{\"1\":{\"33\":1}}],[\"若当前节点没有冲突\",{\"1\":{\"33\":1}}],[\"若新数组未设置阈值\",{\"1\":{\"33\":1}}],[\"若无数据并且阈值为\",{\"1\":{\"33\":1}}],[\"若无数据\",{\"1\":{\"33\":1}}],[\"若是超过最大值\",{\"1\":{\"33\":1}}],[\"若是链表节点\",{\"1\":{\"30\":1}}],[\"若多出的高位\",{\"1\":{\"33\":1}}],[\"若下标处第一个节点匹配则返回\",{\"1\":{\"31\":1}}],[\"若节点已经存在\",{\"1\":{\"30\":1}}],[\"若为\",{\"1\":{\"59\":1}}],[\"若为链表节点则进行遍历\",{\"1\":{\"33\":1}}],[\"若为链表则遍历判断\",{\"1\":{\"31\":1}}],[\"若为空直接新增\",{\"1\":{\"30\":1}}],[\"若为树节点则调用\",{\"1\":{\"31\":1}}],[\"若为树节点\",{\"1\":{\"30\":1,\"33\":2}}],[\"若数组下标位置节点key不匹配\",{\"1\":{\"26\":1}}],[\"若链表元素\",{\"1\":{\"25\":1}}],[\"若\",{\"1\":{\"14\":1,\"27\":1,\"30\":1}}],[\"创建连接后\",{\"1\":{\"134\":1}}],[\"创建事件类\",{\"1\":{\"113\":1}}],[\"创建事件对象\",{\"1\":{\"113\":1}}],[\"创建类的实例\",{\"1\":{\"46\":1}}],[\"创建大小为原来\",{\"1\":{\"16\":1}}],[\"创建一个新的数组\",{\"1\":{\"16\":1}}],[\"创建\",{\"1\":{\"14\":1,\"112\":1,\"133\":1,\"135\":2}}],[\"将连接回收到数据库连接池\",{\"1\":{\"120\":1}}],[\"将数据同步到\",{\"1\":{\"104\":1}}],[\"将客户端请求引导到适当的分片\",{\"1\":{\"92\":1}}],[\"将它们称为\",{\"1\":{\"79\":1}}],[\"将使一些当前的最佳实践成为强制性要求\",{\"1\":{\"75\":1}}],[\"将新的常量加入常量池\",{\"1\":{\"67\":1}}],[\"将新数组赋值给\",{\"1\":{\"16\":1}}],[\"将编译好的文件解释成平台系统\",{\"1\":{\"57\":1}}],[\"将其放在\",{\"1\":{\"39\":1}}],[\"将头节点保存在相应位置\",{\"1\":{\"33\":1}}],[\"将尾节点指向当前遍历节点\",{\"1\":{\"33\":2}}],[\"将原有节点\",{\"1\":{\"14\":1}}],[\"将\",{\"1\":{\"14\":2}}],[\"将会抛出异常\",{\"1\":{\"3\":1}}],[\"6379\",{\"1\":{\"101\":1}}],[\"6\",{\"0\":{\"83\":2},\"1\":{\"14\":1,\"27\":3,\"30\":4,\"33\":12}}],[\"修改次数\",{\"1\":{\"14\":1}}],[\"500\",{\"1\":{\"101\":1}}],[\"50\",{\"1\":{\"75\":1,\"76\":2,\"77\":2}}],[\"5\",{\"0\":{\"82\":2},\"1\":{\"14\":1,\"16\":1,\"30\":1,\"33\":2}}],[\"4\",{\"0\":{\"81\":2},\"1\":{\"14\":1,\"16\":1,\"27\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"104\":1,\"105\":1}}],[\"计算下标方式\",{\"1\":{\"32\":1}}],[\"计算下标时\",{\"1\":{\"32\":1}}],[\"计算哈希值从而获取数组下标\",{\"1\":{\"20\":1}}],[\"计算数组下标\",{\"1\":{\"16\":1,\"30\":2}}],[\"计算数组下标并循环遍历该下标处的链表节点\",{\"1\":{\"15\":1}}],[\"计算key的\",{\"1\":{\"14\":1,\"31\":1}}],[\"计算\",{\"1\":{\"14\":1,\"15\":1,\"32\":1}}],[\"复制数据等方法的具体实现是怎么样的\",{\"1\":{\"13\":1}}],[\"设备实时监控等应用场景大放异彩\",{\"1\":{\"125\":1}}],[\"设置过期时间\",{\"1\":{\"101\":1}}],[\"设置\",{\"1\":{\"101\":1,\"136\":1}}],[\"设置不同的\",{\"1\":{\"99\":1}}],[\"设置每个线程的堆栈大小\",{\"1\":{\"68\":1}}],[\"设置元空间最大空间大小\",{\"1\":{\"68\":1}}],[\"设置元空间最小空间大小\",{\"1\":{\"68\":1}}],[\"设置永久代最大空间大小\",{\"1\":{\"68\":1}}],[\"设置永久代最小空间大小\",{\"1\":{\"68\":1}}],[\"设置新生代最大空间大小\",{\"1\":{\"68\":1}}],[\"设置新生代最小空间大小\",{\"1\":{\"68\":1}}],[\"设置堆的最大空间大小\",{\"1\":{\"68\":1}}],[\"设置堆的最小空间大小\",{\"1\":{\"68\":1}}],[\"设置默认的枚举类型转化器\",{\"1\":{\"3\":1}}],[\"设值\",{\"1\":{\"13\":1}}],[\"即修改autocommit=true\",{\"1\":{\"120\":1}}],[\"即缺少最新的请求记录\",{\"1\":{\"117\":1}}],[\"即事务同步\",{\"1\":{\"109\":1}}],[\"即可看到注解方法内的内容输出\",{\"1\":{\"113\":1}}],[\"即可看到如下结果\",{\"1\":{\"112\":1}}],[\"即可\",{\"1\":{\"101\":1}}],[\"即使分片的定义中出现了动词\",{\"1\":{\"90\":1}}],[\"即使部分节点故障也能继续操作\",{\"1\":{\"89\":1}}],[\"即将推出的\",{\"1\":{\"83\":1}}],[\"即将推出\",{\"1\":{\"78\":1}}],[\"即数据类型的默认初始值\",{\"1\":{\"44\":1}}],[\"即数据元素\",{\"1\":{\"12\":1}}],[\"即原来大小的\",{\"1\":{\"33\":1}}],[\"即长度为\",{\"1\":{\"32\":1}}],[\"即添加的新元素会放在链表尾节点\",{\"1\":{\"25\":1}}],[\"即\",{\"1\":{\"25\":2,\"33\":2,\"64\":1,\"99\":1,\"117\":1,\"136\":1}}],[\"即一个key对应一个value\",{\"1\":{\"8\":1}}],[\"存储客户端连接\",{\"1\":{\"128\":1}}],[\"存储结构不能为单独的属性\",{\"1\":{\"101\":1}}],[\"存储模式\",{\"1\":{\"101\":1}}],[\"存储的元素数量在\",{\"1\":{\"27\":1}}],[\"存储的元素数量达到该值\",{\"1\":{\"11\":1}}],[\"存在于自己孤立的环境中\",{\"1\":{\"91\":1}}],[\"存在返回值\",{\"1\":{\"15\":1}}],[\"存放的是几乎所有的对象实例和数组数据\",{\"1\":{\"64\":1}}],[\"存放\",{\"1\":{\"57\":1}}],[\"存放键值对\",{\"1\":{\"12\":1}}],[\"存入缓存区\",{\"1\":{\"48\":1}}],[\"判断类型\",{\"1\":{\"119\":1}}],[\"判断当前\",{\"1\":{\"43\":1}}],[\"判断两个尾节点\",{\"1\":{\"33\":1}}],[\"判断是树节点还是链表节点\",{\"1\":{\"31\":1}}],[\"判断是否为树节点\",{\"1\":{\"30\":1}}],[\"判断是否超过阈值\",{\"1\":{\"30\":1}}],[\"判断是否需要重新计算\",{\"1\":{\"16\":1}}],[\"判断是否\",{\"1\":{\"15\":1}}],[\"判断下标处元素\",{\"1\":{\"30\":1}}],[\"判断该位置是否为空\",{\"1\":{\"30\":1}}],[\"判断值是否相同\",{\"1\":{\"20\":1}}],[\"判断key是否\",{\"1\":{\"15\":1}}],[\"判断key是否重复\",{\"1\":{\"14\":1}}],[\"判断key是否为null\",{\"1\":{\"14\":1}}],[\"判断传递的value是否已有key进行映射\",{\"1\":{\"12\":1}}],[\"判断传递的key在\",{\"1\":{\"12\":1}}],[\"判断\",{\"1\":{\"12\":1,\"14\":2,\"15\":1,\"30\":2}}],[\"返回请求处理结果\",{\"1\":{\"117\":1}}],[\"返回结果等\",{\"1\":{\"57\":1}}],[\"返回\",{\"1\":{\"12\":1}}],[\"返回给前端时不仅有字典值\",{\"1\":{\"3\":1}}],[\"常见示例有提示\",{\"1\":{\"78\":1}}],[\"常见的做法是出入参都用integer类型修饰\",{\"1\":{\"3\":1}}],[\"常用实现方式\",{\"1\":{\"71\":1}}],[\"常用方法\",{\"0\":{\"12\":1}}],[\"常量\",{\"1\":{\"66\":1}}],[\"常量在编译期间会存入调用类的常量池\",{\"1\":{\"46\":1}}],[\"就新开事务执行\",{\"1\":{\"121\":1}}],[\"就需要保证\",{\"1\":{\"117\":1}}],[\"就只会查到旧数据\",{\"1\":{\"117\":1}}],[\"就导致容易遗忘\",{\"1\":{\"71\":1}}],[\"就对应着虚拟机栈的入栈到出栈的过程\",{\"1\":{\"60\":1}}],[\"就可以在多种平台上不加修改地运行\",{\"1\":{\"56\":1}}],[\"就得查看浏览下\",{\"1\":{\"49\":1}}],[\"就已经可以正常使用\",{\"1\":{\"47\":1}}],[\"就说明引用的目标在内存已经存在\",{\"1\":{\"45\":1}}],[\"就进行扩容resize\",{\"1\":{\"30\":1}}],[\"就将链表转换为红黑树\",{\"1\":{\"30\":1}}],[\"就会中断\",{\"1\":{\"81\":1}}],[\"就会转换为红黑树\",{\"1\":{\"27\":1}}],[\"就会很轻松了\",{\"1\":{\"20\":1}}],[\"就会进行扩容操作\",{\"1\":{\"11\":1}}],[\"就是直接指向目标的指针\",{\"1\":{\"45\":1}}],[\"就是在高位多\",{\"1\":{\"33\":1}}],[\"就是在这一步\",{\"1\":{\"3\":1}}],[\"就是对\",{\"1\":{\"3\":1}}],[\"不过在查看了其博客站点\",{\"1\":{\"138\":1}}],[\"不过在实际应用中\",{\"1\":{\"137\":1}}],[\"不依赖于协调器组件\",{\"1\":{\"89\":1}}],[\"不幸的是\",{\"1\":{\"80\":1}}],[\"不是吗\",{\"1\":{\"79\":1}}],[\"不会再有提交操作\",{\"1\":{\"120\":1}}],[\"不会轻易泄露此类信息\",{\"1\":{\"83\":1}}],[\"不会在主程序运行期对方法区进行清理\",{\"1\":{\"66\":1}}],[\"不会触发类初\",{\"1\":{\"46\":1}}],[\"不会触发类初始化的情况如下\",{\"1\":{\"46\":1}}],[\"不会触发\",{\"1\":{\"46\":1}}],[\"不会触发该类的初始化\",{\"1\":{\"46\":1}}],[\"不存在事务时\",{\"1\":{\"113\":1}}],[\"不存在时再从二级缓存读取\",{\"1\":{\"97\":1}}],[\"不存在线程共享和适合被快速\",{\"1\":{\"64\":1}}],[\"不存在则返回null\",{\"1\":{\"15\":1}}],[\"不含\",{\"1\":{\"60\":1}}],[\"不仅问题解决了\",{\"1\":{\"50\":1}}],[\"不为\",{\"1\":{\"33\":1}}],[\"不为空说明链表存在\",{\"1\":{\"33\":1}}],[\"不为空先判断key\",{\"1\":{\"30\":1}}],[\"不为空则进行覆盖并返回旧值\",{\"1\":{\"30\":1}}],[\"不为空\",{\"1\":{\"14\":1,\"18\":1}}],[\"不需要改变位置的链表头节点\",{\"1\":{\"33\":1}}],[\"不超过最大值则扩容为原来的\",{\"1\":{\"33\":1}}],[\"不同说明发生碰撞\",{\"1\":{\"30\":1}}],[\"不覆盖\",{\"1\":{\"30\":1}}],[\"不匹配则循环判断下一节点\",{\"1\":{\"15\":1}}],[\"不指定则默认为\",{\"1\":{\"11\":1}}],[\"不支持的类型转枚举\",{\"1\":{\"3\":1}}],[\"不支持枚举转换jdbc类型\",{\"1\":{\"3\":1}}],[\"重定向的解决方案\",{\"1\":{\"79\":1}}],[\"重定向\",{\"1\":{\"75\":1}}],[\"重要的变化可以简单归纳为\",{\"1\":{\"35\":1}}],[\"重要的是内部静态类增加了treenode<k\",{\"1\":{\"29\":1}}],[\"重复则覆盖并返回旧值\",{\"1\":{\"14\":1}}],[\"重新计算阈值\",{\"1\":{\"16\":1}}],[\"重新调整\",{\"1\":{\"11\":1}}],[\"重新扩容等\",{\"1\":{\"11\":1}}],[\"重拾博客\",{\"1\":{\"0\":1}}],[\"则关闭连接\",{\"1\":{\"128\":1}}],[\"则为类似\",{\"1\":{\"128\":1}}],[\"则提供了实时\",{\"1\":{\"125\":1}}],[\"则善用线程池异步处理\",{\"1\":{\"121\":1}}],[\"则查询\",{\"1\":{\"117\":1}}],[\"则可以正确回调\",{\"1\":{\"115\":1}}],[\"则入参不需要指定\",{\"1\":{\"115\":1}}],[\"则表示方法不关心任何事件\",{\"1\":{\"115\":1}}],[\"则表示只要事件发布了就回调\",{\"1\":{\"113\":1}}],[\"则代表是感兴趣的事件\",{\"1\":{\"115\":1}}],[\"则是全新的两级缓存框架\",{\"1\":{\"105\":1}}],[\"则是对应链表尾节点\",{\"1\":{\"33\":1}}],[\"则\",{\"1\":{\"101\":1}}],[\"则请求首先发送到协调器\",{\"1\":{\"91\":1}}],[\"则计数器的值为空\",{\"1\":{\"59\":1}}],[\"则计数器记录的是正在执行的虚拟机字节码指令的地址\",{\"1\":{\"59\":1}}],[\"则计算新的数组下标直接存值\",{\"1\":{\"33\":1}}],[\"则需要使用到类加载器\",{\"1\":{\"47\":1}}],[\"则需要前端一一转化\",{\"1\":{\"3\":1}}],[\"则其父类也会被初始化\",{\"1\":{\"46\":1}}],[\"则系统依次执行这些初始化语句\",{\"1\":{\"46\":1}}],[\"则先初始化其直接父类\",{\"1\":{\"46\":1}}],[\"则程序先加载并连接该类\",{\"1\":{\"46\":1}}],[\"则会从二级缓存获取最新数据\",{\"1\":{\"104\":1}}],[\"则会有前缀为\",{\"1\":{\"101\":1}}],[\"则会自动创建\",{\"1\":{\"99\":1}}],[\"则会直接赋值为\",{\"1\":{\"44\":1}}],[\"则会触发扩容操作\",{\"1\":{\"11\":1}}],[\"则直接计算新的数组下标存值\",{\"1\":{\"33\":1}}],[\"则链表存在\",{\"1\":{\"33\":1}}],[\"则链表为空\",{\"1\":{\"33\":1}}],[\"则链表元素会出现逆序\",{\"1\":{\"25\":1}}],[\"则调用\",{\"1\":{\"33\":1}}],[\"则进入此处计算新的\",{\"1\":{\"33\":1}}],[\"则使用默认值设置\",{\"1\":{\"33\":1}}],[\"则用初始化阈值赋值\",{\"1\":{\"33\":1}}],[\"则不扩容\",{\"1\":{\"33\":1}}],[\"则不需要变化\",{\"1\":{\"33\":1}}],[\"则元素\",{\"1\":{\"33\":1}}],[\"则按默认值进行初始化\",{\"1\":{\"33\":1}}],[\"则下标运算的结果取决于哈希值的低\",{\"1\":{\"32\":1}}],[\"则替换旧值oldvalue并返回\",{\"1\":{\"30\":1}}],[\"则遍历到链表尾部判断\",{\"1\":{\"30\":1}}],[\"则遍历链表\",{\"1\":{\"26\":1}}],[\"则判断是否与当前遍历节点相同\",{\"1\":{\"30\":1}}],[\"则转换为红黑树\",{\"1\":{\"30\":1}}],[\"则说明发生\",{\"1\":{\"14\":1}}],[\"则扩容为原来的2倍大小\",{\"1\":{\"14\":1}}],[\"阈值大小计算为\",{\"1\":{\"11\":1}}],[\"阈值\",{\"1\":{\"11\":2}}],[\"并创建文件index\",{\"1\":{\"134\":1}}],[\"并为其注册一个\",{\"1\":{\"133\":1}}],[\"并为开发人员提供简单的自助注册流程来注册他们的应用程序并开始使用\",{\"1\":{\"82\":1}}],[\"并实现其相关方法来处理新连接建立\",{\"1\":{\"128\":1}}],[\"并实时互传数据\",{\"1\":{\"125\":1}}],[\"并通过注解属性指定回调时的事务阶段和感兴趣的事件\",{\"1\":{\"113\":1}}],[\"并可通过ordered接口控制多个事务同步的执行顺序\",{\"1\":{\"110\":1}}],[\"并不麻烦\",{\"1\":{\"137\":1}}],[\"并不能直接通过\",{\"1\":{\"135\":1}}],[\"并不复杂\",{\"1\":{\"104\":1}}],[\"并不需要像\",{\"1\":{\"58\":1}}],[\"并插入\",{\"1\":{\"92\":1}}],[\"并无缝处理客户端请求\",{\"1\":{\"89\":1}}],[\"并执行多节点事务\",{\"1\":{\"89\":1}}],[\"并包括强制的\",{\"1\":{\"83\":1}}],[\"并祝您好运在您的\",{\"1\":{\"80\":1}}],[\"并听听您是如何做到的\",{\"1\":{\"76\":1}}],[\"并分享给别人\",{\"1\":{\"71\":1}}],[\"并理解类加载器的执行机制\",{\"1\":{\"50\":1}}],[\"并重写其\",{\"1\":{\"49\":1}}],[\"并重新计算阈值\",{\"1\":{\"16\":1}}],[\"并在准备阶段赋值为\",{\"1\":{\"44\":1}}],[\"并初始化类变量的值\",{\"1\":{\"44\":1}}],[\"并将这些分片分布在多个独立的数据库实例上来实现水平可扩展性\",{\"1\":{\"89\":1}}],[\"并将其转换成\",{\"1\":{\"48\":1}}],[\"并将其初始化为默认值\",{\"0\":{\"44\":1}}],[\"并将key\",{\"1\":{\"20\":1}}],[\"并提供了访问方法区内的数据结构的接口\",{\"1\":{\"39\":1}}],[\"并判断节点在新数组的位置\",{\"1\":{\"33\":1}}],[\"并含有before\",{\"1\":{\"29\":1}}],[\"并且该注解还提供了属性maxmessagesize用于控制接收的消息大小\",{\"1\":{\"132\":1}}],[\"并且该内存区域是唯一一个在虚拟机中没有规定任何\",{\"1\":{\"59\":1}}],[\"并且方法带有一个closereason对象\",{\"1\":{\"130\":1}}],[\"并且利用事务同步功能\",{\"1\":{\"121\":1}}],[\"并且得等到清理资源时才提交\",{\"1\":{\"118\":1}}],[\"并且至少得等到下一次有用户对\",{\"1\":{\"117\":1}}],[\"并且可缓存数量的大小和超时时间与\",{\"1\":{\"99\":1}}],[\"并且可以在几天内完成\",{\"1\":{\"82\":1}}],[\"并且即使某些节点出现故障\",{\"1\":{\"92\":1}}],[\"并且需要您做大量的工作\",{\"1\":{\"82\":1}}],[\"并且必须设置为特定的固定值\",{\"1\":{\"79\":1}}],[\"并且类的元数据放入本地内存\",{\"1\":{\"66\":1}}],[\"并且堆也无法再扩展时抛出\",{\"1\":{\"65\":1}}],[\"并且\",{\"1\":{\"35\":1,\"46\":1,\"64\":1}}],[\"并且在扩容方法的\",{\"1\":{\"25\":1}}],[\"并且死链情况在\",{\"1\":{\"19\":1}}],[\"并发送通知给到其它节点\",{\"1\":{\"104\":1}}],[\"并发扩容出现死链\",{\"1\":{\"25\":1}}],[\"并发情况下\",{\"1\":{\"19\":1}}],[\"并解决了死链问题\",{\"1\":{\"24\":1}}],[\"并保存了下一个entry<k\",{\"1\":{\"10\":1}}],[\"并采用共识算法将更改复制到其他节点的子集\",{\"1\":{\"92\":1}}],[\"并采用\",{\"1\":{\"9\":1}}],[\"kv\",{\"1\":{\"101\":1}}],[\"kryo\",{\"1\":{\"101\":1}}],[\"keep\",{\"1\":{\"83\":2}}],[\"keys\",{\"1\":{\"104\":2}}],[\"keyset\",{\"1\":{\"12\":1}}],[\"key\",{\"1\":{\"10\":2,\"12\":4,\"14\":17,\"15\":13,\"16\":2,\"18\":2,\"20\":1,\"25\":2,\"29\":9,\"30\":18,\"31\":13,\"32\":4,\"78\":1,\"79\":1,\"91\":2,\"99\":2,\"101\":2,\"103\":2,\"129\":1}}],[\"key唯一\",{\"1\":{\"9\":1}}],[\"kindly\",{\"1\":{\"79\":1}}],[\"kind\",{\"1\":{\"78\":1,\"83\":1}}],[\"know\",{\"1\":{\"78\":1,\"84\":1}}],[\"k\",{\"1\":{\"10\":4,\"12\":1,\"14\":6,\"15\":3,\"29\":4,\"30\":9,\"31\":7}}],[\"键值对\",{\"1\":{\"10\":1}}],[\"本身也是支持二进制消息的\",{\"1\":{\"132\":1}}],[\"本身提供的模块依赖\",{\"1\":{\"125\":1}}],[\"本身并非一个缓存框架\",{\"1\":{\"97\":1}}],[\"本质上是为了保证一次业务请求处理过程中涉及多次\",{\"1\":{\"109\":1}}],[\"本质上是一个映射\",{\"1\":{\"10\":1}}],[\"本地主机上有\",{\"1\":{\"79\":1}}],[\"本地方法栈是为\",{\"1\":{\"63\":1}}],[\"本地方法栈的作用其实与虚拟机栈类似\",{\"1\":{\"63\":1}}],[\"本地方法栈\",{\"0\":{\"63\":1},\"1\":{\"58\":1}}],[\"本篇是\",{\"1\":{\"75\":1,\"89\":1,\"125\":1}}],[\"本篇是我第一次编写的博客文章\",{\"1\":{\"71\":1}}],[\"本篇主要说明\",{\"1\":{\"69\":1}}],[\"本篇主要讲解\",{\"1\":{\"50\":1}}],[\"本篇着重于\",{\"1\":{\"57\":1}}],[\"本篇\",{\"1\":{\"8\":1}}],[\"数据编解码器等\",{\"1\":{\"128\":1}}],[\"数据已落库\",{\"1\":{\"117\":1}}],[\"数据刷新到缓存\",{\"1\":{\"117\":1}}],[\"数据不一致情况\",{\"1\":{\"117\":1}}],[\"数据\",{\"1\":{\"117\":2}}],[\"数据未更新\",{\"1\":{\"117\":1}}],[\"数据真正落库\",{\"1\":{\"117\":1}}],[\"数据操作\",{\"1\":{\"116\":1,\"118\":1}}],[\"数据操作时的原子性\",{\"1\":{\"109\":1}}],[\"数据库\",{\"1\":{\"117\":1}}],[\"数据库的数据同步问题时\",{\"1\":{\"105\":1}}],[\"数据库设计选择\",{\"1\":{\"89\":1}}],[\"数据区两大类\",{\"1\":{\"58\":1}}],[\"数组长度\",{\"1\":{\"14\":1}}],[\"数组其实就是entry<k\",{\"1\":{\"10\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"19\":1,\"24\":1,\"26\":1}}],[\"数组+链表\",{\"1\":{\"10\":1}}],[\"数值integertypehandler\",{\"1\":{\"3\":1}}],[\"是根据\",{\"1\":{\"136\":1}}],[\"是其它\",{\"1\":{\"135\":1}}],[\"是标识连接的唯一字符\",{\"1\":{\"128\":1}}],[\"是因为\",{\"1\":{\"125\":1}}],[\"是因为put\",{\"1\":{\"18\":1}}],[\"是在执行事务回调完成后\",{\"1\":{\"120\":1}}],[\"是跟\",{\"1\":{\"120\":1}}],[\"是对缓存设计的封装\",{\"1\":{\"105\":1}}],[\"是阿里开源的一款缓存框架\",{\"1\":{\"105\":1}}],[\"是基于\",{\"1\":{\"101\":1,\"125\":1}}],[\"是基于哈希表\",{\"1\":{\"9\":1}}],[\"是无法为每个\",{\"1\":{\"99\":1}}],[\"是记录分片的所有者\",{\"1\":{\"92\":1}}],[\"是时候考虑以下问题了\",{\"1\":{\"84\":1}}],[\"是货币化\",{\"1\":{\"82\":1}}],[\"是的\",{\"1\":{\"78\":1,\"79\":2,\"81\":1,\"82\":1}}],[\"是如何管理内存\",{\"1\":{\"69\":1}}],[\"是如何处理并正确使用\",{\"1\":{\"50\":1}}],[\"是回退到方法执行前的原因了吧\",{\"1\":{\"60\":1}}],[\"是描述\",{\"1\":{\"60\":1}}],[\"是当前线程所执行的字节码的行号指示器\",{\"1\":{\"59\":1}}],[\"是通过单个\",{\"1\":{\"125\":1}}],[\"是通过\",{\"1\":{\"57\":1}}],[\"是通过计算key的hash值来确定数组下标位置\",{\"1\":{\"10\":1}}],[\"是一个标准\",{\"1\":{\"81\":1}}],[\"是一个标准协议\",{\"1\":{\"76\":1}}],[\"是一个非常大的标准\",{\"1\":{\"78\":1}}],[\"是一个key\",{\"1\":{\"8\":1}}],[\"是一道必须攻破的关卡\",{\"1\":{\"69\":1}}],[\"是一门可跨平台的语言\",{\"1\":{\"57\":1}}],[\"是一种用于计算设备的规范\",{\"1\":{\"56\":1}}],[\"是则调用puttreeval\",{\"1\":{\"30\":1}}],[\"是假设当链表长度大于小于\",{\"1\":{\"27\":1}}],[\"是将索引下标处的链表节点全部遍历获取后\",{\"1\":{\"25\":1}}],[\"是否将数据分割\",{\"1\":{\"136\":1}}],[\"是否有过期时间\",{\"1\":{\"101\":1}}],[\"是否相同\",{\"1\":{\"30\":1}}],[\"是否\",{\"1\":{\"15\":1}}],[\"是否为红色节点\",{\"1\":{\"29\":1}}],[\"是否为\",{\"1\":{\"14\":1}}],[\"是否为空\",{\"1\":{\"12\":1,\"30\":1}}],[\"是\",{\"1\":{\"10\":1,\"16\":1,\"56\":1,\"64\":1,\"96\":1,\"103\":1,\"125\":1}}],[\"是作为\",{\"1\":{\"10\":1,\"80\":1}}],[\"72\",{\"1\":{\"78\":2}}],[\"75\",{\"1\":{\"11\":1}}],[\"7\",{\"1\":{\"8\":1,\"24\":1,\"25\":2,\"27\":1,\"30\":2}}],[\"等名称\",{\"1\":{\"125\":1}}],[\"等同于classes指定了该事件\",{\"1\":{\"115\":1}}],[\"等则可参考配置文件去填写即可\",{\"1\":{\"102\":1}}],[\"等数据库都有针对于分片的实现方案来解决某些业务场景\",{\"1\":{\"89\":1}}],[\"等等\",{\"1\":{\"82\":1}}],[\"等来配置\",{\"1\":{\"68\":1}}],[\"等\",{\"1\":{\"8\":1,\"57\":1,\"70\":1,\"75\":1}}],[\"时便设置为\",{\"1\":{\"120\":1}}],[\"时便已存在\",{\"1\":{\"8\":1}}],[\"时是取的自身建立的连接\",{\"1\":{\"101\":1}}],[\"时再加载它\",{\"1\":{\"39\":1}}],[\"时\",{\"1\":{\"27\":3,\"48\":2,\"101\":1,\"117\":1}}],[\"时指定的容量大小\",{\"1\":{\"11\":1}}],[\"时隔三年\",{\"1\":{\"0\":1}}],[\"聊聊\",{\"0\":{\"7\":1}}],[\"开发者需要详细阅读每个\",{\"1\":{\"75\":1}}],[\"开发者\",{\"1\":{\"69\":1}}],[\"开发一样时刻关注内存的释放\",{\"1\":{\"58\":1}}],[\"开发一枚\",{\"1\":{\"0\":1}}],[\"开发人员\",{\"1\":{\"57\":1}}],[\"开发技巧\",{\"2\":{\"5\":1,\"6\":1}}],[\"还会判断用户好友历史记录是否添加过目标用户\",{\"1\":{\"117\":1}}],[\"还记得第一次学习\",{\"1\":{\"105\":1}}],[\"还做了更烦人的事情\",{\"1\":{\"80\":1}}],[\"还使用\",{\"1\":{\"78\":1}}],[\"还可以在运行期间\",{\"1\":{\"67\":1}}],[\"还具有相应的指令系统\",{\"1\":{\"56\":1}}],[\"还能更深入的理解其核心原理\",{\"1\":{\"50\":1}}],[\"还保存了当前entry<k\",{\"1\":{\"10\":1}}],[\"还不错\",{\"1\":{\"4\":1}}],[\"还有对应的字典描述以直接展示\",{\"1\":{\"3\":1}}],[\"巧用枚举让字典表的管理和使用变得简单\",{\"1\":{\"4\":1}}],[\"直接使用\",{\"1\":{\"46\":1}}],[\"直接使用枚举类型\",{\"1\":{\"3\":1}}],[\"直接引用\",{\"1\":{\"45\":1}}],[\"直接取数组下标为\",{\"1\":{\"15\":1}}],[\"直接上源码\",{\"1\":{\"15\":1,\"30\":1}}],[\"直接存放在数组下标\",{\"1\":{\"14\":1}}],[\"直戳链接进入\",{\"1\":{\"4\":1}}],[\"完\",{\"1\":{\"3\":1}}],[\"也没有深入讲解原理\",{\"1\":{\"138\":1}}],[\"也没有做一些知识记录\",{\"1\":{\"71\":1}}],[\"也可在此对\",{\"1\":{\"131\":1}}],[\"也可达到缩小事务范围的效果\",{\"1\":{\"121\":1}}],[\"也可以由客户端主动断开\",{\"1\":{\"134\":1}}],[\"也可以先带着问题去阅读下源码\",{\"1\":{\"118\":1}}],[\"也可以在不停机的情况下继续操作\",{\"1\":{\"92\":1}}],[\"也可以理解为是用永久代方法实现了方法区\",{\"1\":{\"66\":1}}],[\"也可以自定义类加载器对\",{\"1\":{\"41\":1}}],[\"也就导致了事务回调期间的\",{\"1\":{\"120\":1}}],[\"也就是说\",{\"1\":{\"136\":1}}],[\"也就是静态配置\",{\"1\":{\"103\":1}}],[\"也就是\",{\"1\":{\"46\":1}}],[\"也已提供二级缓存功能了\",{\"1\":{\"105\":1}}],[\"也不支持任何促进此类通信的协议\",{\"1\":{\"91\":1}}],[\"也会使刷新令牌过期\",{\"1\":{\"83\":1}}],[\"也适用于本地主机\",{\"1\":{\"79\":1}}],[\"也足以让人感到复杂\",{\"1\":{\"75\":1}}],[\"也是印度尼西亚的首都\",{\"1\":{\"125\":1}}],[\"也是因为对于\",{\"1\":{\"71\":1}}],[\"也是\",{\"1\":{\"64\":1}}],[\"也是面试经典问题了\",{\"1\":{\"35\":1}}],[\"也与虚拟机栈相同\",{\"1\":{\"63\":1}}],[\"也有其它的开源或闭源实现\",{\"1\":{\"56\":1}}],[\"也有忽略的细节\",{\"1\":{\"50\":1}}],[\"也将由该类加载器负责载入\",{\"1\":{\"48\":1}}],[\"也提供了自己实现的jacksontypehandler\",{\"1\":{\"3\":1}}],[\"也在同一天发布了第一篇文章\",{\"1\":{\"0\":1}}],[\"至于上述三个缓冲区的大小设置方式\",{\"1\":{\"136\":1}}],[\"至于其它的一些细枝末节\",{\"1\":{\"20\":1}}],[\"至于\",{\"1\":{\"3\":1}}],[\"成功\",{\"1\":{\"3\":1}}],[\"入参依然可指定为某个事件类型\",{\"1\":{\"115\":1}}],[\"入参必须为该值对应的事件类型\",{\"1\":{\"115\":1}}],[\"入参转化\",{\"1\":{\"3\":1}}],[\"入参与返回数据如下\",{\"1\":{\"3\":1}}],[\"入参枚举\",{\"1\":{\"3\":1}}],[\"luttuce\",{\"1\":{\"101\":1}}],[\"luck\",{\"1\":{\"80\":1}}],[\"luckily\",{\"1\":{\"79\":1,\"83\":1}}],[\"ld\",{\"1\":{\"96\":1}}],[\"l2provider\",{\"1\":{\"103\":2}}],[\"l2\",{\"1\":{\"96\":2,\"101\":2,\"104\":2}}],[\"l1\",{\"1\":{\"96\":2,\"101\":1,\"104\":3}}],[\"lack\",{\"1\":{\"92\":1}}],[\"larger\",{\"1\":{\"91\":1}}],[\"latest\",{\"1\":{\"81\":1}}],[\"later\",{\"1\":{\"78\":1}}],[\"last自然为false\",{\"1\":{\"136\":1}}],[\"last\",{\"0\":{\"84\":1,\"136\":1},\"1\":{\"78\":1,\"128\":2}}],[\"lang=\",{\"1\":{\"134\":1}}],[\"lang\",{\"1\":{\"39\":1,\"41\":1}}],[\"leverages\",{\"1\":{\"90\":1}}],[\"lead\",{\"1\":{\"82\":1}}],[\"leads\",{\"1\":{\"78\":1}}],[\"learn\",{\"1\":{\"78\":1}}],[\"least\",{\"0\":{\"84\":1},\"1\":{\"76\":1,\"79\":1,\"80\":1,\"83\":1}}],[\"lettucecacheprovider\",{\"1\":{\"103\":2}}],[\"lettuce\",{\"1\":{\"101\":6,\"104\":1}}],[\"letting\",{\"1\":{\"84\":1}}],[\"let\",{\"1\":{\"77\":1,\"78\":2,\"79\":1,\"134\":1}}],[\"left\",{\"1\":{\"29\":1}}],[\"lengthy\",{\"1\":{\"83\":1}}],[\"length\",{\"1\":{\"14\":5,\"15\":1,\"16\":2,\"25\":1,\"30\":2,\"31\":1,\"33\":1}}],[\"limit\",{\"1\":{\"82\":1}}],[\"list<string>>\",{\"1\":{\"128\":1}}],[\"list<user>\",{\"1\":{\"3\":1}}],[\"listing\",{\"1\":{\"82\":1}}],[\"listed\",{\"1\":{\"82\":1}}],[\"list\",{\"1\":{\"78\":1,\"79\":1,\"80\":1,\"82\":1}}],[\"lists\",{\"1\":{\"78\":1}}],[\"likely\",{\"1\":{\"78\":1}}],[\"like\",{\"1\":{\"76\":1,\"78\":2,\"79\":2,\"83\":1,\"84\":1,\"92\":2}}],[\"lindholm\",{\"1\":{\"70\":1}}],[\"linux\",{\"1\":{\"57\":1}}],[\"linkedin\",{\"1\":{\"77\":2,\"81\":2}}],[\"linkedhashmap\",{\"1\":{\"8\":1,\"29\":2}}],[\"linkageerror\",{\"1\":{\"39\":1}}],[\"liberal\",{\"1\":{\"82\":1}}],[\"library\",{\"1\":{\"76\":1,\"80\":1}}],[\"libraries\",{\"1\":{\"76\":1}}],[\"lib\",{\"1\":{\"47\":2}}],[\"lowest\",{\"1\":{\"110\":1}}],[\"love\",{\"1\":{\"85\":2}}],[\"locations\",{\"1\":{\"79\":1}}],[\"locally\",{\"1\":{\"92\":1}}],[\"local\",{\"1\":{\"64\":1}}],[\"localhost\",{\"1\":{\"3\":1,\"79\":4,\"134\":2}}],[\"lots\",{\"1\":{\"78\":1}}],[\"lot\",{\"1\":{\"78\":1,\"81\":2}}],[\"lotail\",{\"1\":{\"33\":7}}],[\"looked\",{\"1\":{\"81\":1}}],[\"looking\",{\"1\":{\"80\":1,\"82\":1,\"83\":1,\"92\":1}}],[\"look\",{\"1\":{\"78\":1}}],[\"longer\",{\"1\":{\"84\":1}}],[\"long\",{\"1\":{\"76\":1,\"78\":1,\"79\":2}}],[\"longvalue\",{\"1\":{\"3\":1}}],[\"lohead\",{\"1\":{\"33\":4}}],[\"loadclass\",{\"1\":{\"49\":3}}],[\"load\",{\"1\":{\"33\":1,\"90\":1,\"92\":1}}],[\"loadfactor\",{\"1\":{\"11\":2,\"16\":1,\"33\":1}}],[\"loggerfactory\",{\"1\":{\"128\":1}}],[\"logger\",{\"1\":{\"120\":7,\"128\":9}}],[\"logins\",{\"1\":{\"82\":1}}],[\"login\",{\"1\":{\"78\":1}}],[\"log\",{\"1\":{\"3\":2,\"26\":1,\"27\":1,\"134\":4}}],[\"对事务的特性和使用需有所理解\",{\"1\":{\"121\":1}}],[\"对现在的企业\",{\"1\":{\"97\":1}}],[\"对\",{\"1\":{\"80\":1}}],[\"对标准\",{\"1\":{\"77\":1}}],[\"对一门新技术\",{\"1\":{\"71\":1}}],[\"对字节码描述的信息进行语义分析\",{\"1\":{\"43\":1}}],[\"对key\",{\"1\":{\"32\":1}}],[\"对象中\",{\"1\":{\"120\":1}}],[\"对象定义\",{\"1\":{\"103\":1}}],[\"对象发布更新通知\",{\"1\":{\"103\":1}}],[\"对象去获取\",{\"1\":{\"101\":1}}],[\"对象来设置缓存的时间策略\",{\"1\":{\"99\":1}}],[\"对象都存放在堆区的原因\",{\"1\":{\"39\":1}}],[\"对象封装了类在方法区内的数据结构\",{\"1\":{\"39\":1}}],[\"对象进行存储\",{\"1\":{\"20\":1}}],[\"对象并添加\",{\"1\":{\"14\":1}}],[\"对象的\",{\"1\":{\"10\":1}}],[\"对象\",{\"1\":{\"10\":1,\"39\":1,\"41\":1,\"46\":1,\"48\":2,\"101\":1,\"104\":2,\"135\":1}}],[\"对象存储\",{\"1\":{\"10\":1}}],[\"对象包含了一个字段\",{\"1\":{\"3\":1}}],[\"对于后端人员来说\",{\"1\":{\"89\":1}}],[\"对于后端则无大碍\",{\"1\":{\"3\":1}}],[\"对于最终用户来说\",{\"1\":{\"82\":1}}],[\"对于应该如何完成工作存在普遍共识\",{\"1\":{\"77\":1}}],[\"对于简单的第三方访问令牌授权都是相关的\",{\"1\":{\"75\":1}}],[\"对于异常抛出规范\",{\"1\":{\"63\":1}}],[\"对于\",{\"1\":{\"56\":1,\"79\":1}}],[\"对于页面渲染性能有影响\",{\"1\":{\"3\":1}}],[\"对于前端\",{\"1\":{\"3\":1}}],[\"对于变化较多的字典较为麻烦\",{\"1\":{\"2\":1}}],[\"如代码示例中的wsmap\",{\"1\":{\"129\":1}}],[\"如代码所示去获取参数即可\",{\"1\":{\"129\":1}}],[\"如endpoint\",{\"1\":{\"128\":1}}],[\"如请求\",{\"1\":{\"125\":1}}],[\"如上即为连接获取后autocommit的修改操作\",{\"1\":{\"120\":1}}],[\"如上代码\",{\"1\":{\"3\":1}}],[\"如添加好友\",{\"1\":{\"117\":1}}],[\"如资源准备\",{\"1\":{\"109\":1}}],[\"如今在公司看到其它系统项目引入\",{\"1\":{\"105\":1}}],[\"如何撤销您不再需要的访问令牌\",{\"1\":{\"84\":1}}],[\"如何安全地存储这些访问令牌和刷新令牌\",{\"1\":{\"84\":1}}],[\"如何确保在刷新当前访问令牌时没有其他请求运行\",{\"1\":{\"83\":1}}],[\"如何观察我\",{\"1\":{\"81\":1}}],[\"如何针对此特定\",{\"1\":{\"78\":1}}],[\"如何处理\",{\"1\":{\"69\":1}}],[\"如有疑问\",{\"1\":{\"78\":1}}],[\"如即将到来的\",{\"1\":{\"75\":1}}],[\"如技术原理\",{\"1\":{\"71\":1}}],[\"如处理器\",{\"1\":{\"56\":1}}],[\"如\",{\"1\":{\"47\":1,\"50\":1,\"63\":1,\"97\":2,\"102\":1}}],[\"如class\",{\"1\":{\"46\":1}}],[\"如新增树节点\",{\"1\":{\"34\":1}}],[\"如此一来\",{\"1\":{\"26\":1}}],[\"如修改值\",{\"1\":{\"11\":1}}],[\"如字符串stringtypehandler\",{\"1\":{\"3\":1}}],[\"如下图\",{\"1\":{\"33\":1}}],[\"如下图所示\",{\"1\":{\"32\":1,\"40\":1,\"47\":1}}],[\"如下\",{\"1\":{\"3\":1,\"10\":1,\"113\":1,\"128\":1,\"134\":1,\"136\":1}}],[\"如果时使用\",{\"1\":{\"101\":1}}],[\"如果不是\",{\"1\":{\"92\":1}}],[\"如果不是那么烦人的话\",{\"1\":{\"77\":1}}],[\"如果客户端想要将新记录插入\",{\"1\":{\"91\":1}}],[\"如果读者对分片数据库架构感兴趣\",{\"1\":{\"89\":1}}],[\"如果这些附加数据可以与\",{\"1\":{\"80\":1}}],[\"如果这个类一直没有被程序主动使用\",{\"1\":{\"39\":1}}],[\"如果他们真的尝试实施完整的标准\",{\"1\":{\"78\":1}}],[\"如果您有兴趣探索真正的分布式数据库的架构\",{\"1\":{\"92\":1}}],[\"如果您有兴趣深入研究分片数据库架构\",{\"1\":{\"91\":1}}],[\"如果您尝试一下\",{\"1\":{\"85\":1}}],[\"如果您读到这里\",{\"1\":{\"85\":1}}],[\"如果您在一定天数内不使用刷新令牌\",{\"1\":{\"83\":1}}],[\"如果您现在使用的\",{\"1\":{\"83\":1}}],[\"如果您希望实施当前的安全最佳实践\",{\"1\":{\"83\":1}}],[\"如果您想与我们分享您最糟糕的\",{\"1\":{\"85\":1}}],[\"如果您想超过\",{\"1\":{\"82\":1}}],[\"如果您想访问包含更敏感用户数据\",{\"1\":{\"82\":1}}],[\"如果您获得批准\",{\"1\":{\"82\":1}}],[\"如果您使用其他系统的\",{\"1\":{\"82\":1}}],[\"如果您传入\",{\"1\":{\"81\":1}}],[\"如果您输入\",{\"1\":{\"79\":1}}],[\"如果您认为这仍然感觉太复杂并且需要学习很多东西\",{\"1\":{\"78\":1}}],[\"如果您成功了\",{\"1\":{\"76\":1}}],[\"如果在堆中没有内存完成实例分配\",{\"1\":{\"65\":1}}],[\"如果在预先加载的过程中遇到了\",{\"1\":{\"39\":1}}],[\"如果线程正在执行的是一个\",{\"1\":{\"59\":1}}],[\"如果直接重写\",{\"1\":{\"49\":1}}],[\"如果有需要\",{\"1\":{\"49\":1}}],[\"如果指定参数initialize为\",{\"1\":{\"46\":1}}],[\"如果一个类中既没有类变量也没有静态代码块\",{\"1\":{\"46\":1}}],[\"如果想先了解\",{\"1\":{\"38\":1}}],[\"如果数组本就为空\",{\"1\":{\"33\":1}}],[\"如果链表长度大于等于treeify\",{\"1\":{\"30\":1}}],[\"如果加入新元素超过阈值\",{\"1\":{\"14\":1}}],[\"如果\",{\"1\":{\"3\":1,\"92\":1}}],[\"utf\",{\"1\":{\"134\":1}}],[\"uuid\",{\"1\":{\"128\":1}}],[\"uid\",{\"1\":{\"128\":4,\"135\":3}}],[\"u\",{\"1\":{\"79\":1}}],[\"ubiquitous\",{\"1\":{\"79\":1}}],[\"update\",{\"1\":{\"112\":1,\"113\":1}}],[\"updated\",{\"1\":{\"81\":1}}],[\"upcoming\",{\"1\":{\"83\":1}}],[\"upon\",{\"1\":{\"81\":1}}],[\"up\",{\"1\":{\"78\":1}}],[\"urls\",{\"1\":{\"79\":1}}],[\"url\",{\"1\":{\"75\":1,\"79\":5,\"80\":6}}],[\"ushered\",{\"1\":{\"83\":1}}],[\"usually\",{\"1\":{\"81\":1}}],[\"us\",{\"1\":{\"76\":1,\"79\":1,\"81\":1,\"85\":1}}],[\"useful\",{\"1\":{\"81\":1}}],[\"used\",{\"1\":{\"78\":1,\"82\":1}}],[\"use\",{\"1\":{\"78\":3,\"79\":1,\"83\":1}}],[\"uses\",{\"1\":{\"78\":2,\"80\":1,\"81\":1}}],[\"usealthashing\",{\"1\":{\"16\":3}}],[\"userservice\",{\"1\":{\"135\":5}}],[\"users\",{\"1\":{\"3\":2,\"79\":1,\"80\":1,\"82\":2,\"84\":3}}],[\"usermapper\",{\"1\":{\"3\":3}}],[\"user\",{\"1\":{\"3\":2,\"79\":1,\"80\":5,\"82\":1,\"83\":1,\"84\":2,\"103\":1}}],[\"using\",{\"1\":{\"3\":2,\"33\":2,\"82\":3,\"83\":2}}],[\"unexpected\",{\"1\":{\"128\":2}}],[\"unbindresource\",{\"1\":{\"120\":1}}],[\"unnecessarily\",{\"1\":{\"120\":1}}],[\"unlike\",{\"1\":{\"92\":1}}],[\"unaware\",{\"1\":{\"91\":1}}],[\"uncovered\",{\"1\":{\"83\":1}}],[\"unchecked\",{\"1\":{\"3\":1,\"33\":1}}],[\"unfortunately\",{\"1\":{\"80\":1}}],[\"undertow\",{\"1\":{\"128\":1}}],[\"underscores\",{\"1\":{\"92\":1}}],[\"understanding\",{\"1\":{\"92\":1}}],[\"understand\",{\"1\":{\"79\":1,\"81\":1}}],[\"under\",{\"1\":{\"84\":1}}],[\"undefined\",{\"1\":{\"59\":1}}],[\"until\",{\"1\":{\"78\":1}}],[\"untreeify\",{\"1\":{\"27\":1}}],[\"unknown\",{\"1\":{\"3\":1}}],[\"接收\",{\"1\":{\"132\":1}}],[\"接下来的所有代码示例也是基于注解方式实现\",{\"1\":{\"128\":1}}],[\"接下来一一讲解每个部分都做了什么\",{\"1\":{\"40\":1}}],[\"接下来我们具体看看\",{\"1\":{\"13\":1}}],[\"接下来是入参\",{\"1\":{\"3\":1}}],[\"接口\",{\"1\":{\"104\":1}}],[\"接口方法\",{\"1\":{\"45\":1}}],[\"接口进行测试了\",{\"1\":{\"3\":1}}],[\"接口添加两个注解使用上述的序列化与反序列化器即可\",{\"1\":{\"3\":1}}],[\"写在前头\",{\"0\":{\"75\":1,\"89\":1}}],[\"写出枚举名称键值\",{\"1\":{\"3\":1}}],[\"写枚举的值\",{\"1\":{\"3\":1}}],[\"wssummaryapplication\",{\"1\":{\"136\":2}}],[\"wsframebase\",{\"1\":{\"136\":1}}],[\"ws\",{\"1\":{\"128\":2,\"133\":1,\"134\":2}}],[\"wsmap\",{\"1\":{\"128\":2}}],[\"www\",{\"1\":{\"79\":2}}],[\"won\",{\"1\":{\"79\":1}}],[\"worst\",{\"1\":{\"85\":1}}],[\"worse\",{\"1\":{\"79\":1}}],[\"word\",{\"1\":{\"79\":1}}],[\"words\",{\"1\":{\"78\":1}}],[\"worry\",{\"1\":{\"78\":1}}],[\"working\",{\"1\":{\"81\":1,\"83\":2}}],[\"work\",{\"1\":{\"78\":1,\"80\":1,\"82\":1,\"83\":1}}],[\"works\",{\"1\":{\"78\":2}}],[\"world\",{\"1\":{\"77\":1}}],[\"wouldn\",{\"1\":{\"80\":1}}],[\"would\",{\"1\":{\"76\":1,\"77\":1,\"91\":1}}],[\"who\",{\"1\":{\"80\":1,\"82\":1,\"92\":1}}],[\"wheel\",{\"1\":{\"79\":1}}],[\"where\",{\"1\":{\"79\":3}}],[\"whenever\",{\"1\":{\"83\":1}}],[\"when\",{\"1\":{\"78\":2,\"79\":2,\"80\":1,\"81\":2,\"83\":1,\"84\":1,\"92\":1}}],[\"what\",{\"1\":{\"78\":2,\"79\":2,\"81\":4}}],[\"which\",{\"1\":{\"78\":2,\"79\":4,\"80\":2,\"81\":1,\"85\":1,\"90\":1,\"92\":3}}],[\"while\",{\"1\":{\"16\":1,\"25\":3,\"31\":1,\"33\":1,\"79\":1,\"81\":1,\"83\":1,\"92\":1}}],[\"why\",{\"0\":{\"76\":1},\"1\":{\"75\":1,\"79\":1,\"80\":2,\"85\":1,\"91\":2}}],[\"will\",{\"1\":{\"80\":1,\"82\":1,\"83\":3,\"92\":2}}],[\"windows\",{\"1\":{\"57\":1}}],[\"without\",{\"1\":{\"92\":1}}],[\"with\",{\"1\":{\"33\":2,\"76\":1,\"78\":4,\"79\":4,\"80\":5,\"81\":3,\"82\":2,\"83\":5,\"85\":2,\"91\":1,\"92\":3}}],[\"waiting\",{\"1\":{\"82\":1}}],[\"walkthroughs\",{\"1\":{\"82\":1}}],[\"way\",{\"0\":{\"85\":1},\"1\":{\"81\":1,\"85\":1}}],[\"ways\",{\"0\":{\"79\":1}}],[\"wants\",{\"1\":{\"91\":1}}],[\"want\",{\"1\":{\"79\":3,\"82\":2,\"85\":1,\"120\":1}}],[\"was\",{\"1\":{\"33\":1,\"79\":1,\"81\":1}}],[\"warn\",{\"1\":{\"3\":1}}],[\"weaker\",{\"1\":{\"82\":1}}],[\"welcome\",{\"1\":{\"79\":1}}],[\"well\",{\"1\":{\"78\":1,\"83\":1}}],[\"were\",{\"1\":{\"78\":1}}],[\"weren\",{\"1\":{\"77\":1}}],[\"weeks\",{\"1\":{\"78\":1,\"82\":2}}],[\"webapprootlistener\",{\"1\":{\"136\":1}}],[\"websocketconfig\",{\"1\":{\"133\":1,\"136\":1}}],[\"websocket<\",{\"1\":{\"127\":1}}],[\"websocket\",{\"0\":{\"124\":1,\"126\":1},\"1\":{\"125\":5,\"128\":5,\"129\":1,\"132\":2,\"133\":2,\"134\":12,\"136\":8,\"137\":1,\"138\":3,\"139\":2},\"2\":{\"141\":1}}],[\"web\",{\"1\":{\"68\":1,\"83\":2,\"109\":1,\"125\":1}}],[\"we\",{\"0\":{\"84\":1},\"1\":{\"33\":1,\"76\":2,\"77\":1,\"78\":3,\"79\":3,\"80\":5,\"81\":1,\"82\":3,\"83\":4,\"84\":1,\"85\":4,\"120\":2}}],[\"writing\",{\"1\":{\"82\":1}}],[\"writestringfield\",{\"1\":{\"3\":1}}],[\"writenumber\",{\"1\":{\"3\":1}}],[\"writenull\",{\"1\":{\"3\":1}}],[\"wrong\",{\"1\":{\"81\":1}}],[\"wrappers\",{\"1\":{\"3\":1}}],[\"为何还会参与原始事务\",{\"1\":{\"118\":1}}],[\"为何还要加事务\",{\"1\":{\"117\":1}}],[\"为避免出现这种情况\",{\"1\":{\"117\":1}}],[\"为好友\",{\"1\":{\"117\":1}}],[\"为不同缓存解决方案提供统一的使用方式\",{\"1\":{\"105\":1}}],[\"为例\",{\"1\":{\"101\":1}}],[\"为每个客户使用不同的\",{\"1\":{\"80\":1}}],[\"为了简洁起见\",{\"1\":{\"80\":1}}],[\"为了安全起见\",{\"1\":{\"79\":1}}],[\"为了让哈希值的低\",{\"1\":{\"32\":1}}],[\"为什么分片解决方案中甚至需要协调器\",{\"1\":{\"91\":1}}],[\"为什么不喜欢这个简单的\",{\"1\":{\"78\":1}}],[\"为什么\",{\"0\":{\"74\":1,\"76\":1},\"1\":{\"80\":2}}],[\"为类的静态变量赋予正确的初始值\",{\"1\":{\"46\":1}}],[\"为类的静态变量分配内存\",{\"0\":{\"44\":1}}],[\"为空则与\",{\"1\":{\"101\":1}}],[\"为空则先创建\",{\"1\":{\"30\":1}}],[\"为空则创建\",{\"1\":{\"30\":1}}],[\"为空直接添加\",{\"1\":{\"30\":1}}],[\"为空直接抛出\",{\"1\":{\"18\":1}}],[\"为空直接获取数组下标为\",{\"1\":{\"15\":1}}],[\"为null则直接存放到数组下标为\",{\"1\":{\"14\":1}}],[\"为枚举字段添加一个字段来描述对应的内容\",{\"1\":{\"3\":1}}],[\"为\",{\"1\":{\"3\":1,\"14\":1,\"15\":1,\"33\":2,\"92\":1,\"99\":1,\"120\":1}}],[\"当数据内容过大\",{\"1\":{\"132\":1}}],[\"当连接默认为自动提交时\",{\"1\":{\"120\":1}}],[\"当服务端接收\",{\"1\":{\"117\":1}}],[\"当存在多个事务同步且有顺序要去时可指定\",{\"1\":{\"110\":1}}],[\"当存值时若元素数量大于阈值threshold则进行扩容\",{\"1\":{\"20\":1}}],[\"当扩展到更多节点时\",{\"1\":{\"92\":1}}],[\"当我们实现这一点时\",{\"1\":{\"83\":1}}],[\"当您使用的服务使用广泛的通用错误消息时\",{\"1\":{\"81\":1}}],[\"当线程请求栈深度超出虚拟机栈所允许的深度时抛出\",{\"1\":{\"62\":1}}],[\"当线程一恢复运行后\",{\"1\":{\"25\":1}}],[\"当然这里也可以直接通过匿名类的方式创建\",{\"1\":{\"112\":1}}],[\"当然了\",{\"1\":{\"66\":1}}],[\"当然本篇并不算全面细致的讲解\",{\"1\":{\"50\":1}}],[\"当然\",{\"1\":{\"49\":1}}],[\"当程序中需要使用某个\",{\"1\":{\"48\":1}}],[\"当一个类加载器负责加载某个\",{\"1\":{\"48\":1}}],[\"当一个类加载器收到类加载任务\",{\"1\":{\"48\":1}}],[\"当有了直接引用\",{\"1\":{\"45\":1}}],[\"当节点不存在则新增\",{\"1\":{\"30\":1}}],[\"当节点数量达到\",{\"1\":{\"27\":1}}],[\"当链表节点数量\",{\"1\":{\"30\":1}}],[\"当链表节点数量大于等于\",{\"1\":{\"27\":1}}],[\"当发生哈希碰撞时\",{\"1\":{\"27\":1}}],[\"当碰撞频率高时\",{\"1\":{\"26\":1}}],[\"当通过put\",{\"1\":{\"20\":1}}],[\"当\",{\"1\":{\"11\":1,\"62\":1,\"104\":1,\"117\":1}}],[\"当前节点的前一节点\",{\"1\":{\"29\":1}}],[\"当前\",{\"1\":{\"10\":1,\"80\":1}}],[\"当前反序列化字段的类型\",{\"1\":{\"3\":1}}],[\"当前反序列化的字段名\",{\"1\":{\"3\":1}}],[\"当前反序列化目标对象的类\",{\"1\":{\"3\":1}}],[\"当前字段所在类\",{\"1\":{\"3\":1}}],[\"当接口的出入参中包含字典字段时\",{\"1\":{\"3\":1}}],[\"反序列化\",{\"1\":{\"3\":1}}],[\"html>\",{\"1\":{\"134\":2}}],[\"html\",{\"1\":{\"134\":1}}],[\"https\",{\"1\":{\"79\":8,\"96\":1}}],[\"http\",{\"1\":{\"3\":1,\"79\":2,\"125\":3}}],[\"hubspot\",{\"1\":{\"77\":2,\"82\":2}}],[\"host\",{\"1\":{\"101\":1,\"102\":1}}],[\"hosts\",{\"1\":{\"101\":2}}],[\"horizontal\",{\"1\":{\"90\":1}}],[\"horror\",{\"1\":{\"85\":1}}],[\"hold\",{\"1\":{\"80\":1}}],[\"holder\",{\"1\":{\"16\":1,\"101\":1,\"120\":1}}],[\"hopefully\",{\"1\":{\"79\":1}}],[\"however\",{\"1\":{\"78\":1,\"82\":1,\"91\":1,\"92\":1}}],[\"how\",{\"1\":{\"76\":1,\"77\":1,\"78\":4,\"81\":2,\"83\":1,\"84\":2}}],[\"hour\",{\"1\":{\"76\":1,\"81\":1}}],[\"hotspot\",{\"1\":{\"63\":1,\"66\":2}}],[\"home\",{\"1\":{\"47\":2}}],[\"hint\",{\"1\":{\"78\":1}}],[\"hitail\",{\"1\":{\"33\":7}}],[\"hihead\",{\"1\":{\"33\":4}}],[\"hello\",{\"1\":{\"103\":1}}],[\"held\",{\"1\":{\"33\":1}}],[\"here\",{\"1\":{\"80\":1}}],[\"head>\",{\"1\":{\"134\":1}}],[\"headers\",{\"1\":{\"79\":1}}],[\"heard\",{\"1\":{\"82\":1}}],[\"hear\",{\"1\":{\"76\":1,\"78\":1,\"82\":2,\"85\":2}}],[\"heap\",{\"1\":{\"58\":1,\"64\":1}}],[\"hexo\",{\"1\":{\"0\":2}}],[\"h\",{\"1\":{\"10\":2,\"14\":2,\"32\":4}}],[\"had\",{\"1\":{\"83\":1}}],[\"hand\",{\"1\":{\"92\":1}}],[\"handful\",{\"1\":{\"83\":1}}],[\"handle\",{\"1\":{\"79\":1,\"92\":1}}],[\"handler\",{\"1\":{\"3\":1}}],[\"happy\",{\"1\":{\"82\":1,\"85\":1}}],[\"haven\",{\"0\":{\"84\":1}}],[\"have\",{\"1\":{\"78\":2,\"79\":1,\"80\":2,\"81\":2,\"82\":3,\"83\":2,\"84\":2,\"92\":2}}],[\"hasconnectionholder\",{\"1\":{\"120\":1}}],[\"has\",{\"1\":{\"77\":1,\"78\":1,\"79\":2,\"80\":1,\"81\":1,\"82\":1,\"83\":4,\"84\":1,\"91\":1}}],[\"hashcode\",{\"1\":{\"20\":1,\"26\":1,\"32\":2}}],[\"hashing\",{\"1\":{\"16\":1,\"84\":1}}],[\"hash值\",{\"1\":{\"10\":1}}],[\"hash\",{\"0\":{\"32\":1},\"1\":{\"9\":1,\"10\":3,\"14\":18,\"15\":7,\"16\":5,\"25\":3,\"26\":1,\"29\":8,\"30\":14,\"31\":9,\"32\":5,\"33\":5,\"35\":1,\"101\":3}}],[\"hashtable\",{\"0\":{\"18\":1},\"1\":{\"8\":1,\"9\":1,\"18\":3}}],[\"hashmap的死循环\",{\"1\":{\"19\":1}}],[\"hashmap\",{\"0\":{\"7\":1,\"19\":1,\"23\":1},\"1\":{\"8\":3,\"9\":2,\"10\":4,\"11\":9,\"12\":5,\"13\":1,\"14\":1,\"16\":3,\"18\":1,\"19\":5,\"20\":2,\"24\":5,\"25\":2,\"26\":2,\"27\":2,\"29\":2,\"32\":1,\"34\":2,\"35\":5},\"2\":{\"22\":1,\"37\":1}}],[\"harder\",{\"1\":{\"81\":1}}],[\"hard\",{\"0\":{\"76\":1,\"81\":1,\"83\":1},\"1\":{\"75\":1,\"78\":1,\"81\":1}}],[\"oschina\",{\"1\":{\"96\":1,\"104\":1}}],[\"operator\",{\"1\":{\"103\":1}}],[\"operates\",{\"1\":{\"92\":1}}],[\"operations\",{\"1\":{\"92\":1}}],[\"open\",{\"1\":{\"66\":1,\"85\":1}}],[\"option\",{\"1\":{\"84\":1}}],[\"optional\",{\"1\":{\"81\":1,\"82\":1}}],[\"obtaindatasource\",{\"1\":{\"120\":2}}],[\"observe\",{\"1\":{\"81\":1}}],[\"oblivious\",{\"1\":{\"78\":1,\"91\":1}}],[\"object\",{\"1\":{\"3\":2,\"12\":4,\"14\":1,\"15\":3,\"31\":2,\"32\":1,\"48\":1,\"101\":1,\"113\":1,\"120\":2}}],[\"owner\",{\"1\":{\"92\":3}}],[\"owning\",{\"1\":{\"91\":1}}],[\"own\",{\"1\":{\"77\":1,\"91\":1}}],[\"our\",{\"1\":{\"77\":1,\"78\":1,\"85\":1}}],[\"outlining\",{\"1\":{\"78\":1}}],[\"outlook\",{\"1\":{\"77\":2}}],[\"outofmemoryerror\",{\"1\":{\"57\":1,\"62\":1,\"63\":1,\"65\":1,\"66\":1,\"67\":1}}],[\"out\",{\"1\":{\"3\":1,\"80\":1,\"82\":1,\"103\":3,\"112\":5,\"113\":1}}],[\"others\",{\"1\":{\"82\":1,\"83\":1}}],[\"other\",{\"1\":{\"77\":1,\"82\":2,\"83\":1,\"91\":2,\"92\":4}}],[\"otherwise\",{\"1\":{\"33\":1}}],[\"onstartup\",{\"1\":{\"136\":1}}],[\"onclose方法也能得到回调并输出日志\",{\"1\":{\"134\":1}}],[\"onclose注解的方法则用于监听连接的关闭\",{\"1\":{\"130\":1}}],[\"onclose\",{\"0\":{\"130\":1},\"1\":{\"128\":2,\"134\":1}}],[\"once\",{\"1\":{\"78\":1}}],[\"onopen方法在整个连接的生命周期中\",{\"1\":{\"135\":1}}],[\"onopen注解的方法会监听客户端的连接事件\",{\"1\":{\"129\":1}}],[\"onopen\",{\"0\":{\"129\":1},\"1\":{\"128\":2,\"134\":1,\"135\":2}}],[\"onmessage来做对应的处理\",{\"1\":{\"137\":1}}],[\"onmessage方法时\",{\"1\":{\"136\":1}}],[\"onmessage方法的参数类型来决定是否转化为对应类型\",{\"1\":{\"136\":1}}],[\"onmessage方法的last参数是\",{\"1\":{\"136\":1}}],[\"onmessage方法自然是用来接收客户端消息\",{\"1\":{\"132\":1}}],[\"onmessage自然是接收服务端推送的内容\",{\"1\":{\"134\":1}}],[\"onmessage\",{\"0\":{\"132\":1,\"136\":1},\"1\":{\"128\":2,\"134\":1}}],[\"onerror方法则用于处理异常事件\",{\"1\":{\"131\":1}}],[\"onerror\",{\"0\":{\"131\":1},\"1\":{\"128\":2,\"134\":1}}],[\"ones\",{\"1\":{\"81\":1}}],[\"one\",{\"1\":{\"78\":2,\"81\":1,\"90\":1,\"91\":3}}],[\"onedrive\",{\"1\":{\"77\":2}}],[\"only\",{\"1\":{\"78\":2,\"80\":1,\"83\":2,\"84\":1}}],[\"onlyifabsent\",{\"1\":{\"30\":3}}],[\"on\",{\"0\":{\"82\":1},\"1\":{\"77\":1,\"78\":3,\"79\":5,\"80\":1,\"81\":1,\"82\":2,\"83\":2,\"84\":2,\"91\":2,\"92\":5}}],[\"oauth蜜蜂\",{\"1\":{\"77\":1}}],[\"oauth2\",{\"1\":{\"75\":1,\"81\":2}}],[\"oauth\",{\"0\":{\"74\":1,\"76\":2,\"77\":2,\"78\":2,\"79\":2,\"80\":2,\"81\":2,\"83\":2},\"1\":{\"75\":21,\"76\":8,\"77\":5,\"78\":28,\"79\":15,\"80\":10,\"81\":12,\"82\":2,\"83\":10,\"84\":6,\"85\":6}}],[\"oom\",{\"1\":{\"57\":1,\"59\":1,\"66\":1,\"97\":1}}],[\"often\",{\"1\":{\"81\":2,\"82\":1,\"83\":1,\"92\":1}}],[\"offline\",{\"1\":{\"79\":4}}],[\"official\",{\"1\":{\"78\":2}}],[\"offset\",{\"1\":{\"33\":1}}],[\"of\",{\"0\":{\"82\":1},\"1\":{\"33\":2,\"77\":1,\"78\":8,\"79\":3,\"80\":9,\"81\":3,\"82\":9,\"83\":5,\"84\":1,\"90\":1,\"91\":4,\"92\":11}}],[\"org\",{\"1\":{\"128\":1,\"136\":4}}],[\"original\",{\"1\":{\"90\":1}}],[\"orr\",{\"1\":{\"80\":1}}],[\"oracle\",{\"1\":{\"56\":1,\"89\":1,\"91\":2,\"125\":2}}],[\"ordered\",{\"1\":{\"110\":2}}],[\"order\",{\"1\":{\"33\":1}}],[\"or\",{\"1\":{\"33\":2,\"76\":1,\"78\":1,\"79\":2,\"81\":3,\"82\":3,\"83\":1,\"84\":1,\"91\":2,\"92\":1}}],[\"o\",{\"1\":{\"26\":2}}],[\"old\",{\"1\":{\"83\":1}}],[\"oldthr\",{\"1\":{\"33\":4}}],[\"oldtab\",{\"1\":{\"33\":7}}],[\"oldtable\",{\"1\":{\"16\":2}}],[\"oldcap\",{\"1\":{\"33\":10}}],[\"oldcapacity\",{\"1\":{\"16\":2}}],[\"oldalthashing\",{\"1\":{\"16\":2}}],[\"oldvalue\",{\"1\":{\"14\":2,\"30\":3}}],[\"override\",{\"1\":{\"3\":8,\"110\":8,\"112\":3,\"120\":2,\"135\":1,\"136\":1}}],[\"backwards\",{\"1\":{\"83\":1}}],[\"back\",{\"1\":{\"82\":1}}],[\"based\",{\"1\":{\"92\":1}}],[\"base\",{\"1\":{\"80\":1}}],[\"basetypehandler<basicenum<e>>\",{\"1\":{\"3\":1}}],[\"basetypehandler<t>\",{\"1\":{\"3\":1}}],[\"basicremote\",{\"1\":{\"128\":1}}],[\"basic\",{\"1\":{\"79\":1,\"128\":1}}],[\"basicenum\",{\"1\":{\"3\":11}}],[\"basicenum<demoenum>\",{\"1\":{\"3\":1}}],[\"basicenum<\",{\"1\":{\"3\":4}}],[\"basicenum<e>\",{\"1\":{\"3\":8}}],[\"basicenum<e\",{\"1\":{\"3\":2}}],[\"blog\",{\"1\":{\"82\":1}}],[\"blaming\",{\"1\":{\"78\":1}}],[\"boardcast\",{\"1\":{\"102\":1}}],[\"both\",{\"1\":{\"92\":1}}],[\"bother\",{\"1\":{\"79\":1}}],[\"bot\",{\"1\":{\"80\":1}}],[\"body>\",{\"1\":{\"134\":1}}],[\"body\",{\"1\":{\"79\":1}}],[\"boot<\",{\"1\":{\"127\":1}}],[\"boot\",{\"1\":{\"125\":2,\"127\":2,\"134\":1,\"135\":1,\"139\":1},\"2\":{\"141\":1}}],[\"bootstrap\",{\"1\":{\"47\":1}}],[\"books\",{\"1\":{\"79\":2}}],[\"book\",{\"1\":{\"78\":1}}],[\"boolean\",{\"1\":{\"12\":3,\"16\":3,\"25\":1,\"29\":1,\"30\":2,\"110\":1,\"113\":1,\"128\":1}}],[\"bytebuffer\",{\"1\":{\"136\":2}}],[\"byte\",{\"1\":{\"132\":1,\"136\":1}}],[\"bytevalue\",{\"1\":{\"3\":1}}],[\"bye\",{\"1\":{\"128\":3,\"134\":2}}],[\"by\",{\"1\":{\"78\":2,\"79\":1,\"80\":1,\"81\":1,\"82\":2,\"84\":1,\"90\":1,\"91\":1,\"92\":1}}],[\"broadcast\",{\"1\":{\"101\":2}}],[\"broad\",{\"1\":{\"81\":1}}],[\"browser\",{\"1\":{\"77\":1}}],[\"brex\",{\"1\":{\"82\":2}}],[\"brevity\",{\"1\":{\"80\":1}}],[\"breaks\",{\"1\":{\"81\":2}}],[\"break\",{\"1\":{\"3\":5,\"30\":2,\"81\":1}}],[\"braintree\",{\"1\":{\"80\":2}}],[\"burdened\",{\"1\":{\"92\":1}}],[\"built\",{\"1\":{\"92\":2}}],[\"builder\",{\"1\":{\"102\":2}}],[\"build\",{\"0\":{\"82\":1},\"1\":{\"79\":1,\"82\":1}}],[\"building\",{\"1\":{\"78\":1,\"85\":1}}],[\"but\",{\"0\":{\"84\":1},\"1\":{\"77\":1,\"78\":5,\"79\":4,\"80\":4,\"81\":1,\"82\":3,\"83\":2,\"84\":1,\"90\":1,\"92\":1}}],[\"buffer\",{\"1\":{\"64\":1,\"136\":3}}],[\"bugs\",{\"1\":{\"84\":1}}],[\"bug\",{\"1\":{\"35\":1}}],[\"bucketindex\",{\"1\":{\"14\":7}}],[\"bevent\",{\"1\":{\"119\":2}}],[\"beansexception\",{\"1\":{\"135\":1}}],[\"bean\",{\"0\":{\"135\":1},\"1\":{\"102\":1,\"133\":2,\"135\":4}}],[\"bearer\",{\"1\":{\"78\":2}}],[\"become\",{\"1\":{\"82\":1}}],[\"becomes\",{\"1\":{\"82\":1}}],[\"because\",{\"1\":{\"33\":1,\"82\":1}}],[\"being\",{\"1\":{\"81\":1}}],[\"been\",{\"1\":{\"81\":1,\"83\":2}}],[\"better\",{\"0\":{\"85\":1},\"1\":{\"79\":1,\"80\":3,\"83\":1,\"85\":1}}],[\"beware\",{\"1\":{\"79\":1}}],[\"best\",{\"1\":{\"78\":1,\"83\":2}}],[\"behalf\",{\"1\":{\"80\":1}}],[\"behavior\",{\"1\":{\"78\":1,\"80\":1}}],[\"behaviors\",{\"1\":{\"77\":1}}],[\"behind\",{\"1\":{\"77\":1}}],[\"be\",{\"1\":{\"76\":1,\"77\":2,\"78\":4,\"79\":2,\"80\":4,\"81\":1,\"82\":4,\"85\":2,\"92\":1}}],[\"beforecompletion\",{\"1\":{\"110\":1}}],[\"beforecommit\",{\"1\":{\"110\":1}}],[\"before\",{\"1\":{\"29\":1,\"82\":1}}],[\"b\",{\"1\":{\"19\":2,\"25\":5,\"115\":2,\"117\":8}}],[\"biggest\",{\"1\":{\"83\":1}}],[\"big\",{\"0\":{\"78\":1},\"1\":{\"78\":1}}],[\"bigint\",{\"1\":{\"3\":1}}],[\"bit\",{\"1\":{\"33\":4}}],[\"binarybuffersize\",{\"1\":{\"136\":1}}],[\"bin\",{\"1\":{\"33\":1}}],[\"bincount\",{\"1\":{\"30\":2}}],[\"bingqiling\",{\"1\":{\"3\":1}}],[\"转化出参\",{\"1\":{\"3\":1}}],[\"转化入参\",{\"1\":{\"3\":1}}],[\"转为枚举对象\",{\"1\":{\"3\":1}}],[\"转为指定的\",{\"1\":{\"3\":1}}],[\"转向\",{\"1\":{\"0\":1}}],[\"duh\",{\"1\":{\"81\":1}}],[\"dynamic\",{\"1\":{\"79\":1}}],[\"date\",{\"1\":{\"80\":1}}],[\"datasource\",{\"1\":{\"120\":1}}],[\"datasourcetransactionobject\",{\"1\":{\"120\":2}}],[\"datasourceutils\",{\"1\":{\"120\":4}}],[\"dataset\",{\"1\":{\"90\":1}}],[\"database\",{\"1\":{\"89\":1,\"90\":3,\"91\":7,\"92\":3,\"101\":1}}],[\"databases\",{\"0\":{\"92\":1},\"1\":{\"89\":1,\"92\":6}}],[\"data\",{\"1\":{\"3\":1,\"79\":3,\"80\":2,\"82\":1,\"90\":1,\"91\":1,\"92\":5,\"134\":1}}],[\"days\",{\"1\":{\"79\":1,\"81\":1,\"82\":2,\"83\":1}}],[\"dx\",{\"1\":{\"78\":2}}],[\"d\",{\"1\":{\"76\":1,\"78\":1,\"79\":1,\"80\":1,\"85\":2}}],[\"drivers\",{\"1\":{\"120\":1}}],[\"drastic\",{\"1\":{\"82\":1}}],[\"dr\",{\"1\":{\"76\":2}}],[\"drop\",{\"1\":{\"60\":1}}],[\"directs\",{\"1\":{\"92\":1}}],[\"directly\",{\"1\":{\"92\":1}}],[\"director\",{\"1\":{\"91\":1}}],[\"dirs\",{\"1\":{\"47\":1}}],[\"divulge\",{\"1\":{\"83\":1}}],[\"dive\",{\"1\":{\"77\":1}}],[\"distinction\",{\"1\":{\"92\":1}}],[\"distinct\",{\"1\":{\"92\":1}}],[\"distribution\",{\"1\":{\"91\":1,\"92\":3}}],[\"distribute\",{\"1\":{\"92\":1}}],[\"distributes\",{\"1\":{\"90\":2}}],[\"distributed\",{\"0\":{\"90\":1,\"92\":1},\"1\":{\"81\":1,\"89\":3,\"90\":2,\"91\":1,\"92\":7}}],[\"disregarded\",{\"1\":{\"81\":1}}],[\"discovered\",{\"1\":{\"79\":1}}],[\"dispatch\",{\"1\":{\"61\":1}}],[\"different\",{\"0\":{\"79\":1},\"1\":{\"78\":3,\"79\":4,\"80\":3}}],[\"dinner\",{\"1\":{\"76\":1}}],[\"did\",{\"1\":{\"76\":2,\"78\":1,\"79\":1,\"81\":1}}],[\"dictionary<k\",{\"1\":{\"18\":1}}],[\"dobegin\",{\"1\":{\"120\":1}}],[\"downtime\",{\"1\":{\"92\":1}}],[\"doesn\",{\"1\":{\"92\":2}}],[\"does\",{\"0\":{\"90\":1},\"1\":{\"79\":1,\"80\":4,\"89\":1}}],[\"doctype\",{\"1\":{\"134\":1}}],[\"doctor\",{\"1\":{\"79\":1}}],[\"docleanupaftercompletion\",{\"1\":{\"120\":1}}],[\"documented\",{\"1\":{\"113\":1}}],[\"documentation\",{\"1\":{\"84\":1}}],[\"documents\",{\"1\":{\"78\":1}}],[\"docs\",{\"1\":{\"78\":1,\"79\":2,\"81\":2}}],[\"don\",{\"1\":{\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":2,\"120\":1}}],[\"done\",{\"1\":{\"77\":1,\"78\":1,\"79\":1}}],[\"doubt\",{\"1\":{\"78\":1}}],[\"double\",{\"1\":{\"33\":1}}],[\"doubles\",{\"1\":{\"33\":1}}],[\"do\",{\"1\":{\"31\":1,\"33\":1,\"78\":3,\"79\":2,\"80\":2,\"91\":2,\"92\":1,\"119\":2,\"120\":1,\"128\":1}}],[\"decoders\",{\"1\":{\"128\":1}}],[\"decisions\",{\"1\":{\"92\":1}}],[\"dependency>\",{\"1\":{\"127\":1}}],[\"deployments\",{\"1\":{\"91\":1}}],[\"deeper\",{\"1\":{\"91\":1}}],[\"design\",{\"1\":{\"92\":1}}],[\"designed\",{\"1\":{\"91\":1}}],[\"deserializationcontext\",{\"1\":{\"3\":2}}],[\"deserialize\",{\"1\":{\"3\":1}}],[\"delving\",{\"1\":{\"91\":1}}],[\"delete\",{\"1\":{\"84\":1}}],[\"delicious\",{\"1\":{\"76\":1}}],[\"detecting\",{\"1\":{\"84\":1}}],[\"details\",{\"1\":{\"79\":1,\"80\":1}}],[\"detail\",{\"1\":{\"79\":1,\"81\":1}}],[\"dev\",{\"0\":{\"142\":1}}],[\"developers\",{\"1\":{\"82\":2,\"83\":1}}],[\"device\",{\"1\":{\"78\":2}}],[\"debug\",{\"1\":{\"81\":1,\"120\":4,\"129\":1}}],[\"debugging\",{\"0\":{\"81\":1},\"1\":{\"81\":3}}],[\"demand\",{\"1\":{\"81\":1}}],[\"demands\",{\"1\":{\"79\":1}}],[\"democontroller\",{\"1\":{\"3\":1,\"103\":1}}],[\"demo\",{\"1\":{\"3\":2,\"82\":1,\"103\":1}}],[\"demoenum\",{\"1\":{\"3\":1}}],[\"definition\",{\"1\":{\"90\":1,\"120\":3}}],[\"defining\",{\"1\":{\"78\":1}}],[\"defined\",{\"1\":{\"78\":1}}],[\"define\",{\"1\":{\"78\":1}}],[\"defaults\",{\"1\":{\"33\":1}}],[\"default\",{\"1\":{\"3\":2,\"11\":1,\"33\":4,\"78\":1,\"99\":2,\"101\":2,\"103\":7,\"113\":5,\"136\":2}}],[\"db\",{\"1\":{\"3\":1,\"109\":1,\"112\":1,\"113\":1,\"116\":1,\"117\":6,\"118\":1,\"120\":5,\"121\":2}}],[\"未知错误\",{\"1\":{\"110\":1}}],[\"未知\",{\"1\":{\"3\":1}}],[\"30m\",{\"1\":{\"101\":1}}],[\"3003\",{\"1\":{\"79\":2}}],[\"30\",{\"1\":{\"79\":2,\"82\":2}}],[\"3288\",{\"1\":{\"103\":1}}],[\"32\",{\"1\":{\"33\":1,\"136\":1}}],[\"3\",{\"0\":{\"80\":2},\"1\":{\"3\":1,\"14\":1,\"15\":1,\"16\":1,\"27\":1,\"30\":2,\"33\":10,\"96\":1,\"97\":2,\"104\":1,\"105\":1,\"113\":1,\"127\":1,\"134\":1}}],[\"女\",{\"1\":{\"3\":1}}],[\"男\",{\"1\":{\"3\":2}}],[\"123456\",{\"1\":{\"101\":1}}],[\"127\",{\"1\":{\"101\":1}}],[\"121\",{\"1\":{\"91\":2,\"92\":2}}],[\"15\",{\"1\":{\"82\":2}}],[\"1024\",{\"1\":{\"136\":3}}],[\"1024字节\",{\"1\":{\"136\":4}}],[\"1000\",{\"1\":{\"101\":1,\"128\":1}}],[\"10\",{\"1\":{\"76\":2,\"78\":2,\"91\":6}}],[\"17\",{\"1\":{\"75\":1,\"78\":2}}],[\"1111\",{\"1\":{\"33\":2}}],[\"1st\",{\"1\":{\"30\":1}}],[\"1<<30\",{\"1\":{\"16\":1}}],[\"16\",{\"1\":{\"11\":1,\"32\":7,\"33\":4}}],[\"1\",{\"0\":{\"78\":2},\"1\":{\"3\":3,\"14\":3,\"15\":1,\"16\":2,\"26\":2,\"30\":6,\"31\":2,\"32\":1,\"33\":13,\"46\":1,\"75\":1,\"78\":4,\"83\":4,\"97\":1,\"101\":3,\"103\":5,\"104\":1,\"110\":1,\"113\":1,\"115\":1,\"117\":4,\"128\":1,\"132\":1}}],[\"值得一提的是\",{\"1\":{\"125\":1}}],[\"值得庆幸的是\",{\"1\":{\"80\":1}}],[\"值与旧数组长度\",{\"1\":{\"33\":1}}],[\"值跟原数组长度\",{\"1\":{\"33\":1}}],[\"值找到数组下标\",{\"1\":{\"31\":1}}],[\"值并通过该值确定数组下标位置\",{\"1\":{\"14\":1}}],[\"值是否相同且不为\",{\"1\":{\"15\":1}}],[\"值是否相同\",{\"1\":{\"14\":1}}],[\"值和\",{\"1\":{\"14\":1,\"15\":1,\"30\":1}}],[\"值计算数组下标\",{\"1\":{\"14\":1}}],[\"值为枚举的\",{\"1\":{\"3\":1}}],[\"值\",{\"1\":{\"3\":1,\"10\":1,\"14\":1,\"15\":1,\"26\":1,\"30\":2,\"33\":1}}],[\"的整合方式\",{\"1\":{\"138\":1}}],[\"的博客内容\",{\"1\":{\"138\":1}}],[\"的获取是线程安全的\",{\"1\":{\"129\":1}}],[\"的端点路径上\",{\"1\":{\"128\":1}}],[\"的字符串\",{\"1\":{\"128\":1}}],[\"的字段类型处理器中使用\",{\"1\":{\"3\":1}}],[\"的特性\",{\"1\":{\"125\":1}}],[\"的特点便不复存在\",{\"1\":{\"105\":1}}],[\"的请求\",{\"1\":{\"125\":1}}],[\"的请求处理完成\",{\"1\":{\"117\":1}}],[\"的连接\",{\"1\":{\"120\":1}}],[\"的事务机制有关\",{\"1\":{\"120\":1}}],[\"的事务未提交\",{\"1\":{\"117\":1}}],[\"的添加好友请求已处理完毕\",{\"1\":{\"117\":1}}],[\"的缓存删了等于没删\",{\"1\":{\"117\":1}}],[\"的视角来看\",{\"1\":{\"117\":1}}],[\"的查询请求\",{\"1\":{\"117\":1}}],[\"的命令操作标识为\",{\"1\":{\"104\":1}}],[\"的配置就不会去读取了\",{\"1\":{\"103\":1}}],[\"的配置初始化\",{\"1\":{\"103\":1}}],[\"的信息配置都是\",{\"1\":{\"102\":1}}],[\"的相同设置参数\",{\"1\":{\"101\":1}}],[\"的访问次数降到最低\",{\"1\":{\"97\":1}}],[\"的访问令牌都会在短时间内过期\",{\"1\":{\"79\":1}}],[\"的处理一般会采用集群来降低缓存服务的\",{\"1\":{\"97\":1}}],[\"的瓶颈之一在于网络\",{\"1\":{\"97\":1}}],[\"的发生\",{\"1\":{\"97\":1}}],[\"的读取次数\",{\"1\":{\"96\":1}}],[\"的加入目标是降低对\",{\"1\":{\"96\":1}}],[\"的新\",{\"1\":{\"92\":1}}],[\"的自动令牌刷新\",{\"1\":{\"85\":1}}],[\"的原因\",{\"1\":{\"85\":1}}],[\"的原理解析\",{\"1\":{\"34\":1}}],[\"的收入\",{\"1\":{\"82\":1}}],[\"的一方收到消息后\",{\"1\":{\"104\":1}}],[\"的一个特别激烈的例子\",{\"1\":{\"82\":1}}],[\"的一半减1\",{\"1\":{\"16\":1}}],[\"的范围\",{\"1\":{\"82\":1}}],[\"的回调\",{\"1\":{\"79\":1}}],[\"的情况会变得更糟\",{\"1\":{\"79\":1}}],[\"的不同子集\",{\"1\":{\"79\":1}}],[\"的哪个子集与他们相关的想法都略有不同\",{\"1\":{\"78\":1}}],[\"的想法只有最好的\",{\"1\":{\"78\":1}}],[\"的团队似乎也同意这一点\",{\"1\":{\"78\":1}}],[\"的简单第三方访问令牌授权相关吗\",{\"1\":{\"78\":1}}],[\"的工作方式\",{\"1\":{\"78\":1}}],[\"的工作原理\",{\"1\":{\"20\":1}}],[\"的官方网站目前列出了\",{\"1\":{\"78\":1}}],[\"的客户端库\",{\"1\":{\"76\":1}}],[\"的开源服务\",{\"1\":{\"75\":1}}],[\"的构建需要繁琐的批准流程\",{\"1\":{\"75\":1}}],[\"的构造方法\",{\"1\":{\"29\":1}}],[\"的所有内容\",{\"1\":{\"75\":1,\"78\":1}}],[\"的经验得出结论\",{\"1\":{\"75\":1}}],[\"的复杂性\",{\"1\":{\"75\":1}}],[\"的常量值等\",{\"1\":{\"67\":1}}],[\"的设计团队选择把\",{\"1\":{\"66\":1}}],[\"的设值\",{\"1\":{\"16\":1}}],[\"的重点照顾对象\",{\"1\":{\"64\":1}}],[\"的效果\",{\"1\":{\"57\":1}}],[\"的缩写\",{\"1\":{\"56\":1}}],[\"的类\",{\"1\":{\"47\":1}}],[\"的方式\",{\"1\":{\"46\":1}}],[\"的方法区\",{\"1\":{\"39\":1}}],[\"的内存缓存框架\",{\"1\":{\"99\":1}}],[\"的内存模型\",{\"1\":{\"38\":1}}],[\"的内容一直都是仅凭记忆\",{\"1\":{\"71\":1}}],[\"的内部接口\",{\"1\":{\"10\":1}}],[\"的性能提升一文中含有性能测试的结果\",{\"1\":{\"35\":1}}],[\"的哈希值进行\",{\"1\":{\"32\":1}}],[\"的实现\",{\"1\":{\"29\":1}}],[\"的下一节点又变成\",{\"1\":{\"25\":1}}],[\"的几个方法\",{\"1\":{\"24\":1}}],[\"的改变\",{\"0\":{\"23\":1}}],[\"的结构就变为了\",{\"1\":{\"19\":1}}],[\"的key不能为空\",{\"1\":{\"18\":1}}],[\"的区别\",{\"0\":{\"18\":1},\"1\":{\"105\":1}}],[\"的table变量\",{\"1\":{\"16\":1}}],[\"的值为\",{\"1\":{\"16\":1}}],[\"的元素\",{\"1\":{\"15\":2}}],[\"的元素数量\",{\"1\":{\"12\":1}}],[\"的位置\",{\"1\":{\"14\":2}}],[\"的大小以便存放更多的元素\",{\"1\":{\"11\":1}}],[\"的size超过阈值\",{\"1\":{\"11\":1}}],[\"的默认初始容量\",{\"1\":{\"11\":1}}],[\"的幂次方\",{\"1\":{\"11\":1}}],[\"的底层结构是\",{\"1\":{\"10\":1}}],[\"的\",{\"1\":{\"9\":1,\"14\":1,\"15\":1,\"19\":3,\"24\":1,\"30\":1,\"32\":2,\"75\":2,\"99\":2,\"117\":3}}],[\"的源码和原理讲解全部基于\",{\"1\":{\"8\":1}}],[\"的序列化与反序列化功能\",{\"1\":{\"3\":1}}],[\"的枚举\",{\"1\":{\"3\":1}}],[\"中整合\",{\"1\":{\"125\":1,\"139\":1}}],[\"中拷贝\",{\"1\":{\"101\":1}}],[\"中可以针对每一个\",{\"1\":{\"99\":1}}],[\"中拥有分片\",{\"1\":{\"91\":1}}],[\"中为类变量进行初始值设定有两种方式\",{\"1\":{\"46\":1}}],[\"中类的加载到底经历了哪些过程\",{\"1\":{\"38\":1}}],[\"中间存在差值\",{\"1\":{\"27\":1}}],[\"中则是通过构建\",{\"1\":{\"99\":1}}],[\"中则变为node<k\",{\"1\":{\"29\":1}}],[\"中则利用红黑树替代链表\",{\"1\":{\"26\":1}}],[\"中则更改为\",{\"1\":{\"25\":1}}],[\"中已经得到解决\",{\"1\":{\"19\":1}}],[\"中\",{\"0\":{\"23\":1},\"1\":{\"16\":1,\"24\":1,\"26\":2,\"35\":1}}],[\"中是否已存在\",{\"1\":{\"12\":1}}],[\"中枚举字段没有指定\",{\"1\":{\"3\":1}}],[\"中没有值为\",{\"1\":{\"3\":1}}],[\"中提供了字段类型处理器\",{\"1\":{\"3\":1}}],[\"类和接口的全限定名\",{\"1\":{\"67\":1}}],[\"类初始化其实是执行类构造器方法的过程\",{\"1\":{\"46\":1}}],[\"类方法\",{\"1\":{\"45\":1}}],[\"类的\",{\"1\":{\"67\":1}}],[\"类的数据全部都存放在\",{\"1\":{\"39\":1}}],[\"类的加载机制\",{\"1\":{\"57\":1}}],[\"类的加载过程\",{\"0\":{\"40\":1}}],[\"类的加载的最终结果是位于堆区中的\",{\"1\":{\"39\":1}}],[\"类的加载指的是将类的\",{\"1\":{\"39\":1}}],[\"类加载经过\",{\"1\":{\"47\":1}}],[\"类加载过程\",{\"1\":{\"40\":1}}],[\"类加载主要经历五个部分\",{\"1\":{\"40\":1}}],[\"类加载器先从缓存区寻找该\",{\"1\":{\"48\":1}}],[\"类加载器\",{\"0\":{\"47\":1},\"1\":{\"41\":1,\"47\":1}}],[\"类加载器必须在程序首次主动使用该类时才报告错误\",{\"1\":{\"39\":1}}],[\"类加载器并不需要等到某个类被\",{\"1\":{\"39\":1}}],[\"类加载完毕后\",{\"1\":{\"39\":1}}],[\"类加载\",{\"1\":{\"39\":1}}],[\"类加载机制\",{\"0\":{\"38\":1},\"1\":{\"38\":1,\"39\":1,\"50\":1}}],[\"类中对它有一个静态实现\",{\"1\":{\"10\":1}}],[\"类图\",{\"1\":{\"9\":1}}],[\"类图如下\",{\"1\":{\"9\":1}}],[\"类型转化器创建好后\",{\"1\":{\"3\":1}}],[\"类型\",{\"1\":{\"3\":1}}],[\"类\",{\"1\":{\"3\":1}}],[\"f\",{\"1\":{\"117\":11}}],[\"flush\",{\"1\":{\"110\":1}}],[\"flows\",{\"0\":{\"81\":1},\"1\":{\"80\":1,\"81\":3,\"82\":1,\"85\":1}}],[\"flow\",{\"1\":{\"78\":1,\"80\":1,\"81\":1,\"82\":1,\"84\":2}}],[\"float\",{\"1\":{\"11\":1,\"33\":3}}],[\"fse\",{\"1\":{\"101\":1}}],[\"fst\",{\"1\":{\"101\":1}}],[\"full\",{\"1\":{\"78\":2}}],[\"funny\",{\"1\":{\"77\":1}}],[\"feedback\",{\"1\":{\"85\":1}}],[\"feels\",{\"1\":{\"78\":1}}],[\"fetch\",{\"1\":{\"80\":1}}],[\"features\",{\"1\":{\"80\":1}}],[\"few\",{\"1\":{\"78\":1,\"79\":1,\"82\":1}}],[\"female\",{\"1\":{\"3\":1}}],[\"foundation\",{\"1\":{\"125\":1}}],[\"focus\",{\"1\":{\"78\":1}}],[\"footguns\",{\"1\":{\"77\":1}}],[\"forward\",{\"1\":{\"92\":1}}],[\"forwards\",{\"1\":{\"91\":1}}],[\"forcing\",{\"1\":{\"80\":1}}],[\"forced\",{\"1\":{\"79\":1}}],[\"forms\",{\"1\":{\"82\":1}}],[\"form\",{\"1\":{\"79\":2}}],[\"format\",{\"1\":{\"3\":3}}],[\"forname\",{\"1\":{\"46\":2}}],[\"for\",{\"1\":{\"3\":1,\"14\":1,\"15\":1,\"16\":1,\"25\":1,\"30\":3,\"33\":2,\"76\":3,\"77\":1,\"78\":9,\"79\":9,\"80\":7,\"81\":4,\"82\":7,\"83\":4,\"85\":2,\"89\":2,\"91\":7,\"92\":3,\"120\":2}}],[\"frontend\",{\"1\":{\"79\":1}}],[\"from\",{\"1\":{\"33\":1,\"64\":1,\"78\":2,\"80\":1,\"81\":1,\"82\":3,\"83\":1,\"120\":1}}],[\"fromcode\",{\"1\":{\"3\":4}}],[\"frank\",{\"1\":{\"70\":1}}],[\"framework\",{\"0\":{\"147\":1},\"1\":{\"78\":1}}],[\"frame\",{\"0\":{\"61\":1},\"1\":{\"60\":1}}],[\"ft\",{\"1\":{\"33\":3}}],[\"fallbackexecution\",{\"1\":{\"113\":1}}],[\"false\",{\"1\":{\"30\":2,\"46\":1,\"101\":3,\"113\":1,\"120\":2}}],[\"fastjson\",{\"1\":{\"101\":1}}],[\"fail\",{\"1\":{\"83\":1,\"92\":1,\"117\":1}}],[\"fair\",{\"1\":{\"82\":2}}],[\"far\",{\"1\":{\"80\":1,\"85\":1}}],[\"famous\",{\"1\":{\"78\":1}}],[\"facilitate\",{\"1\":{\"91\":1}}],[\"fact\",{\"1\":{\"79\":1,\"91\":1}}],[\"factor\",{\"1\":{\"33\":1,\"83\":1,\"92\":1}}],[\"facebook\",{\"1\":{\"77\":2}}],[\"fill\",{\"1\":{\"82\":1}}],[\"filedtype\",{\"1\":{\"3\":1}}],[\"fitbit\",{\"1\":{\"79\":2}}],[\"fixed\",{\"1\":{\"79\":1}}],[\"first\",{\"1\":{\"31\":9,\"78\":1,\"81\":2,\"91\":2}}],[\"fine\",{\"1\":{\"80\":1}}],[\"finding\",{\"1\":{\"80\":1}}],[\"find\",{\"1\":{\"79\":1,\"80\":1}}],[\"findfield\",{\"1\":{\"3\":1}}],[\"final\",{\"1\":{\"3\":3,\"10\":1,\"11\":2,\"15\":1,\"27\":2,\"29\":3,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"44\":1,\"67\":1,\"101\":1,\"128\":2}}],[\"fieldtype\",{\"1\":{\"3\":3}}],[\"field\",{\"1\":{\"3\":4,\"33\":1,\"45\":1}}],[\"fieldname\",{\"1\":{\"3\":2}}],[\"=>\",{\"1\":{\"3\":2,\"134\":4}}],[\"=\",{\"1\":{\"3\":21,\"10\":4,\"11\":1,\"14\":14,\"15\":7,\"16\":16,\"25\":8,\"27\":2,\"29\":4,\"30\":20,\"31\":14,\"32\":1,\"33\":43,\"44\":2,\"101\":20,\"102\":3,\"103\":5,\"112\":2,\"113\":7,\"119\":2,\"120\":6,\"128\":8,\"134\":5,\"135\":4}}],[\"============\",{\"1\":{\"103\":2}}],[\"==\",{\"1\":{\"3\":6,\"14\":3,\"15\":5,\"16\":2,\"25\":1,\"30\":9,\"31\":5,\"32\":1,\"33\":6}}],[\"normal\",{\"1\":{\"128\":1}}],[\"nor\",{\"1\":{\"91\":1}}],[\"nontrivial\",{\"1\":{\"82\":1}}],[\"nonstandard\",{\"0\":{\"80\":1},\"1\":{\"77\":1,\"80\":2}}],[\"no\",{\"1\":{\"79\":1,\"83\":1,\"84\":1}}],[\"now\",{\"1\":{\"78\":3,\"79\":1,\"82\":1,\"83\":1,\"84\":1}}],[\"nothing\",{\"1\":{\"92\":2}}],[\"notorious\",{\"1\":{\"82\":1}}],[\"notion\",{\"1\":{\"79\":6,\"82\":2}}],[\"note\",{\"1\":{\"78\":1}}],[\"not\",{\"0\":{\"84\":1,\"90\":1},\"1\":{\"78\":3,\"80\":1,\"81\":1,\"84\":1,\"89\":1,\"90\":1,\"91\":1,\"92\":2,\"120\":1}}],[\"node4\",{\"1\":{\"92\":2}}],[\"node1\",{\"1\":{\"92\":6}}],[\"nodes\",{\"1\":{\"92\":8}}],[\"node\",{\"1\":{\"29\":1,\"31\":1,\"33\":1,\"92\":3}}],[\"node<k\",{\"0\":{\"29\":1},\"1\":{\"29\":8,\"30\":3,\"31\":4,\"33\":8}}],[\"nango\",{\"1\":{\"75\":1,\"85\":2}}],[\"native\",{\"1\":{\"59\":1,\"60\":1,\"63\":1}}],[\"names\",{\"1\":{\"91\":1}}],[\"name\",{\"1\":{\"3\":10}}],[\"npe\",{\"1\":{\"18\":1,\"101\":1}}],[\"n\",{\"1\":{\"10\":2,\"26\":4,\"30\":4,\"31\":3,\"32\":3,\"33\":4}}],[\"necessary\",{\"1\":{\"120\":1}}],[\"never\",{\"1\":{\"83\":1}}],[\"netty\",{\"1\":{\"101\":1,\"117\":2}}],[\"net\",{\"1\":{\"82\":1,\"104\":1}}],[\"neat\",{\"1\":{\"80\":1}}],[\"needed\",{\"1\":{\"84\":1,\"91\":1}}],[\"needs\",{\"1\":{\"79\":1,\"92\":1}}],[\"need\",{\"1\":{\"78\":3,\"79\":2,\"80\":7,\"82\":1,\"84\":2}}],[\"next\",{\"1\":{\"10\":3,\"14\":1,\"15\":1,\"16\":5,\"19\":2,\"25\":5,\"29\":8,\"30\":4,\"31\":2,\"33\":9}}],[\"newcon\",{\"1\":{\"120\":3}}],[\"newcap\",{\"1\":{\"33\":8}}],[\"newcapacity\",{\"1\":{\"16\":6,\"25\":2}}],[\"newsize\",{\"1\":{\"68\":1}}],[\"newinstance\",{\"1\":{\"39\":1}}],[\"newtab\",{\"1\":{\"33\":7}}],[\"newtable\",{\"1\":{\"16\":7,\"25\":4}}],[\"newthr\",{\"1\":{\"33\":6}}],[\"newnode\",{\"1\":{\"30\":2}}],[\"new\",{\"1\":{\"3\":4,\"14\":1,\"16\":1,\"33\":2,\"46\":1,\"83\":2,\"91\":1,\"92\":1,\"101\":1,\"102\":1,\"103\":2,\"112\":2,\"113\":1,\"120\":1,\"128\":3,\"133\":1,\"134\":1}}],[\"nuances\",{\"1\":{\"92\":1}}],[\"numerous\",{\"1\":{\"92\":1}}],[\"number\",{\"1\":{\"3\":2,\"82\":1,\"83\":1}}],[\"null\",{\"1\":{\"3\":12,\"14\":7,\"15\":11,\"16\":2,\"18\":1,\"25\":2,\"30\":10,\"31\":9,\"32\":1,\"33\":17,\"101\":3,\"120\":1}}],[\">=\",{\"1\":{\"14\":1,\"16\":1,\"30\":2,\"33\":2}}],[\">>>\",{\"1\":{\"32\":2}}],[\">>\",{\"1\":{\"3\":1}}],[\">\",{\"1\":{\"3\":7,\"30\":1,\"31\":1,\"33\":2,\"134\":3}}],[\"md\",{\"1\":{\"101\":1}}],[\"mysql\",{\"1\":{\"89\":2,\"91\":2,\"105\":1}}],[\"myshopify\",{\"1\":{\"79\":2}}],[\"my\",{\"1\":{\"79\":2}}],[\"mybatis\",{\"1\":{\"3\":6}}],[\"mybatisplus\",{\"0\":{\"3\":1}}],[\"multi\",{\"1\":{\"92\":1}}],[\"multiple\",{\"1\":{\"90\":1,\"92\":1}}],[\"much\",{\"1\":{\"78\":1,\"82\":1,\"92\":1}}],[\"mustrestoreautocommit\",{\"1\":{\"120\":2}}],[\"must\",{\"1\":{\"33\":1,\"79\":1,\"85\":1,\"91\":1}}],[\"memcache\",{\"1\":{\"97\":1}}],[\"memcached\",{\"1\":{\"96\":1}}],[\"merits\",{\"1\":{\"92\":1}}],[\"me\",{\"1\":{\"81\":1}}],[\"mean\",{\"1\":{\"80\":1,\"92\":1}}],[\"meanwhile\",{\"1\":{\"79\":1}}],[\"meaning\",{\"1\":{\"78\":1}}],[\"messagebuffertext\",{\"1\":{\"136\":1}}],[\"messagebufferbinary\",{\"1\":{\"136\":1}}],[\"message\",{\"1\":{\"81\":1,\"128\":4,\"132\":1}}],[\"messages\",{\"1\":{\"81\":3}}],[\"mess\",{\"1\":{\"76\":1}}],[\"metaspacesize\",{\"1\":{\"68\":1}}],[\"metaspace\",{\"1\":{\"66\":1}}],[\"methodmapping\",{\"1\":{\"128\":1}}],[\"method\",{\"1\":{\"45\":1,\"90\":1,\"113\":1}}],[\"moving\",{\"0\":{\"83\":1}}],[\"move\",{\"1\":{\"33\":1,\"78\":1}}],[\"mongodb\",{\"1\":{\"89\":1,\"91\":2}}],[\"monetized\",{\"1\":{\"82\":1}}],[\"months\",{\"1\":{\"82\":2}}],[\"more\",{\"1\":{\"78\":1,\"80\":2,\"82\":2,\"83\":1,\"85\":1,\"92\":1}}],[\"model\",{\"1\":{\"79\":2,\"83\":1}}],[\"models\",{\"1\":{\"78\":1}}],[\"mode参数并要求你始终将其设置为查询\",{\"1\":{\"79\":1}}],[\"mode\",{\"1\":{\"79\":1,\"101\":1}}],[\"modcount++\",{\"1\":{\"14\":1}}],[\"modcount\",{\"1\":{\"11\":1}}],[\"most\",{\"1\":{\"76\":1,\"77\":1,\"78\":2,\"79\":2,\"82\":2}}],[\"mild\",{\"1\":{\"82\":1}}],[\"mistake\",{\"1\":{\"81\":1}}],[\"missed\",{\"1\":{\"81\":1}}],[\"missing\",{\"1\":{\"81\":1,\"84\":1}}],[\"misc\",{\"1\":{\"16\":1}}],[\"microsoft\",{\"1\":{\"77\":2,\"79\":1}}],[\"might\",{\"1\":{\"76\":1,\"85\":1,\"92\":2}}],[\"mind\",{\"1\":{\"78\":1,\"79\":1}}],[\"minutes\",{\"1\":{\"76\":1,\"79\":1}}],[\"min\",{\"1\":{\"16\":1}}],[\"main\",{\"1\":{\"134\":1,\"136\":1}}],[\"maintain\",{\"1\":{\"92\":1}}],[\"making\",{\"1\":{\"92\":1}}],[\"make\",{\"1\":{\"79\":1,\"82\":1,\"83\":2}}],[\"marketplace\",{\"1\":{\"82\":2}}],[\"match\",{\"1\":{\"81\":1,\"84\":1}}],[\"math\",{\"1\":{\"16\":1}}],[\"may\",{\"1\":{\"79\":1}}],[\"mandatory\",{\"1\":{\"83\":2}}],[\"manual\",{\"1\":{\"82\":1,\"120\":2}}],[\"many\",{\"0\":{\"80\":1},\"1\":{\"78\":1,\"79\":1,\"80\":2,\"82\":2}}],[\"manage\",{\"1\":{\"76\":1,\"92\":2}}],[\"mac\",{\"1\":{\"57\":1}}],[\"machine\",{\"1\":{\"56\":1}}],[\"maxmessagesize\",{\"1\":{\"128\":1}}],[\"maxmetaspacesize\",{\"1\":{\"68\":1}}],[\"maxpermsize\",{\"1\":{\"68\":1}}],[\"maxnewsize\",{\"1\":{\"68\":1}}],[\"max\",{\"1\":{\"16\":2,\"33\":2}}],[\"maximum\",{\"1\":{\"16\":3,\"33\":4}}],[\"map<string\",{\"1\":{\"128\":2}}],[\"maps\",{\"1\":{\"91\":3}}],[\"mapping\",{\"1\":{\"30\":1,\"128\":2}}],[\"map\",{\"1\":{\"8\":2,\"9\":1,\"10\":2,\"29\":1}}],[\"male\",{\"1\":{\"3\":1}}],[\"msg\",{\"1\":{\"3\":1}}],[\"mp\",{\"1\":{\"3\":1}}],[\"该区默认大小即为default\",{\"1\":{\"136\":1}}],[\"该区域不会抛出\",{\"1\":{\"67\":1}}],[\"该请求处理步骤如下\",{\"1\":{\"117\":1}}],[\"该对象保存了\",{\"1\":{\"104\":1}}],[\"该缓存框架主要用于集群环境中\",{\"1\":{\"96\":1}}],[\"该所有者可能是\",{\"1\":{\"92\":1}}],[\"该架构没有像协调器这样的单一组件\",{\"1\":{\"92\":1}}],[\"该组件可以有各种名称\",{\"1\":{\"91\":1}}],[\"该过程似乎很简单\",{\"1\":{\"83\":1}}],[\"该时间段可以由用户自定义\",{\"1\":{\"80\":1}}],[\"该\",{\"1\":{\"48\":1}}],[\"该类也就是红黑树节点对象\",{\"1\":{\"29\":1}}],[\"该类提供了四个可供开发者实现的钩子方法\",{\"1\":{\"3\":1}}],[\"该类提供了对引用泛型类型的转化\",{\"1\":{\"3\":1}}],[\"该方法必须要有一个throwable对象来表示发生的异常\",{\"1\":{\"131\":1}}],[\"该方法将\",{\"1\":{\"3\":1}}],[\"该方法会在\",{\"1\":{\"3\":1}}],[\"ee\",{\"1\":{\"125\":4}}],[\"ehcache\",{\"1\":{\"96\":2,\"97\":2,\"99\":2}}],[\"establish\",{\"1\":{\"92\":1}}],[\"easily\",{\"1\":{\"83\":1}}],[\"easy\",{\"1\":{\"82\":1}}],[\"each\",{\"1\":{\"33\":1,\"78\":1,\"80\":2,\"91\":2,\"92\":3}}],[\"eu\",{\"1\":{\"79\":2}}],[\"europeans\",{\"1\":{\"79\":1}}],[\"evolved\",{\"1\":{\"83\":1}}],[\"event\",{\"1\":{\"119\":3}}],[\"eventlistener\",{\"1\":{\"113\":3}}],[\"even\",{\"1\":{\"79\":1,\"80\":2,\"82\":1,\"90\":1,\"91\":1,\"92\":1}}],[\"everybody\",{\"0\":{\"79\":1},\"1\":{\"78\":1,\"80\":1,\"82\":1}}],[\"everything\",{\"1\":{\"78\":1,\"79\":1}}],[\"every\",{\"1\":{\"77\":2,\"79\":2,\"80\":2,\"81\":1,\"82\":1,\"83\":2,\"91\":1}}],[\"evict\",{\"1\":{\"30\":2,\"103\":1}}],[\"etc\",{\"1\":{\"77\":1}}],[\"employ\",{\"1\":{\"92\":2}}],[\"employs\",{\"1\":{\"80\":1}}],[\"emptywrapper\",{\"1\":{\"3\":1}}],[\"email\",{\"1\":{\"76\":1,\"82\":1}}],[\"eclipse\",{\"1\":{\"68\":1,\"125\":3}}],[\"eden\",{\"1\":{\"64\":2}}],[\"either\",{\"1\":{\"33\":1}}],[\"elementtype\",{\"1\":{\"113\":2}}],[\"elements\",{\"1\":{\"33\":1}}],[\"elasticsearch\",{\"1\":{\"89\":1}}],[\"else\",{\"1\":{\"3\":2,\"30\":3,\"33\":8,\"80\":1,\"82\":1,\"119\":1}}],[\"e\",{\"1\":{\"14\":13,\"15\":7,\"16\":10,\"25\":10,\"30\":13,\"31\":10,\"33\":19,\"134\":8}}],[\"environments\",{\"1\":{\"91\":1}}],[\"encryption\",{\"1\":{\"84\":1}}],[\"encoders等属性可以定义子协议\",{\"1\":{\"128\":1}}],[\"encoded\",{\"1\":{\"79\":3}}],[\"encountered\",{\"1\":{\"80\":1}}],[\"enter\",{\"1\":{\"79\":1,\"82\":1}}],[\"entry<>\",{\"1\":{\"14\":1}}],[\"entry<k\",{\"1\":{\"10\":9,\"11\":1,\"14\":2,\"15\":3,\"16\":2,\"20\":1,\"25\":2,\"29\":7}}],[\"entryset\",{\"1\":{\"12\":1}}],[\"entry\",{\"1\":{\"10\":2,\"11\":1,\"14\":3,\"15\":3,\"16\":4,\"19\":2,\"25\":1,\"29\":1}}],[\"ending\",{\"1\":{\"83\":1}}],[\"endpointconfig\",{\"1\":{\"128\":3,\"135\":2}}],[\"endpoint\",{\"1\":{\"80\":1}}],[\"end\",{\"1\":{\"78\":1,\"82\":1}}],[\"enumdto\",{\"1\":{\"3\":2}}],[\"enumhelperjsondeserializer\",{\"1\":{\"3\":1}}],[\"enumhelperjsondeserializer<e\",{\"1\":{\"3\":1}}],[\"enumhelperjsonserializer\",{\"1\":{\"3\":2}}],[\"enumhelpertypehandler\",{\"1\":{\"3\":3}}],[\"enums\",{\"1\":{\"3\":1}}],[\"enum\",{\"1\":{\"3\":2}}],[\"enumconverttest\",{\"1\":{\"3\":1}}],[\"enumconv\",{\"1\":{\"3\":1}}],[\"enumconstant\",{\"1\":{\"3\":3}}],[\"enumconstants\",{\"1\":{\"3\":2}}],[\"enumcls\",{\"1\":{\"3\":4}}],[\"enum<e>>\",{\"1\":{\"3\":4}}],[\"ex\",{\"1\":{\"120\":3}}],[\"exist\",{\"1\":{\"91\":1}}],[\"existing\",{\"1\":{\"30\":1}}],[\"exceed\",{\"1\":{\"82\":1}}],[\"except\",{\"1\":{\"79\":1}}],[\"exception\",{\"0\":{\"62\":1,\"65\":1},\"1\":{\"61\":1,\"112\":1,\"113\":1}}],[\"exporter\",{\"1\":{\"133\":2}}],[\"exposed\",{\"1\":{\"120\":1}}],[\"explicitly\",{\"1\":{\"120\":1}}],[\"exploring\",{\"1\":{\"91\":1,\"92\":1}}],[\"expensive\",{\"1\":{\"120\":1}}],[\"expect\",{\"1\":{\"83\":1}}],[\"experience\",{\"0\":{\"142\":1},\"1\":{\"77\":1,\"78\":1}}],[\"expiring\",{\"1\":{\"83\":1}}],[\"expiration\",{\"1\":{\"80\":1,\"83\":1}}],[\"expired\",{\"1\":{\"84\":1}}],[\"expires\",{\"1\":{\"83\":1}}],[\"expire\",{\"1\":{\"79\":1,\"80\":2,\"83\":1}}],[\"expansion\",{\"1\":{\"33\":1}}],[\"ext\",{\"1\":{\"47\":2}}],[\"extensions\",{\"0\":{\"80\":1},\"1\":{\"77\":1,\"80\":1}}],[\"extension\",{\"1\":{\"47\":1}}],[\"extends\",{\"1\":{\"3\":8,\"29\":2,\"112\":1,\"113\":1}}],[\"execute\",{\"1\":{\"92\":1}}],[\"exe\",{\"1\":{\"46\":1}}],[\"examples\",{\"1\":{\"78\":1,\"82\":1}}],[\"example\",{\"1\":{\"3\":2,\"81\":1,\"82\":1,\"91\":1,\"92\":1,\"120\":1}}],[\"error\",{\"1\":{\"3\":1,\"81\":6,\"134\":1}}],[\"equalsignorecase\",{\"1\":{\"128\":1}}],[\"equals\",{\"1\":{\"3\":1,\"14\":1,\"15\":1,\"20\":1,\"26\":1,\"30\":3,\"31\":3}}],[\"枚举的code值\",{\"1\":{\"3\":1}}],[\"枚举内容\",{\"1\":{\"3\":1}}],[\"枚举代码\",{\"1\":{\"3\":1}}],[\"枚举无法继承\",{\"1\":{\"3\":1}}],[\"枚举字典的巧用\",{\"0\":{\"1\":1}}],[\"首次主动使用\",{\"1\":{\"39\":1}}],[\"首次建立个人博客\",{\"1\":{\"0\":1}}],[\"首先与服务端点建立\",{\"1\":{\"134\":1}}],[\"首先创建一个服务器端点\",{\"1\":{\"128\":1}}],[\"首先创建一个枚举接口\",{\"1\":{\"3\":1}}],[\"首先创建\",{\"1\":{\"127\":1}}],[\"首先\",{\"1\":{\"91\":1}}],[\"首先用链表存储\",{\"1\":{\"27\":1}}],[\"rollbackfor\",{\"1\":{\"112\":1,\"113\":1}}],[\"rocketmq\",{\"1\":{\"104\":1}}],[\"route\",{\"1\":{\"91\":1,\"92\":1}}],[\"router\",{\"1\":{\"91\":1}}],[\"runtime\",{\"1\":{\"113\":1}}],[\"runtimeexception\",{\"1\":{\"3\":1}}],[\"runs\",{\"1\":{\"84\":1}}],[\"run\",{\"1\":{\"83\":1,\"136\":1}}],[\"rise\",{\"1\":{\"83\":1}}],[\"ripple\",{\"1\":{\"82\":1}}],[\"rippling\",{\"1\":{\"82\":1}}],[\"right\",{\"1\":{\"29\":1,\"76\":1,\"78\":1}}],[\"rfcs\",{\"1\":{\"78\":2}}],[\"rfc\",{\"1\":{\"75\":2,\"78\":2}}],[\"rt\",{\"1\":{\"47\":1}}],[\"rabbitmq\",{\"1\":{\"104\":1}}],[\"rather\",{\"1\":{\"83\":1}}],[\"ramp\",{\"1\":{\"82\":2}}],[\"random\",{\"1\":{\"81\":1}}],[\"randall\",{\"1\":{\"81\":2}}],[\"radical\",{\"1\":{\"79\":1}}],[\"rawtypes\",{\"1\":{\"33\":1}}],[\"race\",{\"1\":{\"19\":1,\"83\":1,\"84\":1}}],[\"reprint\",{\"0\":{\"145\":1}}],[\"replicate\",{\"1\":{\"92\":1}}],[\"replication\",{\"1\":{\"92\":1}}],[\"req\",{\"1\":{\"117\":11}}],[\"requires\",{\"1\":{\"82\":2}}],[\"require\",{\"1\":{\"79\":1,\"81\":1,\"82\":4,\"83\":1}}],[\"requestparametermap\",{\"1\":{\"128\":2}}],[\"requested\",{\"1\":{\"84\":2}}],[\"request\",{\"0\":{\"81\":2},\"1\":{\"79\":3,\"80\":1,\"81\":1,\"83\":1,\"91\":2,\"92\":1,\"117\":4}}],[\"requests\",{\"1\":{\"78\":1,\"80\":1,\"82\":1,\"83\":1,\"91\":2,\"92\":2}}],[\"requestbody\",{\"1\":{\"3\":1}}],[\"requestmapping\",{\"1\":{\"3\":1,\"103\":1}}],[\"retentionpolicy\",{\"1\":{\"113\":1}}],[\"retention\",{\"1\":{\"113\":1}}],[\"returned\",{\"1\":{\"80\":1}}],[\"return\",{\"1\":{\"3\":13,\"14\":4,\"15\":4,\"16\":1,\"30\":3,\"31\":5,\"32\":1,\"33\":2,\"80\":1,\"101\":1,\"102\":1,\"110\":1,\"128\":1,\"133\":2}}],[\"region\",{\"0\":{\"99\":1},\"1\":{\"99\":7,\"101\":2,\"103\":2,\"104\":2}}],[\"registersynchronization\",{\"1\":{\"112\":2}}],[\"register\",{\"1\":{\"79\":2,\"82\":1}}],[\"rebalances\",{\"1\":{\"92\":1}}],[\"releaseconnection\",{\"1\":{\"120\":2}}],[\"releasing\",{\"1\":{\"120\":1}}],[\"relevant\",{\"1\":{\"78\":3}}],[\"rely\",{\"1\":{\"92\":1}}],[\"relative\",{\"1\":{\"83\":1}}],[\"revoke\",{\"1\":{\"84\":1}}],[\"revoked\",{\"1\":{\"83\":1,\"84\":1}}],[\"reversible\",{\"1\":{\"84\":1}}],[\"revenue\",{\"1\":{\"82\":2}}],[\"review\",{\"1\":{\"82\":3}}],[\"reviews\",{\"1\":{\"82\":3}}],[\"record\",{\"1\":{\"91\":3,\"92\":4}}],[\"recordaccess\",{\"1\":{\"14\":1}}],[\"recommended\",{\"1\":{\"81\":1}}],[\"received\",{\"1\":{\"80\":1}}],[\"remoteendpoint\",{\"1\":{\"128\":1}}],[\"remove\",{\"1\":{\"12\":1,\"120\":1}}],[\"remains\",{\"1\":{\"91\":1}}],[\"remind\",{\"1\":{\"79\":1}}],[\"remember\",{\"1\":{\"79\":1}}],[\"reinvent\",{\"1\":{\"79\":1}}],[\"refreshing\",{\"1\":{\"84\":1}}],[\"refreshes\",{\"1\":{\"83\":1,\"85\":1}}],[\"refresh\",{\"1\":{\"78\":1,\"79\":1,\"83\":10,\"84\":1}}],[\"reflectionutils\",{\"1\":{\"3\":1}}],[\"re\",{\"1\":{\"78\":2,\"80\":1,\"81\":2,\"82\":4,\"83\":2,\"84\":1,\"85\":1,\"91\":1,\"92\":1}}],[\"reason=$\",{\"1\":{\"134\":1}}],[\"reason=\",{\"1\":{\"128\":1}}],[\"reasons\",{\"1\":{\"81\":1}}],[\"reason\",{\"1\":{\"80\":1,\"128\":2,\"134\":1}}],[\"realm\",{\"1\":{\"92\":1}}],[\"realmid\",{\"1\":{\"80\":3}}],[\"realize\",{\"1\":{\"83\":1}}],[\"reality\",{\"1\":{\"77\":1,\"83\":1}}],[\"really\",{\"1\":{\"79\":2,\"80\":1}}],[\"real\",{\"1\":{\"77\":1}}],[\"readbuffer\",{\"1\":{\"136\":2}}],[\"readonly\",{\"1\":{\"110\":1}}],[\"readme\",{\"1\":{\"101\":1}}],[\"reading\",{\"1\":{\"85\":1}}],[\"ready\",{\"1\":{\"78\":1,\"82\":1}}],[\"read\",{\"1\":{\"76\":1,\"78\":1,\"79\":1,\"85\":1}}],[\"redundant\",{\"1\":{\"92\":1}}],[\"redisconnection\",{\"1\":{\"101\":1}}],[\"redis\",{\"1\":{\"89\":1,\"96\":2,\"97\":6,\"99\":1,\"101\":19,\"103\":2,\"104\":3,\"105\":3,\"117\":1},\"2\":{\"107\":1}}],[\"redirects\",{\"1\":{\"79\":1}}],[\"redirect\",{\"1\":{\"79\":1}}],[\"red\",{\"1\":{\"29\":1}}],[\"rehash\",{\"1\":{\"16\":4,\"25\":3}}],[\"rehashing\",{\"1\":{\"16\":1}}],[\"reset\",{\"1\":{\"120\":1}}],[\"resetconnectionaftertransaction\",{\"1\":{\"120\":1}}],[\"resume\",{\"1\":{\"110\":1}}],[\"results\",{\"1\":{\"81\":1}}],[\"resultset\",{\"1\":{\"3\":4}}],[\"result\",{\"1\":{\"77\":1}}],[\"resultvo\",{\"1\":{\"3\":7}}],[\"responsible\",{\"1\":{\"91\":1}}],[\"response\",{\"1\":{\"79\":1,\"80\":2}}],[\"restrictions\",{\"1\":{\"83\":1}}],[\"restcontroller\",{\"1\":{\"3\":1,\"103\":1,\"112\":1,\"113\":1}}],[\"resides\",{\"1\":{\"79\":1}}],[\"resize\",{\"0\":{\"16\":1,\"33\":1},\"1\":{\"14\":1,\"16\":1,\"24\":1,\"30\":2,\"33\":1}}],[\"resources下创建public目录\",{\"1\":{\"134\":1}}],[\"resources\",{\"1\":{\"101\":1}}],[\"resource\",{\"1\":{\"3\":1,\"78\":1,\"103\":1,\"113\":1}}],[\"rs\",{\"1\":{\"3\":6}}],[\"ssl\",{\"1\":{\"101\":1}}],[\"s|m|h|d\",{\"1\":{\"101\":1}}],[\"scaling\",{\"1\":{\"92\":1}}],[\"scalability\",{\"1\":{\"90\":1}}],[\"schema\",{\"1\":{\"91\":1}}],[\"script>\",{\"1\":{\"134\":1}}],[\"scratched\",{\"1\":{\"84\":1}}],[\"screening\",{\"1\":{\"82\":1}}],[\"scopes\",{\"1\":{\"79\":1,\"80\":6,\"81\":3,\"82\":1,\"84\":4}}],[\"scope\",{\"1\":{\"78\":1,\"79\":3}}],[\"skipping\",{\"1\":{\"80\":1}}],[\"smart\",{\"1\":{\"80\":1}}],[\"small\",{\"1\":{\"78\":1,\"80\":1}}],[\"smallint\",{\"1\":{\"3\":1}}],[\"slightly\",{\"1\":{\"78\":1}}],[\"slack\",{\"1\":{\"77\":2,\"79\":2,\"80\":4,\"85\":2}}],[\"spel\",{\"1\":{\"113\":1}}],[\"specifically\",{\"1\":{\"80\":1}}],[\"specific\",{\"1\":{\"79\":1,\"91\":1}}],[\"special\",{\"1\":{\"78\":1}}],[\"springapplication\",{\"1\":{\"136\":1}}],[\"springcontext\",{\"1\":{\"135\":3}}],[\"springframework\",{\"1\":{\"127\":1}}],[\"spring\",{\"0\":{\"108\":1,\"148\":1},\"1\":{\"117\":1,\"120\":5,\"121\":1,\"125\":3,\"127\":1,\"134\":1,\"135\":4,\"138\":1,\"139\":1},\"2\":{\"122\":1,\"123\":1,\"140\":1,\"141\":1}}],[\"springbootapplication\",{\"1\":{\"136\":1}}],[\"springboot\",{\"1\":{\"103\":1}}],[\"spanner\",{\"1\":{\"89\":1,\"92\":2}}],[\"splits\",{\"1\":{\"92\":1}}],[\"splitting\",{\"1\":{\"90\":1,\"92\":1}}],[\"split\",{\"1\":{\"33\":3}}],[\"sole\",{\"1\":{\"91\":1}}],[\"solution\",{\"1\":{\"91\":1}}],[\"solutions\",{\"0\":{\"91\":1},\"1\":{\"79\":1,\"91\":2,\"92\":3}}],[\"source\",{\"1\":{\"85\":1,\"103\":2,\"113\":3}}],[\"somewhere\",{\"1\":{\"80\":1}}],[\"something\",{\"1\":{\"79\":1,\"81\":1,\"119\":2,\"128\":1}}],[\"somebody\",{\"1\":{\"79\":1}}],[\"some\",{\"0\":{\"84\":1},\"1\":{\"78\":1,\"79\":2,\"80\":2,\"81\":2,\"82\":7,\"83\":7,\"84\":1,\"92\":1,\"120\":1}}],[\"so\",{\"1\":{\"77\":1,\"78\":2,\"79\":1,\"80\":1,\"81\":1,\"84\":2,\"120\":1}}],[\"save\",{\"1\":{\"112\":1,\"113\":1}}],[\"sadly\",{\"1\":{\"84\":1}}],[\"sane\",{\"1\":{\"82\":1}}],[\"sake\",{\"1\":{\"80\":1}}],[\"safe\",{\"1\":{\"80\":1}}],[\"say\",{\"1\":{\"78\":1}}],[\"salesforce\",{\"1\":{\"77\":2,\"78\":2,\"80\":6,\"83\":2}}],[\"same\",{\"1\":{\"33\":1,\"80\":1}}],[\"shard\",{\"1\":{\"91\":3,\"92\":4}}],[\"shards\",{\"1\":{\"89\":1,\"90\":1,\"91\":3,\"92\":1}}],[\"sharding\",{\"0\":{\"91\":1},\"1\":{\"89\":2,\"90\":2,\"91\":3,\"92\":5}}],[\"sharded\",{\"0\":{\"90\":1},\"1\":{\"89\":2,\"90\":1,\"91\":2,\"92\":1,\"101\":1}}],[\"shared\",{\"1\":{\"92\":2}}],[\"share\",{\"1\":{\"82\":1,\"85\":1}}],[\"short\",{\"1\":{\"79\":1}}],[\"shortvalue\",{\"1\":{\"3\":1}}],[\"should\",{\"1\":{\"77\":1,\"78\":2,\"79\":2}}],[\"shopify\",{\"1\":{\"77\":2,\"79\":2,\"82\":2}}],[\"sheets\",{\"1\":{\"77\":1}}],[\"similar\",{\"1\":{\"92\":1}}],[\"simply\",{\"1\":{\"92\":1}}],[\"simplicity\",{\"1\":{\"80\":1}}],[\"simpler\",{\"1\":{\"79\":1}}],[\"simple\",{\"1\":{\"78\":2,\"83\":1}}],[\"single\",{\"1\":{\"91\":1,\"92\":1,\"101\":1}}],[\"silently\",{\"1\":{\"83\":1}}],[\"signup\",{\"1\":{\"82\":2}}],[\"signifies\",{\"1\":{\"33\":1}}],[\"situation\",{\"1\":{\"79\":1}}],[\"site\",{\"1\":{\"78\":1}}],[\"side\",{\"1\":{\"78\":1,\"82\":1,\"84\":1}}],[\"size++\",{\"1\":{\"14\":1}}],[\"size\",{\"1\":{\"11\":1,\"12\":1,\"14\":1,\"33\":1,\"128\":1,\"136\":3}}],[\"sync\",{\"1\":{\"101\":2}}],[\"synchronize同步锁\",{\"1\":{\"18\":1}}],[\"systems\",{\"1\":{\"81\":1,\"92\":1}}],[\"system\",{\"1\":{\"3\":1,\"82\":2,\"91\":1,\"92\":1,\"103\":3,\"112\":5,\"113\":1,\"136\":1}}],[\"success\",{\"1\":{\"117\":1}}],[\"such\",{\"1\":{\"77\":1,\"79\":1,\"82\":1,\"91\":1}}],[\"suspend\",{\"1\":{\"110\":1}}],[\"sure\",{\"1\":{\"83\":1}}],[\"surely\",{\"1\":{\"78\":1}}],[\"surface\",{\"1\":{\"83\":1,\"84\":1}}],[\"subdomain\",{\"1\":{\"79\":3}}],[\"subtle\",{\"0\":{\"79\":1}}],[\"sub\",{\"1\":{\"78\":1,\"101\":3,\"104\":1}}],[\"subset\",{\"1\":{\"78\":2,\"79\":1,\"92\":1}}],[\"support\",{\"1\":{\"80\":1,\"91\":1}}],[\"suppresswarnings\",{\"1\":{\"3\":1,\"33\":1}}],[\"super\",{\"1\":{\"29\":2,\"113\":1}}],[\"sun\",{\"1\":{\"16\":1,\"66\":1}}],[\"session\",{\"1\":{\"128\":17,\"129\":2,\"131\":1,\"135\":4}}],[\"seamlessly\",{\"1\":{\"92\":1}}],[\"several\",{\"1\":{\"90\":1}}],[\"second\",{\"1\":{\"91\":1}}],[\"seconds\",{\"1\":{\"83\":1}}],[\"secure\",{\"1\":{\"84\":1,\"85\":1}}],[\"securely\",{\"1\":{\"84\":1}}],[\"security\",{\"0\":{\"83\":1},\"1\":{\"79\":1,\"82\":3,\"83\":2}}],[\"send\",{\"1\":{\"134\":4}}],[\"sendtext\",{\"1\":{\"128\":1}}],[\"sending\",{\"1\":{\"81\":1}}],[\"sentinel\",{\"1\":{\"101\":1}}],[\"sensitive\",{\"1\":{\"82\":1}}],[\"selection\",{\"1\":{\"92\":1}}],[\"selectlist\",{\"1\":{\"3\":1}}],[\"self\",{\"1\":{\"82\":2,\"85\":1}}],[\"separate\",{\"1\":{\"80\":1}}],[\"seen\",{\"1\":{\"80\":1}}],[\"see\",{\"1\":{\"79\":1,\"80\":1}}],[\"seems\",{\"1\":{\"83\":1}}],[\"seem\",{\"1\":{\"78\":2,\"80\":1,\"81\":1}}],[\"serialization\",{\"1\":{\"101\":1}}],[\"serializers\",{\"1\":{\"3\":1}}],[\"serializerprovider\",{\"1\":{\"3\":1}}],[\"serialize\",{\"1\":{\"3\":1}}],[\"servletexception\",{\"1\":{\"136\":1}}],[\"servletcontext\",{\"1\":{\"136\":5}}],[\"servletcontextinitializer\",{\"1\":{\"133\":1,\"136\":1}}],[\"serve\",{\"1\":{\"92\":1}}],[\"serverendpointexporter\",{\"1\":{\"133\":7}}],[\"serverendpoint注解的端点进行扫描注册\",{\"1\":{\"133\":1}}],[\"serverendpoint注解用于声明此类是一个\",{\"1\":{\"128\":1}}],[\"serverendpoint\",{\"1\":{\"128\":2,\"133\":2,\"135\":1}}],[\"server\",{\"1\":{\"91\":1,\"101\":1}}],[\"service\",{\"1\":{\"81\":1,\"82\":2,\"85\":1}}],[\"servivor\",{\"1\":{\"64\":2}}],[\"setinitparameter\",{\"1\":{\"136\":2}}],[\"setint\",{\"1\":{\"3\":1}}],[\"setproperty\",{\"1\":{\"136\":1}}],[\"setpreviousisolationlevel\",{\"1\":{\"120\":1}}],[\"setapplicationcontext\",{\"1\":{\"135\":1}}],[\"setannotatedendpointclasses\",{\"1\":{\"133\":1}}],[\"setautocommit\",{\"1\":{\"120\":2}}],[\"setmustrestoreautocommit\",{\"1\":{\"120\":1}}],[\"setreadonly\",{\"1\":{\"120\":1}}],[\"setregion\",{\"1\":{\"103\":1}}],[\"setconnectionholder\",{\"1\":{\"120\":1}}],[\"setoperator\",{\"1\":{\"103\":1}}],[\"setobject\",{\"1\":{\"3\":1}}],[\"setkeys\",{\"1\":{\"103\":1}}],[\"set>\",{\"1\":{\"12\":1}}],[\"set\",{\"1\":{\"12\":3,\"79\":4,\"103\":2,\"104\":2,\"120\":1}}],[\"setgender\",{\"1\":{\"3\":1}}],[\"setter\",{\"1\":{\"3\":2}}],[\"setsynchronizedwithtransaction\",{\"1\":{\"120\":1}}],[\"setstring\",{\"1\":{\"3\":1}}],[\"setshort\",{\"1\":{\"3\":1}}],[\"setlong\",{\"1\":{\"3\":1}}],[\"setbyte\",{\"1\":{\"3\":1}}],[\"setnonnullparameter\",{\"1\":{\"3\":2}}],[\"switching\",{\"1\":{\"120\":1}}],[\"switch\",{\"1\":{\"3\":1,\"120\":1}}],[\"sql\",{\"1\":{\"3\":1}}],[\"sqlexception\",{\"1\":{\"3\":8}}],[\"s\",{\"0\":{\"79\":1},\"1\":{\"3\":3,\"77\":2,\"78\":5,\"79\":2,\"80\":2,\"81\":2,\"84\":1,\"91\":1,\"92\":2}}],[\"story\",{\"1\":{\"85\":1}}],[\"storage\",{\"1\":{\"85\":1,\"101\":1}}],[\"stored\",{\"1\":{\"91\":2}}],[\"store\",{\"1\":{\"80\":2,\"82\":4,\"83\":1,\"84\":1,\"92\":1}}],[\"straightforward\",{\"1\":{\"91\":1}}],[\"struggle\",{\"1\":{\"83\":1}}],[\"stripe\",{\"1\":{\"77\":2}}],[\"string\",{\"1\":{\"3\":14,\"67\":1,\"103\":2,\"112\":2,\"113\":1,\"128\":2,\"135\":1,\"136\":1}}],[\"step\",{\"1\":{\"78\":1}}],[\"still\",{\"0\":{\"76\":1},\"1\":{\"75\":1,\"76\":1,\"78\":2,\"80\":1,\"82\":1,\"83\":1}}],[\"status\",{\"1\":{\"110\":1,\"112\":2}}],[\"static\",{\"1\":{\"3\":1,\"10\":1,\"11\":1,\"14\":1,\"27\":2,\"29\":3,\"32\":1,\"44\":2,\"101\":2,\"128\":2,\"135\":1,\"136\":1}}],[\"standalone\",{\"1\":{\"90\":1,\"92\":1}}],[\"standardized\",{\"1\":{\"78\":1,\"81\":1}}],[\"standard\",{\"0\":{\"78\":1},\"1\":{\"76\":1,\"77\":1,\"78\":4,\"80\":2,\"81\":2,\"83\":2}}],[\"starter\",{\"1\":{\"127\":1}}],[\"start\",{\"1\":{\"82\":1,\"101\":2}}],[\"stackoverflowerror\",{\"1\":{\"62\":1,\"63\":1}}],[\"stack\",{\"0\":{\"61\":1}}],[\"stay\",{\"1\":{\"33\":1}}],[\"js\",{\"0\":{\"134\":1}}],[\"json\",{\"1\":{\"3\":1,\"79\":2,\"101\":1}}],[\"jsondeserialize\",{\"1\":{\"3\":1}}],[\"jsondeserializer<basicenum<e>>\",{\"1\":{\"3\":1}}],[\"jsongenerator\",{\"1\":{\"3\":1}}],[\"jsonserialize\",{\"1\":{\"3\":1}}],[\"jsonserializer<basicenum<\",{\"1\":{\"3\":1}}],[\"jsonstreamcontext\",{\"1\":{\"3\":1}}],[\"jsonparser\",{\"1\":{\"3\":1}}],[\"jetcache\",{\"1\":{\"105\":6}}],[\"jedis\",{\"1\":{\"101\":2}}],[\"jgroups\",{\"1\":{\"104\":1}}],[\"j2cachebuilder\",{\"1\":{\"102\":2}}],[\"j2cacheconfig\",{\"1\":{\"102\":2}}],[\"j2cache\",{\"0\":{\"95\":1},\"1\":{\"96\":2,\"97\":2,\"98\":2,\"99\":2,\"101\":12,\"103\":6,\"104\":4,\"105\":7}}],[\"just\",{\"0\":{\"78\":1},\"1\":{\"78\":1,\"80\":2,\"84\":1}}],[\"jira\",{\"1\":{\"77\":2,\"79\":2,\"80\":2}}],[\"jit\",{\"1\":{\"64\":1}}],[\"jwts\",{\"1\":{\"78\":1}}],[\"jwt\",{\"1\":{\"75\":1,\"78\":1}}],[\"jvm\",{\"0\":{\"38\":1,\"54\":1,\"55\":1,\"58\":1},\"1\":{\"38\":4,\"39\":3,\"40\":1,\"43\":1,\"46\":2,\"47\":2,\"48\":1,\"50\":2,\"56\":4,\"57\":8,\"58\":3,\"59\":1,\"62\":2,\"64\":4,\"65\":1,\"69\":4,\"70\":1,\"71\":2,\"105\":2},\"2\":{\"53\":1,\"73\":1}}],[\"j\",{\"1\":{\"33\":7}}],[\"jdk\",{\"1\":{\"25\":1,\"66\":2,\"68\":4}}],[\"jdk1\",{\"1\":{\"8\":2,\"24\":1}}],[\"jdbc\",{\"1\":{\"3\":1,\"120\":5}}],[\"jdbctype\",{\"1\":{\"3\":8}}],[\"jakarta\",{\"0\":{\"126\":1},\"1\":{\"125\":5,\"128\":2,\"137\":1,\"138\":1,\"139\":1}}],[\"jar\",{\"1\":{\"47\":1}}],[\"jackson\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"java类下的processdatatext\",{\"1\":{\"136\":1}}],[\"javax\",{\"1\":{\"125\":1}}],[\"javadoc\",{\"1\":{\"116\":1}}],[\"javascript\",{\"1\":{\"75\":1,\"77\":2,\"134\":1}}],[\"java虚拟机规范\",{\"1\":{\"70\":1}}],[\"java\",{\"0\":{\"23\":1,\"144\":1},\"1\":{\"0\":1,\"8\":1,\"19\":5,\"20\":1,\"24\":2,\"25\":2,\"26\":3,\"29\":2,\"32\":1,\"35\":1,\"38\":1,\"39\":2,\"41\":2,\"43\":1,\"45\":1,\"46\":3,\"47\":3,\"49\":1,\"50\":2,\"56\":6,\"57\":4,\"58\":2,\"59\":1,\"60\":1,\"63\":1,\"64\":4,\"66\":3,\"67\":1,\"69\":2,\"70\":1,\"99\":1,\"101\":1,\"105\":1,\"125\":4},\"2\":{\"21\":1,\"22\":1,\"36\":1,\"37\":1,\"52\":1,\"53\":1,\"72\":1,\"73\":1}}],[\"tcp\",{\"1\":{\"125\":2}}],[\"txobject\",{\"1\":{\"120\":16}}],[\"txsyncevent\",{\"1\":{\"113\":4}}],[\"txsyncdemo\",{\"1\":{\"112\":3,\"113\":1}}],[\"txdemo\",{\"1\":{\"112\":2,\"113\":2}}],[\"txcontroller\",{\"1\":{\"112\":1,\"113\":1}}],[\"txname\",{\"1\":{\"112\":5}}],[\"ttl\",{\"1\":{\"99\":2,\"101\":2}}],[\"twitter\",{\"1\":{\"82\":2}}],[\"two\",{\"1\":{\"33\":2,\"80\":1,\"83\":1}}],[\"textbuffersize\",{\"1\":{\"136\":1}}],[\"text\",{\"1\":{\"134\":1}}],[\"techniques\",{\"1\":{\"92\":1}}],[\"technique\",{\"1\":{\"90\":1}}],[\"technologies\",{\"1\":{\"83\":1}}],[\"terms\",{\"1\":{\"82\":1}}],[\"telling\",{\"1\":{\"81\":2}}],[\"tell\",{\"1\":{\"80\":2,\"81\":1,\"83\":1}}],[\"teams\",{\"1\":{\"78\":1}}],[\"tend\",{\"1\":{\"78\":1}}],[\"test\",{\"1\":{\"46\":2,\"103\":1}}],[\"typical\",{\"1\":{\"78\":1}}],[\"type=\",{\"1\":{\"134\":1}}],[\"types\",{\"1\":{\"80\":1}}],[\"type\",{\"1\":{\"3\":2,\"78\":2,\"113\":1}}],[\"typehandler<t>\",{\"1\":{\"3\":1}}],[\"typereference<t>\",{\"1\":{\"3\":1}}],[\"tl\",{\"1\":{\"76\":2}}],[\"tlab\",{\"1\":{\"64\":2}}],[\"title>\",{\"1\":{\"134\":1}}],[\"title\",{\"1\":{\"81\":1}}],[\"timeout\",{\"1\":{\"101\":1}}],[\"time\",{\"1\":{\"78\":1,\"79\":1,\"80\":2,\"82\":1,\"83\":1,\"84\":1}}],[\"tim\",{\"1\":{\"70\":1}}],[\"tinyint\",{\"1\":{\"3\":1}}],[\"today\",{\"1\":{\"83\":2}}],[\"toward\",{\"1\":{\"82\":1}}],[\"top\",{\"0\":{\"82\":1}}],[\"token\",{\"1\":{\"78\":1,\"79\":2,\"80\":10,\"83\":9,\"85\":2}}],[\"tokens\",{\"1\":{\"78\":2,\"79\":1,\"80\":1,\"83\":3,\"84\":7}}],[\"together\",{\"1\":{\"78\":1,\"80\":2}}],[\"tomorrow\",{\"1\":{\"78\":1,\"79\":1}}],[\"tomcat\",{\"1\":{\"49\":1,\"68\":1,\"128\":2,\"135\":1,\"136\":7}}],[\"took\",{\"1\":{\"79\":1,\"81\":1}}],[\"too\",{\"0\":{\"78\":1},\"1\":{\"78\":2,\"79\":1}}],[\"tong\",{\"1\":{\"76\":1}}],[\"to\",{\"0\":{\"80\":1,\"82\":1},\"1\":{\"64\":1,\"76\":3,\"77\":1,\"78\":13,\"79\":15,\"80\":13,\"81\":3,\"82\":14,\"83\":3,\"84\":5,\"85\":3,\"91\":8,\"92\":10,\"101\":2,\"120\":4}}],[\"talked\",{\"0\":{\"84\":1}}],[\"take\",{\"1\":{\"80\":1,\"82\":3}}],[\"takes\",{\"1\":{\"79\":1,\"82\":1}}],[\"target\",{\"0\":{\"83\":1},\"1\":{\"33\":1,\"113\":1,\"117\":3}}],[\"tab\",{\"1\":{\"30\":8,\"31\":4}}],[\"table\",{\"1\":{\"11\":1,\"14\":7,\"15\":2,\"16\":3,\"25\":1,\"30\":3,\"31\":1,\"33\":4,\"91\":1}}],[\"trouble\",{\"1\":{\"78\":1}}],[\"tried\",{\"1\":{\"78\":1}}],[\"truth\",{\"1\":{\"82\":1}}],[\"truly\",{\"1\":{\"78\":1}}],[\"true\",{\"1\":{\"30\":2,\"101\":3,\"113\":1,\"120\":5}}],[\"try\",{\"1\":{\"78\":1,\"85\":1,\"120\":2}}],[\"treat\",{\"1\":{\"76\":1}}],[\"treenode\",{\"1\":{\"29\":1,\"30\":1,\"31\":1,\"33\":2}}],[\"treenode<k\",{\"0\":{\"29\":1},\"1\":{\"29\":6,\"30\":1,\"31\":1,\"33\":1}}],[\"treeifybin\",{\"1\":{\"30\":1}}],[\"treeify\",{\"1\":{\"27\":1,\"30\":1}}],[\"treemap\",{\"1\":{\"8\":1}}],[\"transactiondefinition\",{\"1\":{\"120\":1}}],[\"transaction\",{\"1\":{\"120\":6},\"2\":{\"123\":1}}],[\"transactionphase\",{\"1\":{\"113\":3,\"119\":1}}],[\"transactionaleventlistener注解classes属性是否有指定值分情况说明\",{\"1\":{\"115\":1}}],[\"transactionaleventlistener\",{\"1\":{\"113\":2,\"119\":1}}],[\"transactionaleventlistener与applicationevent事件对象两者搭配使用\",{\"1\":{\"113\":1}}],[\"transactional\",{\"1\":{\"112\":1,\"113\":1}}],[\"transactional注解方法来完成事务操作\",{\"1\":{\"109\":1}}],[\"transactionsynchronizationmanager\",{\"1\":{\"112\":2,\"120\":1}}],[\"transactionsynchronization\",{\"1\":{\"110\":1,\"112\":1}}],[\"transactionsynchronizationadapter\",{\"1\":{\"110\":1,\"112\":1}}],[\"transactions\",{\"1\":{\"92\":1}}],[\"transparently\",{\"1\":{\"92\":1}}],[\"transfer\",{\"0\":{\"16\":1},\"1\":{\"16\":2,\"24\":1,\"25\":1}}],[\"transient\",{\"1\":{\"11\":3}}],[\"thanks\",{\"1\":{\"85\":1}}],[\"thankfully\",{\"1\":{\"80\":1}}],[\"than\",{\"1\":{\"80\":1,\"85\":1}}],[\"that\",{\"1\":{\"76\":1,\"78\":6,\"79\":4,\"80\":4,\"81\":6,\"82\":2,\"83\":3,\"84\":4,\"85\":1,\"90\":1,\"91\":4,\"92\":1}}],[\"though\",{\"1\":{\"80\":1,\"90\":1}}],[\"thinking\",{\"1\":{\"85\":1}}],[\"think\",{\"1\":{\"78\":2,\"79\":1,\"80\":1,\"84\":1,\"85\":1}}],[\"things\",{\"0\":{\"84\":1},\"1\":{\"77\":1,\"78\":1,\"80\":1}}],[\"third\",{\"1\":{\"78\":2}}],[\"this\",{\"1\":{\"3\":5,\"14\":1,\"29\":4,\"30\":1,\"33\":1,\"78\":6,\"79\":3,\"80\":8,\"81\":1,\"82\":1,\"83\":3,\"85\":1,\"90\":1,\"91\":2,\"92\":3,\"101\":1,\"112\":1,\"120\":2,\"128\":10,\"135\":2}}],[\"then\",{\"1\":{\"82\":1,\"90\":1,\"91\":2,\"92\":1}}],[\"their\",{\"1\":{\"78\":2,\"79\":5,\"82\":5,\"91\":2,\"92\":2}}],[\"them\",{\"1\":{\"78\":4,\"79\":2,\"81\":1,\"82\":1}}],[\"these\",{\"1\":{\"78\":1,\"79\":1,\"81\":1,\"82\":1,\"84\":1,\"91\":1,\"92\":1}}],[\"they\",{\"1\":{\"78\":8,\"79\":6,\"80\":6,\"81\":1,\"82\":3,\"84\":3,\"91\":3,\"92\":2}}],[\"there\",{\"1\":{\"76\":1,\"77\":1,\"79\":1,\"80\":1,\"81\":3,\"82\":2,\"85\":2}}],[\"the\",{\"0\":{\"78\":1},\"1\":{\"33\":2,\"76\":1,\"77\":4,\"78\":14,\"79\":15,\"80\":23,\"81\":13,\"82\":7,\"83\":18,\"84\":8,\"90\":3,\"91\":21,\"92\":22,\"120\":3}}],[\"through\",{\"1\":{\"79\":2,\"91\":1}}],[\"throwable=\",{\"1\":{\"128\":1}}],[\"throwable\",{\"1\":{\"120\":2,\"128\":4}}],[\"throw\",{\"1\":{\"3\":3}}],[\"throws\",{\"1\":{\"3\":10,\"128\":2,\"135\":1,\"136\":1}}],[\"threat\",{\"1\":{\"78\":1}}],[\"thread\",{\"1\":{\"64\":1,\"120\":1}}],[\"threshold\",{\"1\":{\"11\":2,\"14\":1,\"16\":3,\"27\":2,\"30\":3,\"33\":8}}],[\"t\",{\"0\":{\"84\":1},\"1\":{\"3\":4,\"76\":1,\"77\":1,\"78\":1,\"79\":2,\"80\":2,\"81\":1,\"82\":1,\"83\":2,\"92\":2,\"120\":1}}],[\"im\",{\"1\":{\"117\":1}}],[\"imply\",{\"0\":{\"90\":1},\"1\":{\"89\":1}}],[\"implementing\",{\"1\":{\"78\":1}}],[\"implementations\",{\"1\":{\"78\":1}}],[\"implementation\",{\"1\":{\"77\":1,\"81\":1,\"84\":1}}],[\"implement\",{\"1\":{\"76\":1,\"78\":2,\"80\":1,\"81\":1,\"83\":1}}],[\"implemented\",{\"1\":{\"76\":1,\"77\":1,\"80\":1,\"83\":1}}],[\"implements\",{\"1\":{\"3\":2,\"10\":1,\"29\":1,\"79\":1,\"83\":1,\"110\":1,\"133\":1,\"135\":1,\"136\":1}}],[\"ioc\",{\"1\":{\"135\":1}}],[\"iot\",{\"1\":{\"125\":1}}],[\"io\",{\"1\":{\"97\":1}}],[\"ioexception\",{\"1\":{\"3\":2,\"128\":2}}],[\"id=\",{\"1\":{\"128\":4}}],[\"id\",{\"1\":{\"92\":2,\"128\":1}}],[\"idea\",{\"1\":{\"68\":1,\"78\":1,\"80\":1,\"134\":1}}],[\"ide\",{\"1\":{\"60\":1,\"68\":1}}],[\"ignite\",{\"1\":{\"89\":1,\"92\":2}}],[\"iteration\",{\"1\":{\"83\":1}}],[\"its\",{\"1\":{\"77\":1,\"91\":1}}],[\"it\",{\"1\":{\"76\":2,\"77\":2,\"78\":1,\"79\":5,\"80\":7,\"81\":2,\"83\":4,\"84\":1,\"85\":2,\"91\":1,\"92\":2,\"120\":2}}],[\"ismustrestoreautocommit\",{\"1\":{\"120\":1}}],[\"isnewconnectionholder\",{\"1\":{\"120\":2}}],[\"isreadonly\",{\"1\":{\"120\":2}}],[\"isdebugenabled\",{\"1\":{\"120\":3}}],[\"issynchronizedwithtransaction\",{\"1\":{\"120\":1}}],[\"issue\",{\"1\":{\"80\":1,\"81\":1,\"83\":1}}],[\"isassignableform\",{\"1\":{\"119\":1}}],[\"isactualtransactionactive\",{\"1\":{\"116\":1}}],[\"isolated\",{\"1\":{\"91\":1}}],[\"is\",{\"0\":{\"76\":1,\"78\":1,\"79\":1,\"81\":1,\"83\":1},\"1\":{\"75\":1,\"76\":2,\"77\":1,\"78\":8,\"79\":2,\"80\":4,\"81\":7,\"82\":3,\"83\":3,\"84\":1,\"85\":2,\"90\":2,\"91\":6,\"92\":3,\"120\":1}}],[\"isbooted\",{\"1\":{\"16\":1}}],[\"isempty\",{\"1\":{\"12\":1}}],[\"inputstream\",{\"1\":{\"132\":1}}],[\"init\",{\"1\":{\"102\":2}}],[\"initializes\",{\"1\":{\"33\":1}}],[\"initial\",{\"1\":{\"11\":1,\"33\":6}}],[\"inherently\",{\"1\":{\"92\":1}}],[\"involves\",{\"1\":{\"92\":1}}],[\"invalid\",{\"0\":{\"81\":2},\"1\":{\"81\":1}}],[\"including\",{\"1\":{\"91\":1}}],[\"includes\",{\"1\":{\"79\":1,\"83\":1}}],[\"indispensable\",{\"1\":{\"91\":1}}],[\"indians\",{\"1\":{\"79\":1}}],[\"index\",{\"1\":{\"14\":1,\"26\":1,\"33\":2}}],[\"indexfor\",{\"1\":{\"14\":3,\"15\":2,\"16\":1,\"25\":1}}],[\"inserts\",{\"1\":{\"91\":1}}],[\"insert\",{\"1\":{\"91\":1,\"92\":1}}],[\"insist\",{\"1\":{\"79\":1}}],[\"instances\",{\"1\":{\"90\":2,\"91\":2,\"92\":1}}],[\"instance\",{\"1\":{\"80\":3,\"81\":1,\"91\":3}}],[\"instanceof\",{\"1\":{\"3\":2,\"30\":1,\"31\":1,\"33\":1,\"119\":2}}],[\"instead\",{\"1\":{\"78\":1,\"80\":2}}],[\"informed\",{\"1\":{\"92\":1}}],[\"information\",{\"1\":{\"80\":1,\"83\":1}}],[\"info\",{\"1\":{\"45\":3,\"128\":7}}],[\"in\",{\"0\":{\"76\":1,\"77\":1,\"79\":1},\"1\":{\"33\":4,\"75\":1,\"76\":2,\"77\":3,\"78\":5,\"79\":11,\"80\":9,\"81\":5,\"82\":5,\"83\":4,\"84\":2,\"85\":1,\"90\":1,\"91\":6,\"92\":5,\"120\":1}}],[\"into\",{\"1\":{\"79\":2,\"82\":1,\"90\":1,\"91\":3,\"92\":1}}],[\"intvalue\",{\"1\":{\"3\":1}}],[\"integrate\",{\"1\":{\"82\":1}}],[\"integrations\",{\"1\":{\"82\":1}}],[\"integration\",{\"1\":{\"82\":1}}],[\"integer\",{\"1\":{\"3\":8,\"16\":2,\"33\":2,\"120\":1}}],[\"intentions\",{\"1\":{\"78\":1}}],[\"interested\",{\"1\":{\"91\":1,\"92\":1}}],[\"interpretation\",{\"1\":{\"77\":1}}],[\"intern\",{\"1\":{\"67\":1,\"78\":1}}],[\"interface\",{\"1\":{\"3\":2,\"113\":1}}],[\"int\",{\"1\":{\"3\":7,\"10\":2,\"11\":4,\"12\":1,\"14\":9,\"15\":1,\"16\":5,\"25\":2,\"27\":2,\"29\":4,\"30\":3,\"31\":2,\"32\":2,\"33\":6,\"44\":2,\"110\":2,\"112\":1,\"128\":1}}],[\"illegalargumentexception\",{\"1\":{\"3\":2}}],[\"if\",{\"1\":{\"3\":9,\"14\":3,\"15\":2,\"16\":2,\"25\":1,\"30\":10,\"31\":5,\"33\":15,\"76\":1,\"77\":1,\"78\":2,\"79\":1,\"80\":1,\"81\":1,\"82\":4,\"83\":4,\"84\":1,\"85\":3,\"91\":2,\"92\":4,\"119\":3,\"120\":11,\"128\":2}}],[\"i\",{\"1\":{\"3\":8,\"14\":3,\"16\":3,\"25\":3,\"30\":3,\"78\":2,\"79\":2,\"81\":2}}],[\"ping\",{\"1\":{\"137\":1}}],[\"pick\",{\"1\":{\"79\":1}}],[\"phase\",{\"1\":{\"113\":2,\"119\":1}}],[\"pkce\",{\"1\":{\"81\":4,\"83\":2}}],[\"period\",{\"1\":{\"80\":1}}],[\"permsize\",{\"1\":{\"68\":1}}],[\"permanent\",{\"1\":{\"66\":1}}],[\"path=\",{\"1\":{\"128\":1}}],[\"pathparam\",{\"1\":{\"128\":1,\"135\":1}}],[\"password\",{\"1\":{\"101\":1,\"102\":1}}],[\"passwords\",{\"1\":{\"84\":1}}],[\"passing\",{\"1\":{\"81\":1}}],[\"pass\",{\"1\":{\"80\":2,\"81\":1,\"82\":1}}],[\"page\",{\"1\":{\"79\":1}}],[\"pages\",{\"1\":{\"78\":1,\"79\":1}}],[\"part\",{\"1\":{\"91\":1}}],[\"partner\",{\"1\":{\"82\":1}}],[\"particularly\",{\"1\":{\"82\":1}}],[\"particular\",{\"1\":{\"78\":1}}],[\"parts\",{\"1\":{\"78\":1}}],[\"party\",{\"1\":{\"78\":2}}],[\"parent\",{\"1\":{\"29\":1}}],[\"param\",{\"1\":{\"3\":2}}],[\"parameters\",{\"1\":{\"78\":1,\"79\":1,\"81\":2}}],[\"parameter\",{\"1\":{\"3\":8,\"79\":5,\"80\":2}}],[\"parse\",{\"1\":{\"80\":1}}],[\"parseint\",{\"1\":{\"3\":1}}],[\"parsingcontext\",{\"1\":{\"3\":4}}],[\"place\",{\"1\":{\"78\":1}}],[\"placed\",{\"1\":{\"33\":1}}],[\"please\",{\"1\":{\"76\":1,\"79\":1}}],[\"plus\",{\"1\":{\"3\":2,\"82\":1}}],[\"pong\",{\"1\":{\"137\":1}}],[\"pojoendpoint\",{\"1\":{\"128\":1}}],[\"pojo\",{\"1\":{\"128\":1}}],[\"pojomethodmapping\",{\"1\":{\"128\":2}}],[\"pool\",{\"1\":{\"120\":1}}],[\"postgresql\",{\"1\":{\"89\":1,\"91\":2}}],[\"posts\",{\"0\":{\"143\":1},\"1\":{\"82\":1}}],[\"postmapping\",{\"1\":{\"3\":1}}],[\"position\",{\"1\":{\"82\":1}}],[\"point\",{\"1\":{\"79\":1}}],[\"popular\",{\"1\":{\"76\":1,\"77\":1,\"82\":1}}],[\"power\",{\"1\":{\"33\":2}}],[\"publishevent\",{\"1\":{\"113\":1}}],[\"publisher\",{\"1\":{\"113\":2}}],[\"publish\",{\"1\":{\"103\":3,\"104\":1}}],[\"public\",{\"1\":{\"3\":25,\"12\":10,\"14\":1,\"15\":1,\"30\":1,\"31\":1,\"44\":2,\"78\":1,\"82\":1,\"101\":2,\"102\":2,\"103\":4,\"110\":9,\"112\":7,\"113\":7,\"119\":1,\"128\":6,\"133\":2,\"135\":3,\"136\":4}}],[\"pub\",{\"1\":{\"101\":2,\"104\":1}}],[\"pubsub\",{\"1\":{\"101\":2}}],[\"pun\",{\"1\":{\"101\":1}}],[\"purposes\",{\"1\":{\"92\":1}}],[\"putifabsent\",{\"1\":{\"30\":1}}],[\"puttreeval\",{\"1\":{\"30\":2}}],[\"putval\",{\"1\":{\"30\":2}}],[\"putfornullkey\",{\"1\":{\"14\":1}}],[\"put\",{\"0\":{\"14\":1,\"30\":1},\"1\":{\"12\":1,\"14\":1,\"24\":1,\"30\":2}}],[\"p\",{\"1\":{\"3\":3,\"30\":10}}],[\"protected\",{\"1\":{\"120\":2}}],[\"protocols\",{\"1\":{\"91\":1}}],[\"protocol\",{\"1\":{\"76\":1}}],[\"properties\",{\"1\":{\"99\":1,\"101\":4,\"102\":1,\"103\":2,\"104\":1}}],[\"provider\",{\"1\":{\"84\":2,\"101\":3}}],[\"providers\",{\"1\":{\"78\":1}}],[\"provide\",{\"1\":{\"82\":1}}],[\"processes\",{\"1\":{\"82\":1}}],[\"process\",{\"1\":{\"78\":1,\"82\":1,\"83\":1}}],[\"probably\",{\"1\":{\"78\":1,\"79\":1,\"82\":2,\"83\":1}}],[\"problem\",{\"0\":{\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1},\"1\":{\"81\":1}}],[\"prompt\",{\"1\":{\"78\":1,\"79\":1}}],[\"practices\",{\"1\":{\"83\":2}}],[\"practice\",{\"0\":{\"77\":1}}],[\"precedence\",{\"1\":{\"110\":1}}],[\"precise\",{\"1\":{\"78\":1}}],[\"prebuilt\",{\"1\":{\"85\":1}}],[\"prepareconnectionfortransaction\",{\"1\":{\"120\":1}}],[\"preparedstatement\",{\"1\":{\"3\":2}}],[\"preproduction\",{\"1\":{\"82\":1}}],[\"preregister\",{\"1\":{\"81\":1}}],[\"preregistered\",{\"1\":{\"81\":1}}],[\"presence\",{\"1\":{\"92\":1}}],[\"preset\",{\"1\":{\"80\":1}}],[\"preserve\",{\"1\":{\"33\":1}}],[\"prefer\",{\"1\":{\"79\":1}}],[\"prefers\",{\"1\":{\"79\":1}}],[\"pretty\",{\"1\":{\"78\":1,\"82\":1}}],[\"previousisolationlevel\",{\"1\":{\"120\":2}}],[\"prev\",{\"1\":{\"29\":1}}],[\"primary\",{\"1\":{\"91\":1}}],[\"println\",{\"1\":{\"3\":1,\"103\":3,\"112\":5,\"113\":1}}],[\"private\",{\"1\":{\"3\":6,\"78\":1,\"101\":1,\"103\":1,\"112\":1,\"113\":1,\"128\":3,\"135\":2}}],[\"ps\",{\"1\":{\"3\":8,\"101\":1,\"117\":1,\"118\":1}}],[\"ve\",{\"1\":{\"85\":1,\"120\":1}}],[\"verb\",{\"1\":{\"90\":1}}],[\"version\",{\"1\":{\"79\":1}}],[\"very\",{\"1\":{\"78\":1,\"120\":1}}],[\"vitess\",{\"1\":{\"89\":1,\"91\":2}}],[\"video\",{\"1\":{\"82\":1}}],[\"visit\",{\"1\":{\"79\":1}}],[\"visual\",{\"1\":{\"78\":1}}],[\"virtual\",{\"1\":{\"56\":1}}],[\"vm\",{\"1\":{\"16\":1}}],[\"v\",{\"1\":{\"10\":4,\"12\":4,\"14\":5,\"15\":1,\"29\":4,\"30\":5,\"31\":1}}],[\"v>本身并没有直接使用到这两个属性\",{\"1\":{\"29\":1}}],[\"v>类\",{\"1\":{\"29\":2}}],[\"v>类是继承linkedhashmap\",{\"1\":{\"29\":1}}],[\"v>类型数组\",{\"1\":{\"10\":1}}],[\"v>接口\",{\"1\":{\"29\":1}}],[\"v>的\",{\"1\":{\"12\":1}}],[\"v>节点的数据\",{\"1\":{\"10\":1}}],[\"v>对象保存\",{\"1\":{\"14\":1,\"29\":1}}],[\"v>对象保存了key\",{\"1\":{\"10\":1}}],[\"v>对象数组\",{\"1\":{\"11\":1}}],[\"v>对象\",{\"1\":{\"10\":2}}],[\"v>对象的下一个entry<k\",{\"1\":{\"10\":1}}],[\"v>对象进行存储\",{\"1\":{\"10\":1}}],[\"v>\",{\"0\":{\"29\":2},\"1\":{\"10\":8,\"14\":2,\"15\":3,\"16\":2,\"18\":2,\"20\":1,\"25\":2,\"29\":19,\"30\":4,\"31\":5,\"33\":9}}],[\"various\",{\"1\":{\"91\":1}}],[\"varbinary\",{\"1\":{\"3\":1}}],[\"vast\",{\"1\":{\"80\":1}}],[\"val\",{\"1\":{\"3\":7,\"29\":2}}],[\"values\",{\"1\":{\"83\":1}}],[\"value的值在准备阶段会被初始化为\",{\"1\":{\"44\":1}}],[\"value的存储位置从而保证其进行数据快速存取\",{\"1\":{\"9\":1}}],[\"value是用entry<k\",{\"1\":{\"29\":1}}],[\"value作为\",{\"1\":{\"20\":1}}],[\"value封装为entry<k\",{\"1\":{\"14\":1}}],[\"value\",{\"1\":{\"10\":3,\"12\":2,\"14\":11,\"16\":2,\"29\":6,\"30\":9,\"31\":1,\"33\":2,\"44\":3,\"79\":1,\"103\":1,\"113\":1,\"128\":2,\"135\":1}}],[\"value可重复\",{\"1\":{\"9\":1}}],[\"value形式保存数据\",{\"1\":{\"9\":1}}],[\"value键值对映射的接口\",{\"1\":{\"8\":1}}],[\"value2enum\",{\"1\":{\"3\":5}}],[\"valueof\",{\"1\":{\"3\":1}}],[\"void\",{\"1\":{\"3\":3,\"12\":1,\"14\":2,\"16\":2,\"25\":1,\"103\":3,\"110\":7,\"112\":4,\"113\":2,\"119\":1,\"120\":2,\"128\":4,\"135\":2,\"136\":2}}],[\"vuepress\",{\"1\":{\"0\":1}}],[\"可直接使用\",{\"1\":{\"131\":1}}],[\"可得到其属性\",{\"1\":{\"129\":1}}],[\"可获取当前\",{\"1\":{\"129\":1}}],[\"可获取连接请求的查询参数\",{\"1\":{\"128\":1}}],[\"可让客户端与服务端建立持久连接\",{\"1\":{\"125\":1}}],[\"可能读者会有疑惑\",{\"1\":{\"117\":1}}],[\"可在这个事件类里注入其它依赖或声明业务逻辑\",{\"1\":{\"113\":1}}],[\"可填\",{\"1\":{\"101\":1}}],[\"可缓存的数量\",{\"1\":{\"101\":1}}],[\"可实际上\",{\"1\":{\"97\":1}}],[\"可同时为多节点提供服务\",{\"1\":{\"97\":1}}],[\"可用\",{\"1\":{\"84\":1}}],[\"可逆的加密\",{\"1\":{\"84\":1}}],[\"可选的\",{\"1\":{\"81\":1}}],[\"可通过transactionsynchronizationmanager\",{\"1\":{\"116\":1}}],[\"可通过\",{\"1\":{\"113\":1}}],[\"可通过下图来了解参数所控制的区域分别是什么\",{\"1\":{\"68\":1}}],[\"可通过对字典字段的出入参进行转化\",{\"1\":{\"3\":1}}],[\"可执行的机器码\",{\"1\":{\"57\":1}}],[\"可以避免应用重启后对后端业务系统的冲击\",{\"1\":{\"98\":1}}],[\"可以有效降低节点间的数据传输量\",{\"1\":{\"98\":1}}],[\"可以考虑研究\",{\"1\":{\"89\":1}}],[\"可以考虑探索\",{\"1\":{\"89\":1}}],[\"可以直接路由客户端请求到适当的分片所有者\",{\"1\":{\"89\":1}}],[\"可以启发我们在内存管理\",{\"1\":{\"69\":1}}],[\"可以通过\",{\"1\":{\"68\":1}}],[\"可以简单的理解新生代主要是存放新创建的对象\",{\"1\":{\"64\":1}}],[\"可以围绕四个部分进行\",{\"1\":{\"57\":1}}],[\"可以是任何字面量\",{\"1\":{\"45\":1}}],[\"可以戳一下链接先去看看哦\",{\"1\":{\"38\":1}}],[\"可以快速定位\",{\"1\":{\"35\":1}}],[\"可以看到其实也是继承hashmap\",{\"1\":{\"29\":1}}],[\"可以先看下图简单对比头插法和尾插法\",{\"1\":{\"25\":1}}],[\"可以用来遍历\",{\"1\":{\"12\":1}}],[\"可以构建入参\",{\"1\":{\"3\":1}}],[\"可空的参数\",{\"1\":{\"3\":1}}],[\"cmd\",{\"1\":{\"103\":5}}],[\"crucial\",{\"1\":{\"92\":1}}],[\"critical\",{\"1\":{\"91\":1}}],[\"credentials\",{\"1\":{\"78\":2}}],[\"createentry\",{\"1\":{\"14\":2}}],[\"citusdata\",{\"1\":{\"89\":1,\"91\":2}}],[\"centralized\",{\"1\":{\"92\":1}}],[\"centers\",{\"1\":{\"79\":1}}],[\"certain\",{\"1\":{\"83\":1}}],[\"cut\",{\"1\":{\"82\":1}}],[\"cumbersome\",{\"0\":{\"82\":1}}],[\"custom\",{\"1\":{\"101\":1}}],[\"customized\",{\"1\":{\"80\":1}}],[\"customer\",{\"1\":{\"80\":1}}],[\"customers\",{\"1\":{\"79\":2,\"82\":1}}],[\"current\",{\"1\":{\"80\":1,\"83\":3}}],[\"currently\",{\"1\":{\"78\":1}}],[\"currentname\",{\"1\":{\"3\":3}}],[\"currentvalue\",{\"1\":{\"3\":1}}],[\"c++\",{\"1\":{\"58\":1}}],[\"channel\",{\"1\":{\"101\":3,\"102\":3,\"103\":3,\"104\":2,\"117\":1,\"128\":1,\"134\":2,\"135\":1}}],[\"changes\",{\"1\":{\"84\":1}}],[\"changed\",{\"1\":{\"83\":1}}],[\"change\",{\"1\":{\"79\":1,\"81\":1,\"83\":1,\"84\":1,\"92\":1}}],[\"charbuffer\",{\"1\":{\"136\":1}}],[\"charset=\",{\"1\":{\"134\":1}}],[\"char\",{\"1\":{\"3\":1}}],[\"checking\",{\"1\":{\"84\":1}}],[\"check\",{\"1\":{\"31\":1}}],[\"c\",{\"1\":{\"25\":3,\"58\":1}}],[\"catch\",{\"1\":{\"120\":2}}],[\"cachenameconstant\",{\"1\":{\"103\":2}}],[\"cacheconfig\",{\"1\":{\"102\":1,\"103\":1}}],[\"cachechannel\",{\"1\":{\"101\":7,\"102\":3,\"103\":3}}],[\"cacheprovider\",{\"1\":{\"101\":3}}],[\"cache\",{\"0\":{\"146\":1},\"1\":{\"99\":3,\"101\":1,\"103\":6},\"2\":{\"106\":1,\"107\":1}}],[\"caffeine\",{\"1\":{\"96\":1,\"97\":1,\"99\":4,\"101\":4,\"104\":1}}],[\"car\",{\"1\":{\"91\":3,\"92\":2}}],[\"cartable\",{\"1\":{\"91\":1}}],[\"cares\",{\"1\":{\"79\":1}}],[\"cassandra\",{\"1\":{\"89\":1,\"92\":2}}],[\"case\",{\"1\":{\"3\":6,\"78\":2}}],[\"cannot\",{\"1\":{\"81\":1}}],[\"can\",{\"1\":{\"79\":2,\"80\":1,\"82\":4,\"83\":1,\"84\":1,\"91\":1,\"92\":3}}],[\"capabilities\",{\"1\":{\"79\":1}}],[\"capacity也就是构建\",{\"1\":{\"11\":1}}],[\"capacity\",{\"1\":{\"11\":2,\"16\":3,\"33\":9}}],[\"callchannel>\",{\"1\":{\"128\":1}}],[\"callchannel\",{\"1\":{\"128\":2,\"133\":1,\"135\":1}}],[\"callback\",{\"1\":{\"79\":4,\"80\":1}}],[\"calls\",{\"1\":{\"79\":1}}],[\"call\",{\"1\":{\"79\":2,\"80\":2,\"128\":1,\"134\":2,\"135\":1}}],[\"callablestatement\",{\"1\":{\"3\":2}}],[\"calendar\",{\"1\":{\"77\":1}}],[\"closure\",{\"1\":{\"128\":1}}],[\"closecodes也已定义了一些常见的枚举原因\",{\"1\":{\"131\":1}}],[\"closecodes\",{\"1\":{\"128\":2}}],[\"closereason\",{\"1\":{\"128\":5}}],[\"close\",{\"1\":{\"102\":2,\"128\":2,\"134\":1}}],[\"clusterpolicy\",{\"1\":{\"104\":1}}],[\"cluster\",{\"1\":{\"89\":1,\"91\":1,\"92\":3,\"101\":1,\"104\":1}}],[\"clientsize\",{\"1\":{\"128\":1}}],[\"clients\",{\"1\":{\"91\":1}}],[\"client\",{\"1\":{\"76\":2,\"78\":2,\"81\":1,\"91\":2,\"92\":5}}],[\"clear\",{\"1\":{\"12\":1,\"78\":1,\"120\":1}}],[\"cls\",{\"1\":{\"3\":7}}],[\"classes指定多个值时\",{\"1\":{\"115\":1}}],[\"classes\",{\"1\":{\"113\":4,\"119\":1}}],[\"classpath\",{\"1\":{\"47\":1}}],[\"classloader\",{\"1\":{\"47\":3,\"49\":1}}],[\"class文件缺失或存在错误\",{\"1\":{\"39\":1}}],[\"class对象\",{\"1\":{\"39\":1}}],[\"class<e>\",{\"1\":{\"3\":2}}],[\"class<\",{\"1\":{\"3\":3}}],[\"class\",{\"1\":{\"3\":9,\"10\":1,\"29\":3,\"39\":3,\"41\":1,\"43\":2,\"45\":2,\"46\":2,\"48\":8,\"56\":1,\"66\":1,\"67\":1,\"101\":4,\"102\":1,\"103\":1,\"110\":1,\"112\":3,\"113\":9,\"115\":2,\"119\":2,\"128\":2,\"133\":2,\"135\":2,\"136\":4}}],[\"cs\",{\"1\":{\"3\":3}}],[\"copies\",{\"1\":{\"92\":1}}],[\"coordinate\",{\"1\":{\"92\":1}}],[\"coordinator\",{\"1\":{\"89\":1,\"91\":8,\"92\":4}}],[\"corresponding\",{\"1\":{\"91\":1}}],[\"corner\",{\"1\":{\"77\":1,\"78\":1}}],[\"cockroachdb\",{\"1\":{\"89\":1,\"92\":2}}],[\"cosmosdb\",{\"1\":{\"89\":1,\"91\":2}}],[\"cost\",{\"1\":{\"83\":1}}],[\"could\",{\"1\":{\"79\":1,\"80\":1,\"81\":1,\"120\":1}}],[\"cover\",{\"1\":{\"78\":1}}],[\"collection\",{\"1\":{\"64\":1}}],[\"columnindex\",{\"1\":{\"3\":6}}],[\"columnname\",{\"1\":{\"3\":3}}],[\"commit\",{\"1\":{\"113\":2,\"119\":1,\"120\":2}}],[\"command\",{\"1\":{\"103\":5,\"104\":2}}],[\"communicating\",{\"1\":{\"92\":1}}],[\"communication\",{\"1\":{\"91\":1}}],[\"communicate\",{\"1\":{\"91\":1}}],[\"community\",{\"1\":{\"85\":1}}],[\"common\",{\"1\":{\"78\":1,\"80\":1,\"81\":1}}],[\"comes\",{\"1\":{\"83\":1,\"85\":1}}],[\"component注解只是表示会由\",{\"1\":{\"135\":1}}],[\"component\",{\"1\":{\"91\":3,\"92\":2,\"113\":1,\"133\":1,\"135\":1}}],[\"compatibility\",{\"1\":{\"83\":1}}],[\"companyid\",{\"1\":{\"80\":2}}],[\"comparable\",{\"1\":{\"77\":1}}],[\"complete\",{\"1\":{\"82\":1}}],[\"completed\",{\"1\":{\"82\":1}}],[\"complex\",{\"0\":{\"78\":1},\"1\":{\"79\":1}}],[\"complicated\",{\"1\":{\"78\":1}}],[\"com\",{\"1\":{\"3\":3,\"46\":1,\"79\":4,\"96\":1}}],[\"con\",{\"1\":{\"120\":11}}],[\"connect\",{\"1\":{\"92\":1}}],[\"connectionholder\",{\"1\":{\"120\":2}}],[\"connection\",{\"1\":{\"92\":1,\"120\":10}}],[\"connected\",{\"1\":{\"82\":1}}],[\"conflated\",{\"1\":{\"92\":1}}],[\"confused\",{\"1\":{\"79\":1}}],[\"configured\",{\"1\":{\"92\":1,\"120\":1}}],[\"configuration\",{\"1\":{\"3\":1,\"102\":1,\"133\":1,\"136\":1}}],[\"config\",{\"1\":{\"3\":2,\"101\":1,\"102\":4}}],[\"console\",{\"1\":{\"134\":5}}],[\"consequently\",{\"1\":{\"91\":1,\"92\":1}}],[\"consensus\",{\"1\":{\"77\":1,\"92\":1}}],[\"consider\",{\"1\":{\"83\":1,\"91\":1,\"92\":1}}],[\"constant\",{\"1\":{\"45\":3}}],[\"constantvalue\",{\"1\":{\"44\":1}}],[\"conclusion\",{\"1\":{\"77\":1}}],[\"conclude\",{\"1\":{\"76\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"128\":1}}],[\"concurrenthashmap\",{\"1\":{\"18\":1}}],[\"conditions\",{\"1\":{\"83\":1,\"84\":1}}],[\"condition\",{\"1\":{\"19\":1,\"113\":1,\"128\":2}}],[\"convert\",{\"1\":{\"3\":2}}],[\"contained\",{\"1\":{\"85\":1}}],[\"containsvalue\",{\"1\":{\"12\":1}}],[\"containskey\",{\"1\":{\"12\":1}}],[\"contents\",{\"1\":{\"82\":1}}],[\"content\",{\"1\":{\"3\":1}}],[\"controller\",{\"1\":{\"3\":1}}],[\"continue\",{\"1\":{\"0\":1,\"92\":1}}],[\"code=$\",{\"1\":{\"134\":1}}],[\"code\",{\"1\":{\"3\":30,\"78\":7,\"79\":1,\"134\":1}}],[\"aevent\",{\"1\":{\"119\":2}}],[\"avoiding\",{\"1\":{\"84\":1}}],[\"available\",{\"1\":{\"83\":1,\"84\":1}}],[\"availableinbasicallyeveryprogramminglanguageyoucanimagine\",{\"1\":{\"76\":1}}],[\"amount\",{\"1\":{\"82\":1}}],[\"aware\",{\"1\":{\"80\":1,\"91\":1,\"92\":2}}],[\"away\",{\"1\":{\"79\":1}}],[\"acquired\",{\"1\":{\"120\":1}}],[\"across\",{\"1\":{\"90\":2,\"92\":2}}],[\"action\",{\"1\":{\"80\":1}}],[\"actually\",{\"1\":{\"80\":1}}],[\"accounts\",{\"1\":{\"79\":6,\"82\":1,\"84\":1}}],[\"accord\",{\"1\":{\"33\":1}}],[\"access\",{\"1\":{\"78\":2,\"79\":5,\"80\":7,\"82\":3,\"83\":6,\"84\":5}}],[\"addlistener\",{\"1\":{\"136\":1}}],[\"adding\",{\"1\":{\"80\":1}}],[\"additionally\",{\"1\":{\"92\":1}}],[\"additional\",{\"1\":{\"80\":4,\"83\":1}}],[\"addition\",{\"1\":{\"80\":1}}],[\"add\",{\"0\":{\"80\":1}}],[\"addentry\",{\"1\":{\"14\":2}}],[\"again\",{\"1\":{\"82\":1}}],[\"agreements\",{\"1\":{\"82\":1}}],[\"agree\",{\"1\":{\"78\":2}}],[\"ago\",{\"1\":{\"78\":1}}],[\"autowired等注解注入依赖\",{\"1\":{\"135\":1}}],[\"autocommit\",{\"1\":{\"120\":1}}],[\"autonomous\",{\"1\":{\"89\":1,\"91\":1}}],[\"automatically\",{\"1\":{\"92\":1}}],[\"automatic\",{\"1\":{\"85\":1}}],[\"auth\",{\"1\":{\"79\":1,\"83\":1}}],[\"authenticate\",{\"1\":{\"79\":1}}],[\"authorizing\",{\"1\":{\"85\":1}}],[\"authorized\",{\"1\":{\"80\":1}}],[\"authorize\",{\"1\":{\"79\":3,\"84\":2}}],[\"authorization\",{\"1\":{\"78\":6,\"79\":1,\"80\":1}}],[\"audience\",{\"1\":{\"78\":1,\"79\":1}}],[\"azure\",{\"1\":{\"77\":2,\"89\":1,\"91\":2}}],[\"aspects\",{\"1\":{\"92\":1}}],[\"assume\",{\"1\":{\"83\":1}}],[\"assertion\",{\"1\":{\"78\":1}}],[\"asking\",{\"1\":{\"82\":1}}],[\"ask\",{\"1\":{\"78\":1,\"79\":1,\"82\":1}}],[\"as\",{\"1\":{\"77\":1,\"78\":3,\"79\":5,\"80\":2,\"81\":2,\"82\":2,\"83\":2}}],[\"annotation\",{\"1\":{\"113\":3}}],[\"annoying\",{\"1\":{\"77\":1,\"80\":1}}],[\"answer\",{\"1\":{\"91\":1}}],[\"another\",{\"1\":{\"81\":1}}],[\"an\",{\"1\":{\"76\":1,\"78\":1,\"80\":2,\"81\":2,\"82\":1,\"83\":2,\"84\":1,\"85\":1}}],[\"any\",{\"1\":{\"76\":1,\"82\":1,\"91\":1,\"92\":1}}],[\"and\",{\"0\":{\"78\":1,\"83\":1},\"1\":{\"76\":2,\"77\":3,\"78\":9,\"79\":8,\"80\":4,\"81\":2,\"82\":14,\"83\":9,\"84\":3,\"85\":3,\"90\":1,\"91\":4,\"92\":12}}],[\"absolute\",{\"1\":{\"83\":1}}],[\"abstractmap<k\",{\"1\":{\"18\":1}}],[\"abstract\",{\"1\":{\"3\":5,\"110\":1}}],[\"above\",{\"1\":{\"81\":1,\"91\":1}}],[\"about\",{\"0\":{\"84\":1},\"1\":{\"76\":1,\"78\":2,\"79\":1,\"81\":2,\"84\":1,\"85\":1}}],[\"able\",{\"1\":{\"76\":1}}],[\"args\",{\"1\":{\"136\":2}}],[\"argue\",{\"1\":{\"81\":1}}],[\"artifactid>\",{\"1\":{\"127\":1}}],[\"architectures\",{\"1\":{\"91\":1,\"92\":2}}],[\"architecture\",{\"1\":{\"91\":1,\"92\":2}}],[\"around\",{\"1\":{\"78\":1}}],[\"armed\",{\"1\":{\"76\":1}}],[\"are\",{\"1\":{\"33\":1,\"76\":1,\"78\":4,\"79\":3,\"81\":2,\"82\":6,\"84\":1,\"90\":1,\"91\":2,\"92\":4}}],[\"ai\",{\"1\":{\"75\":1,\"89\":1}}],[\"attribute\",{\"1\":{\"113\":2}}],[\"attacks\",{\"1\":{\"83\":1}}],[\"atlassian\",{\"1\":{\"82\":2}}],[\"at\",{\"1\":{\"33\":1,\"76\":1,\"78\":1,\"79\":3,\"80\":2,\"81\":1,\"83\":2}}],[\"aliasfor\",{\"1\":{\"113\":2}}],[\"algorithm\",{\"1\":{\"92\":1}}],[\"allow\",{\"1\":{\"80\":1,\"84\":1,\"92\":1}}],[\"allocation\",{\"1\":{\"64\":1}}],[\"allocates\",{\"1\":{\"33\":1}}],[\"all\",{\"1\":{\"78\":1,\"92\":2}}],[\"already\",{\"1\":{\"78\":1,\"82\":1,\"83\":1,\"120\":1}}],[\"also\",{\"1\":{\"78\":2,\"79\":1,\"80\":1,\"81\":1,\"83\":2,\"92\":1}}],[\"always\",{\"1\":{\"31\":1,\"79\":1,\"81\":1,\"91\":1}}],[\"alternative\",{\"1\":{\"16\":1}}],[\"aftersingletonsinstantiated\",{\"1\":{\"133\":1}}],[\"aftercompletion方法回调时若有\",{\"1\":{\"118\":1}}],[\"aftercompletion\",{\"0\":{\"116\":1},\"1\":{\"110\":1,\"112\":1}}],[\"aftercommit\",{\"0\":{\"116\":1},\"1\":{\"110\":1,\"112\":2,\"113\":1,\"118\":1,\"119\":1}}],[\"afterward\",{\"1\":{\"80\":1}}],[\"afternodeinsertion\",{\"1\":{\"30\":1}}],[\"afternodeaccess\",{\"1\":{\"30\":1}}],[\"after\",{\"1\":{\"29\":1,\"79\":1,\"80\":1,\"82\":1,\"113\":2,\"119\":1,\"120\":2}}],[\"after两个属性\",{\"1\":{\"29\":1}}],[\"a\",{\"0\":{\"83\":1,\"85\":1},\"1\":{\"19\":2,\"25\":5,\"33\":1,\"76\":4,\"77\":1,\"78\":13,\"79\":14,\"80\":9,\"81\":6,\"82\":12,\"83\":6,\"85\":2,\"90\":3,\"91\":3,\"92\":13,\"103\":3,\"115\":3,\"117\":5}}],[\"apache\",{\"1\":{\"89\":2,\"92\":4,\"128\":1,\"136\":4}}],[\"appears\",{\"1\":{\"90\":1}}],[\"apps\",{\"1\":{\"82\":1}}],[\"appropriate\",{\"1\":{\"92\":2}}],[\"approved\",{\"1\":{\"82\":1}}],[\"approvals\",{\"0\":{\"82\":1}}],[\"approach\",{\"1\":{\"79\":1}}],[\"app\",{\"1\":{\"79\":3,\"80\":1,\"81\":1,\"82\":4,\"84\":1}}],[\"applicationcontext\",{\"1\":{\"135\":4}}],[\"applicationcontextaware\",{\"1\":{\"135\":1}}],[\"applicationeventpublisher\",{\"1\":{\"113\":1}}],[\"applicationevent\",{\"1\":{\"113\":1,\"119\":1}}],[\"application\",{\"1\":{\"3\":1,\"47\":1}}],[\"apis\",{\"0\":{\"80\":1,\"82\":1},\"1\":{\"76\":1,\"77\":3,\"78\":1,\"79\":2,\"80\":1,\"81\":1,\"82\":2,\"83\":4,\"84\":1,\"85\":1}}],[\"api\",{\"0\":{\"80\":1,\"82\":1},\"1\":{\"2\":1,\"75\":13,\"76\":3,\"77\":4,\"78\":15,\"79\":12,\"80\":12,\"81\":3,\"82\":6,\"83\":6,\"84\":1,\"85\":1,\"125\":1}}],[\"基金会无法继续使用\",{\"1\":{\"125\":1}}],[\"基金会便发布了\",{\"1\":{\"125\":1}}],[\"基本\",{\"1\":{\"80\":1}}],[\"基本上您能想象到的每种编程语言都有适用于\",{\"1\":{\"76\":1}}],[\"基本上其它方法实现都可以很容易理解了\",{\"1\":{\"16\":1}}],[\"基本不存在\",{\"1\":{\"66\":1}}],[\"基本不存在扩容情况\",{\"1\":{\"16\":1}}],[\"基本侧重于\",{\"1\":{\"34\":1}}],[\"基础使用看仓库\",{\"1\":{\"101\":1}}],[\"基础\",{\"0\":{\"9\":1}}],[\"基础字段类型处理器对象为basetypehandler<t>\",{\"1\":{\"3\":1}}],[\"基于注解\",{\"0\":{\"113\":1}}],[\"基于接口\",{\"0\":{\"112\":1}}],[\"基于配置的复制因子\",{\"1\":{\"92\":1}}],[\"基于\",{\"0\":{\"3\":1,\"82\":1},\"1\":{\"75\":1}}],[\"用例所需的\",{\"1\":{\"78\":1}}],[\"用来封装类在方法区内的数据结构\",{\"1\":{\"39\":1}}],[\"用以应对不同业务情况下的数据存储与使用\",{\"1\":{\"8\":1}}],[\"用枚举代码获取枚举对象\",{\"1\":{\"3\":1}}],[\"用于读取传递的数据\",{\"1\":{\"136\":1}}],[\"用于检测带有\",{\"1\":{\"133\":1}}],[\"用于存储所有的客户端连接\",{\"1\":{\"129\":1}}],[\"用于存放编译期生产的各种字面量和符号引用\",{\"1\":{\"67\":1}}],[\"用于避免应用重启导致的缓存冷启动后对后端业务的冲击\",{\"1\":{\"96\":1}}],[\"用于自定义转化非空\",{\"1\":{\"3\":1}}],[\"用于javatype与jdbctype之间的转换\",{\"1\":{\"3\":1}}],[\"用哪一种根据业务决定即可\",{\"1\":{\"2\":1}}],[\"在此就不多赘述\",{\"1\":{\"137\":1}}],[\"在此区域出现频率较低\",{\"1\":{\"66\":1}}],[\"在读取数据时\",{\"1\":{\"136\":1}}],[\"在端点上添加\",{\"1\":{\"135\":1}}],[\"在端点中注入\",{\"0\":{\"135\":1},\"1\":{\"135\":1}}],[\"在浏览器访问应用地址即可\",{\"1\":{\"134\":1}}],[\"在onopen函数中打印日志并向服务端发送三条数据\",{\"1\":{\"134\":1}}],[\"在项目中的src\",{\"1\":{\"134\":1}}],[\"在这两个方法中执行\",{\"1\":{\"116\":1}}],[\"在回调时事务资源可能仍然处于活跃状态并可访问\",{\"1\":{\"116\":1}}],[\"在事务明明已经提交的情况下\",{\"1\":{\"118\":1}}],[\"在事务完成后执行\",{\"1\":{\"117\":1}}],[\"在事务接口方法里\",{\"1\":{\"113\":1}}],[\"在事务方法中通过transactionsynchronizationmanager事务同步管理器注册事务同步\",{\"1\":{\"112\":1}}],[\"在相应的事务阶段回调方法中实现业务逻辑\",{\"1\":{\"112\":1}}],[\"在transactionsynchronization接口有定义\",{\"1\":{\"110\":1}}],[\"在transfer\",{\"1\":{\"16\":1}}],[\"在aftercompletion方法的入参status有三种状态\",{\"1\":{\"110\":1}}],[\"在addentry\",{\"1\":{\"14\":1}}],[\"在下方事务同步的两种使用方式本质都是利用了该抽象类来实现\",{\"1\":{\"110\":1}}],[\"在下面源码中\",{\"1\":{\"29\":1}}],[\"在常规的\",{\"1\":{\"109\":1}}],[\"在更新数据后\",{\"1\":{\"104\":1}}],[\"在配置文件中不存在\",{\"1\":{\"99\":1}}],[\"在集群环境\",{\"1\":{\"98\":1}}],[\"在遭遇\",{\"1\":{\"97\":1}}],[\"在数据库领域\",{\"1\":{\"92\":1}}],[\"在每次刷新请求时都会向您发出一个新的刷新令牌\",{\"1\":{\"83\":1}}],[\"在市场或商店上列出通常是可选的\",{\"1\":{\"82\":1}}],[\"在您的应用程序公开并可供任何用户使用之前需要经过审核\",{\"1\":{\"82\":1}}],[\"在首次实现时都存在一些问题\",{\"1\":{\"81\":1}}],[\"在不同地点为客户提供不同的数据中心\",{\"1\":{\"79\":1}}],[\"在新生代的\",{\"1\":{\"64\":1}}],[\"在新增和获取过程中\",{\"1\":{\"32\":1}}],[\"在执行时都会创建一个栈帧\",{\"1\":{\"60\":1}}],[\"在理解了\",{\"1\":{\"57\":1}}],[\"在理解了上面的内容后\",{\"1\":{\"20\":1}}],[\"在上面的架构中\",{\"1\":{\"91\":1}}],[\"在上面类加器图中我们可以看到\",{\"1\":{\"48\":1}}],[\"在上面内容中\",{\"1\":{\"34\":1}}],[\"在静态代码块赋值\",{\"1\":{\"46\":1}}],[\"在编译阶段会为\",{\"1\":{\"44\":1}}],[\"在实际开发中\",{\"1\":{\"35\":1}}],[\"在java\",{\"1\":{\"35\":1}}],[\"在resize\",{\"1\":{\"33\":1}}],[\"在发生碰撞问题时\",{\"1\":{\"26\":1}}],[\"在最后简单描述了\",{\"1\":{\"24\":1}}],[\"在聊聊\",{\"1\":{\"24\":1}}],[\"在左耳朵耗子\",{\"1\":{\"19\":1}}],[\"在getentry\",{\"1\":{\"15\":1}}],[\"在日常开发使用中\",{\"1\":{\"8\":1}}],[\"在其中封装常用的操作\",{\"1\":{\"3\":1}}],[\"在\",{\"0\":{\"74\":1},\"1\":{\"3\":1,\"16\":1,\"19\":1,\"24\":1,\"26\":4,\"29\":1,\"32\":1,\"33\":1,\"38\":2,\"66\":1,\"75\":1,\"99\":1,\"125\":1,\"139\":1}}],[\"而由字节缓冲区接收后\",{\"1\":{\"136\":1}}],[\"而closereason\",{\"1\":{\"131\":1}}],[\"而uid是通过端点路径配置的路径参数\",{\"1\":{\"129\":1}}],[\"而偏偏这个操作\",{\"1\":{\"120\":1}}],[\"而发布\",{\"1\":{\"115\":1}}],[\"而无需通过继承对象\",{\"1\":{\"112\":1}}],[\"而本篇主要讲述的事务功能是实现在事务执行的某个阶段去做某些事\",{\"1\":{\"109\":1}}],[\"而本篇的主角是\",{\"1\":{\"8\":1}}],[\"而订阅\",{\"1\":{\"104\":1}}],[\"而若配置了\",{\"1\":{\"103\":1}}],[\"而缓存本身的配置字段\",{\"1\":{\"102\":1}}],[\"而后者仅仅是\",{\"1\":{\"101\":1}}],[\"而后端获取到的参数就是一个枚举类型\",{\"1\":{\"3\":1}}],[\"而使用内存缓存导致的应用节点内存占用提升问题\",{\"1\":{\"97\":1}}],[\"而针对问题\",{\"1\":{\"97\":1}}],[\"而对于真正的分布式数据库架构\",{\"1\":{\"89\":1}}],[\"而了解\",{\"1\":{\"69\":1}}],[\"而老年代则是存放生命周期或存活时间较长的对象\",{\"1\":{\"64\":1}}],[\"而虚拟机栈是为\",{\"1\":{\"63\":1}}],[\"而分支\",{\"1\":{\"59\":1}}],[\"而创建\",{\"1\":{\"58\":2}}],[\"而是由服务器\",{\"1\":{\"135\":1}}],[\"而是缓存框架的桥梁\",{\"1\":{\"97\":1}}],[\"而是一种选择\",{\"1\":{\"84\":1}}],[\"而是实现了一个单独的\",{\"1\":{\"80\":1}}],[\"而是只实现他们认为\",{\"1\":{\"78\":1}}],[\"而是使用本地内存\",{\"1\":{\"66\":1}}],[\"而是栈内存\",{\"1\":{\"64\":1}}],[\"而是全权交由\",{\"1\":{\"58\":1}}],[\"而是通过\",{\"1\":{\"57\":1}}],[\"而自定义实现类加载器的有\",{\"1\":{\"49\":1}}],[\"而类加载器存在以下机制\",{\"1\":{\"48\":1}}],[\"而控制加载过程\",{\"1\":{\"47\":1}}],[\"而子类不会初始化\",{\"1\":{\"46\":1}}],[\"而初始化只有在对类的主动使用时才会触发\",{\"1\":{\"46\":1}}],[\"而不是\",{\"1\":{\"44\":1}}],[\"而不是通过key确定数组下标后直接存放值\",{\"1\":{\"10\":1}}],[\"而这一阶段也就会在堆区生成一个\",{\"1\":{\"41\":1}}],[\"而这些改变对\",{\"1\":{\"35\":1}}],[\"而这正巧可以作用于枚举类型字段的出参转化\",{\"1\":{\"3\":1}}],[\"而且\",{\"1\":{\"105\":1}}],[\"而且在检查缓存数据是否失效时性能极差\",{\"1\":{\"99\":1}}],[\"而且很多知识点都是零零散散\",{\"1\":{\"71\":1}}],[\"而且这一步也是可控的\",{\"1\":{\"41\":1}}],[\"而且对不了解红黑树的读者会很不友好\",{\"1\":{\"34\":1}}],[\"而且还内置了默认的类型转换器\",{\"1\":{\"3\":1}}],[\"而红黑树相关的内容\",{\"1\":{\"34\":1}}],[\"而红黑树是一种自平衡的二叉查找树\",{\"1\":{\"26\":1}}],[\"而进入该类\",{\"1\":{\"29\":1}}],[\"而选择\",{\"1\":{\"27\":1}}],[\"而链表则为\",{\"1\":{\"27\":1}}],[\"而链表则是单向的\",{\"1\":{\"10\":1}}],[\"而一旦节点数量小于等于\",{\"1\":{\"27\":1}}],[\"而在\",{\"1\":{\"25\":1,\"99\":1}}],[\"而线程二直接完成了扩容操作\",{\"1\":{\"25\":1}}],[\"而\",{\"1\":{\"19\":1,\"66\":1,\"105\":1}}],[\"而此时\",{\"1\":{\"19\":1}}],[\"而它之所以是线程安全\",{\"1\":{\"18\":1}}],[\"而第二种虽然避免了网络问题\",{\"1\":{\"2\":1}}],[\"但相比于\",{\"1\":{\"125\":1}}],[\"但拿到的却都是旧数据\",{\"1\":{\"117\":1}}],[\"但也有一些特殊情况\",{\"1\":{\"109\":1}}],[\"但最近一次版本更新还是两年前的\",{\"1\":{\"105\":1}}],[\"但当时对缓存概念理解浅薄\",{\"1\":{\"105\":1}}],[\"但由于广播操作的\",{\"1\":{\"101\":1}}],[\"但由于某种原因\",{\"1\":{\"80\":1}}],[\"但前者会调用其\",{\"1\":{\"101\":1}}],[\"但在此与\",{\"1\":{\"101\":1}}],[\"但像\",{\"1\":{\"99\":1}}],[\"但请注意\",{\"1\":{\"89\":1}}],[\"但散列不是一种选择\",{\"1\":{\"84\":1}}],[\"但有些人也默默地假设您将保留旧的刷新令牌并继续使用它\",{\"1\":{\"83\":1}}],[\"但有点特殊\",{\"1\":{\"78\":1}}],[\"但一些臭名昭著的例子可能需要几个月的时间才能完成\",{\"1\":{\"82\":1}}],[\"但一些最流行的\",{\"1\":{\"82\":1}}],[\"但一般情况下\",{\"1\":{\"32\":1}}],[\"但它们有不同的目的\",{\"1\":{\"92\":1}}],[\"但它们建立在无共享架构之上\",{\"1\":{\"89\":1}}],[\"但它们在告诉您正在发生的情况方面与上面标题中的示例一样有用\",{\"1\":{\"81\":1}}],[\"但它们通常无法提供足够的信息来帮助开发者调试问题\",{\"1\":{\"75\":1}}],[\"但他们不是仅仅为每个范围添加不同的范围\",{\"1\":{\"80\":1}}],[\"但您确实需要从那里解析它并存储它\",{\"1\":{\"80\":1}}],[\"但您最初要求它们的方式却不是标准化的\",{\"1\":{\"78\":1}}],[\"但这并不意味着系统本质上是分布式的\",{\"1\":{\"92\":1}}],[\"但这并不意味着系统是分布式的\",{\"1\":{\"89\":1}}],[\"但这通常是以开发人员付出更多工作为代价的\",{\"1\":{\"83\":1}}],[\"但这确实意味着您特别需要为每个\",{\"1\":{\"80\":1}}],[\"但这里有个要注意的点\",{\"1\":{\"49\":1}}],[\"但我们仍在等待几周后的回复\",{\"1\":{\"82\":1}}],[\"但我们认为您现在可能已经明白了要点\",{\"1\":{\"79\":1}}],[\"但我们很难责怪他们\",{\"1\":{\"78\":1}}],[\"但至少我可以选择我的回调\",{\"1\":{\"79\":1}}],[\"但要小心\",{\"1\":{\"79\":1}}],[\"但要求前后端手动同步好字典数据\",{\"1\":{\"2\":1}}],[\"但少数人\",{\"1\":{\"79\":1}}],[\"但真正关心的是提示参数\",{\"1\":{\"79\":1}}],[\"但\",{\"1\":{\"78\":1,\"132\":1}}],[\"但是由于机器网卡带宽跑满\",{\"1\":{\"97\":1}}],[\"但是\",{\"1\":{\"78\":1,\"90\":1}}],[\"但是它们能接受的符号引用必须是一致的\",{\"1\":{\"45\":1}}],[\"但实际上每个\",{\"1\":{\"77\":1}}],[\"但许多\",{\"1\":{\"75\":1,\"80\":1}}],[\"但即使只关注相关的部分\",{\"1\":{\"75\":1}}],[\"但每个\",{\"1\":{\"75\":1}}],[\"但其本身并不能跨平台\",{\"1\":{\"57\":1}}],[\"但其内部方法实现基本相同\",{\"1\":{\"29\":1}}],[\"但事无巨细\",{\"1\":{\"50\":1}}],[\"但本质上并没有直接引用定义常量的类\",{\"1\":{\"46\":1}}],[\"但如果是下面的声明方式\",{\"1\":{\"44\":1}}],[\"但treenode<k\",{\"1\":{\"29\":1}}],[\"但synchronize是重量级锁\",{\"1\":{\"18\":1}}],[\"但获取到的参数若直接是枚举类型\",{\"1\":{\"3\":1}}],[\"倘若查询列表数据过多且字典字段存在好几个\",{\"1\":{\"3\":1}}],[\"比如\",{\"1\":{\"67\":1}}],[\"比如声明如下\",{\"1\":{\"44\":1}}],[\"比如classes=\",{\"1\":{\"115\":1}}],[\"比如class\",{\"1\":{\"39\":1}}],[\"比如根据值获取文本\",{\"1\":{\"3\":1}}],[\"比如根据订单状态执行不同操作\",{\"1\":{\"2\":1}}],[\"比如性别gender\",{\"1\":{\"3\":1}}],[\"++j\",{\"1\":{\"33\":1}}],[\"++size\",{\"1\":{\"30\":1}}],[\"++modcount\",{\"1\":{\"30\":1}}],[\"++bincount\",{\"1\":{\"30\":1}}],[\"+o\",{\"1\":{\"26\":2}}],[\"+1\",{\"1\":{\"14\":2}}],[\"+\",{\"0\":{\"3\":1},\"1\":{\"3\":2,\"16\":1,\"33\":2,\"103\":2,\"112\":2,\"117\":1,\"120\":6}}],[\"针对枚举字典的出入参转化进行介绍\",{\"1\":{\"2\":1}}],[\"以\",{\"1\":{\"104\":1}}],[\"以便他们可以在需要时重新授权您的应用程序\",{\"1\":{\"84\":1}}],[\"以保证其描述的信息符合\",{\"1\":{\"43\":1}}],[\"以让低\",{\"1\":{\"32\":1}}],[\"以key\",{\"1\":{\"9\":1}}],[\"以及刷新令牌的附加限制\",{\"1\":{\"83\":1}}],[\"以及几乎所有拥有集成市场或应用程序商店的其他人都需要经过审核才能在其中列出\",{\"1\":{\"82\":1}}],[\"以及令牌响应中的访问令牌\",{\"1\":{\"80\":1}}],[\"以及树节点平衡被打破后的处理情况等内容比较复杂\",{\"1\":{\"34\":1}}],[\"以及\",{\"1\":{\"3\":1}}],[\"以下代码是随便写写\",{\"1\":{\"101\":1}}],[\"以下是原本+翻译\",{\"1\":{\"89\":1}}],[\"以下是原文+翻译\",{\"1\":{\"75\":1}}],[\"以下是我们见过的一小部分非标准扩展\",{\"1\":{\"80\":1}}],[\"以下是太长不看版\",{\"1\":{\"75\":1,\"89\":1}}],[\"以下部分是遍历链表节点进行复制\",{\"1\":{\"33\":1}}],[\"以下三个方法调用\",{\"1\":{\"3\":1}}],[\"以下内容是基于第二种方案\",{\"1\":{\"2\":1}}],[\"以免出错\",{\"1\":{\"2\":1}}],[\"这些系统中的节点相互了解\",{\"1\":{\"92\":1}}],[\"这些数据库实例不相互通信\",{\"1\":{\"91\":1}}],[\"这通常会导致出现有关范围存在问题的通用错误消息\",{\"1\":{\"81\":1}}],[\"这需要通过参数\",{\"1\":{\"79\":1}}],[\"这导致文档中出现相当长的页面来概述\",{\"1\":{\"78\":1}}],[\"这个是同步发送\",{\"1\":{\"128\":1}}],[\"这个名字的商标归\",{\"1\":{\"125\":1}}],[\"这个变量后面恢复连接自动提交时会用到\",{\"1\":{\"120\":1}}],[\"这个词\",{\"1\":{\"79\":1}}],[\"这个\",{\"1\":{\"78\":1,\"102\":1}}],[\"这个过程可能需要数天甚至数月才能完成\",{\"1\":{\"75\":1}}],[\"这个过程走下来\",{\"1\":{\"47\":1}}],[\"这个过程称为\",{\"1\":{\"16\":1}}],[\"这意味着开发者需要为每个\",{\"1\":{\"75\":1}}],[\"这篇文章讨论了为什么\",{\"1\":{\"75\":1}}],[\"这篇里讲解的非常清楚\",{\"1\":{\"19\":1}}],[\"这对于我个人的知识总结能力也大有脾益\",{\"1\":{\"71\":1}}],[\"这是第三条消息\",{\"1\":{\"134\":1}}],[\"这是第二条消息\",{\"1\":{\"134\":1}}],[\"这是第一条消息\",{\"1\":{\"134\":1}}],[\"这是\",{\"1\":{\"81\":1}}],[\"这是因为二级缓存\",{\"1\":{\"101\":1}}],[\"这是因为\",{\"1\":{\"66\":1}}],[\"这是连接的第一步\",{\"1\":{\"43\":1}}],[\"这就是为什么客户端必须始终通过协调器路由其请求\",{\"1\":{\"91\":1}}],[\"这就是为什么修改了\",{\"1\":{\"48\":1}}],[\"这就是我们构建\",{\"1\":{\"85\":1}}],[\"这就是\",{\"1\":{\"81\":1}}],[\"这就导致\",{\"1\":{\"32\":1}}],[\"这就导致了并发扩容时\",{\"1\":{\"25\":1}}],[\"这一段的配置是指使用\",{\"1\":{\"103\":1}}],[\"这一步从数据库连接池里获取连接\",{\"1\":{\"120\":1}}],[\"这一步开发者可以控制外\",{\"1\":{\"47\":1}}],[\"这一步后\",{\"1\":{\"47\":1}}],[\"这一步主要是在方法区中为类变量分配内存\",{\"1\":{\"44\":1}}],[\"这一篇\",{\"1\":{\"38\":1}}],[\"这才有了转换的必要\",{\"1\":{\"27\":1}}],[\"这两个方法在\",{\"1\":{\"116\":1}}],[\"这两个方法主要是数组扩容和数据复制\",{\"1\":{\"16\":1}}],[\"这两步获取元素的时间复杂度为\",{\"1\":{\"26\":1}}],[\"这样服务端可通过\",{\"1\":{\"137\":1}}],[\"这样来确保对二级缓存\",{\"1\":{\"97\":1}}],[\"这样的例子还在继续\",{\"1\":{\"79\":1}}],[\"这样子的好处是保证了使用不同的类加载器最终得到的都是同样一个\",{\"1\":{\"48\":1}}],[\"这样就避免了死链问题\",{\"1\":{\"25\":1}}],[\"这样就无需依赖\",{\"1\":{\"2\":1}}],[\"这样在扩容时就不会出现元素逆序的情况\",{\"1\":{\"25\":1}}],[\"这也是为什么\",{\"1\":{\"10\":1}}],[\"这里是从连接池获取连接的操作\",{\"1\":{\"120\":1}}],[\"这里选择了\",{\"1\":{\"101\":1}}],[\"这里以\",{\"1\":{\"101\":1}}],[\"这里就不多赘述\",{\"1\":{\"16\":1}}],[\"这里需要注意\",{\"1\":{\"10\":1}}],[\"这里补充一个关于枚举字典的抽象优化\",{\"1\":{\"4\":1}}],[\"这里的做法是字段名使用参数名+name\",{\"1\":{\"3\":1}}],[\"这避免不了需要在前端存储一份字典数据的问题\",{\"1\":{\"2\":1}}],[\"前身是\",{\"1\":{\"125\":1}}],[\"前的\",{\"1\":{\"20\":1}}],[\"前言\",{\"0\":{\"8\":1,\"24\":1,\"109\":1}}],[\"前端总是需要对字典数据做一些特殊处理\",{\"1\":{\"2\":1}}],[\"前后端可约定好ping发送的消息内容\",{\"1\":{\"137\":1}}],[\"前后端传递字典数值即可\",{\"1\":{\"3\":1}}],[\"前后端根据业务约定好字典内容后\",{\"1\":{\"2\":1}}],[\"前后端同步\",{\"1\":{\"2\":1}}],[\"前后端需要时调用接口获取\",{\"1\":{\"2\":1}}],[\"因对\",{\"1\":{\"138\":1}}],[\"因为端点并非由\",{\"1\":{\"135\":1}}],[\"因为后者在\",{\"1\":{\"125\":1}}],[\"因为会根据\",{\"1\":{\"104\":1}}],[\"因为在\",{\"1\":{\"103\":1}}],[\"因为这样管理起来非常复杂\",{\"1\":{\"99\":1}}],[\"因为它们各自有不同的优点和适用场景\",{\"1\":{\"89\":1}}],[\"因为他们已经在使用其他系统\",{\"1\":{\"82\":1}}],[\"因为\",{\"1\":{\"64\":1,\"101\":1,\"117\":1,\"120\":1,\"133\":1}}],[\"因为该参数是告诉虚拟机是否要对类进行初始化\",{\"1\":{\"46\":1}}],[\"因为符号引用的字面量形式明确定义在\",{\"1\":{\"45\":1}}],[\"因为扩容后\",{\"1\":{\"33\":1}}],[\"因为扩容为n\",{\"1\":{\"33\":1}}],[\"因为使用的是\",{\"1\":{\"33\":1}}],[\"因为泛型指定为\",{\"1\":{\"3\":1}}],[\"因为上面为枚举抽象了一个统一接口basicenum\",{\"1\":{\"3\":1}}],[\"因为要转化的是枚举类型\",{\"1\":{\"3\":1}}],[\"因为根据实际情况\",{\"1\":{\"2\":1}}],[\"因此笔者在此记录并做了补充\",{\"1\":{\"138\":1}}],[\"因此该变量是线程安全的\",{\"1\":{\"128\":1}}],[\"因此将其改为\",{\"1\":{\"125\":1}}],[\"因此方法参数指定为applicationevent类型即可\",{\"1\":{\"119\":1}}],[\"因此便可利用事务同步来控制步骤\",{\"1\":{\"117\":1}}],[\"因此便有了这个开头\",{\"1\":{\"71\":1}}],[\"因此不受\",{\"1\":{\"117\":1}}],[\"因此不必太担心\",{\"1\":{\"78\":1}}],[\"因此还是推荐不设置参数\",{\"1\":{\"115\":1}}],[\"因此事务同步回调时可获取该事件的信息\",{\"1\":{\"113\":1}}],[\"因此可以根据不同的业务场景来规划不同的\",{\"1\":{\"99\":1}}],[\"因此可以直接利用它来创建一个类型处理器\",{\"1\":{\"3\":1}}],[\"因此您最好将动态\",{\"1\":{\"79\":1}}],[\"因此您很快就会陷入被迫详细阅读其长页\",{\"1\":{\"79\":1}}],[\"因此最终会得到许多不同的\",{\"1\":{\"78\":1}}],[\"因此最终加载任务都会传递到顶层的启动类加载器\",{\"1\":{\"48\":1}}],[\"因此元空间的大小仅受本地内存限制\",{\"1\":{\"66\":1}}],[\"因此从\",{\"1\":{\"64\":1}}],[\"因此具体的虚拟机可以自由实现它\",{\"1\":{\"63\":1}}],[\"因此扩容时不需要重新计算\",{\"1\":{\"33\":1}}],[\"因此在多线程并发应用中使用是比较少的\",{\"1\":{\"18\":1}}],[\"因此\",{\"1\":{\"3\":1,\"26\":1,\"91\":1,\"96\":1,\"105\":1,\"135\":1}}],[\"因工作琐事\",{\"1\":{\"0\":1}}],[\"交由数据库维护\",{\"1\":{\"2\":1}}],[\"一是实现规范所提供的接口\",{\"1\":{\"128\":1}}],[\"一\",{\"0\":{\"124\":1}}],[\"一文的翻译\",{\"1\":{\"89\":1}}],[\"一文的中文翻译\",{\"1\":{\"75\":1}}],[\"一种开源\",{\"1\":{\"85\":1}}],[\"一定有更好的方法\",{\"1\":{\"85\":1}}],[\"一起返回给您\",{\"1\":{\"80\":1}}],[\"一些\",{\"1\":{\"79\":1}}],[\"一些配置还有内容还需要时间慢慢缝补\",{\"1\":{\"0\":1}}],[\"一次编译\",{\"1\":{\"57\":1}}],[\"一组符号来描述目标\",{\"1\":{\"45\":1}}],[\"一旦应用重启后\",{\"1\":{\"97\":1}}],[\"一旦您知道您的\",{\"1\":{\"78\":1}}],[\"一旦\",{\"1\":{\"11\":1}}],[\"一般在项目当中\",{\"1\":{\"2\":1}}],[\"序列化\",{\"1\":{\"3\":1}}],[\"序\",{\"0\":{\"2\":1}}],[\"从源码可看到事务同步作用就是在事务执行的各个阶段进行方法回调\",{\"1\":{\"110\":1}}],[\"从源码可以看出\",{\"1\":{\"10\":1}}],[\"从何而来以及静态配置如何生效即可\",{\"1\":{\"101\":1}}],[\"从现在开始的几秒钟内\",{\"1\":{\"83\":1}}],[\"从表面上看\",{\"1\":{\"83\":1}}],[\"从而判断数据是否超出了缓冲区大小\",{\"1\":{\"136\":1}}],[\"从而获取数据\",{\"1\":{\"129\":1}}],[\"从而实现事务的功能\",{\"1\":{\"120\":1}}],[\"从而了解数据分布\",{\"1\":{\"92\":1}}],[\"从而在\",{\"1\":{\"66\":1}}],[\"从而引发\",{\"1\":{\"66\":1}}],[\"从图片我们知道\",{\"1\":{\"39\":1}}],[\"从\",{\"1\":{\"0\":1,\"117\":1}}],[\"25\",{\"1\":{\"82\":2}}],[\"2^16\",{\"1\":{\"32\":1}}],[\"2018\",{\"1\":{\"125\":1}}],[\"2017\",{\"1\":{\"125\":1}}],[\"20m\",{\"1\":{\"101\":1}}],[\"2000\",{\"1\":{\"101\":1}}],[\"2008\",{\"1\":{\"75\":1,\"77\":2}}],[\"200\",{\"1\":{\"3\":1}}],[\"2023\",{\"0\":{\"74\":1,\"76\":2},\"1\":{\"0\":1,\"75\":2}}],[\"2020\",{\"1\":{\"0\":2}}],[\"2\",{\"0\":{\"79\":2},\"1\":{\"3\":1,\"8\":1,\"11\":1,\"14\":2,\"15\":1,\"16\":2,\"27\":1,\"30\":2,\"31\":1,\"32\":1,\"33\":9,\"46\":1,\"75\":2,\"76\":2,\"78\":12,\"83\":2,\"96\":1,\"97\":1,\"101\":2,\"103\":1,\"104\":2,\"105\":1,\"110\":1,\"113\":1,\"117\":4,\"127\":2,\"138\":1,\"139\":1}}],[\"21\",{\"1\":{\"0\":1}}],[\"积累经验\",{\"1\":{\"0\":1}}],[\"0a\",{\"1\":{\"78\":2,\"83\":2}}],[\"0001\",{\"1\":{\"33\":2}}],[\"0000\",{\"1\":{\"33\":2}}],[\"0\",{\"1\":{\"3\":1,\"11\":1,\"14\":3,\"15\":3,\"16\":1,\"25\":1,\"30\":2,\"31\":1,\"32\":1,\"33\":12,\"44\":1,\"75\":1,\"76\":2,\"78\":8,\"101\":3,\"103\":1,\"110\":1,\"115\":1,\"128\":1,\"139\":1}}],[\"09\",{\"1\":{\"0\":2}}],[\"08\",{\"1\":{\"0\":2}}],[\"07\",{\"1\":{\"0\":1}}],[\"~\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
