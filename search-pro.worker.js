const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":52,\"nextId\":52,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-e005054c\",\"2\":\"v-e005054c#前言\",\"3\":\"v-e005054c#基础\",\"4\":\"v-e005054c#结构\",\"5\":\"v-e005054c#属性\",\"6\":\"v-e005054c#常用方法\",\"7\":\"v-e005054c#方法原理\",\"8\":\"v-e005054c#put-方法实现\",\"9\":\"v-e005054c#get-方法实现\",\"10\":\"v-e005054c#resize-transfer-方法实现\",\"11\":\"v-e005054c#补充\",\"12\":\"v-e005054c#与-hashtable-的区别\",\"13\":\"v-e005054c#hashmap-死链问题\",\"14\":\"v-e005054c#总结\",\"15\":\"v-e005054c@0\",\"16\":\"v-e005054c@1\",\"17\":\"v-71db46f9\",\"18\":\"v-71db46f9#前言\",\"19\":\"v-71db46f9#死链原因和解决方法\",\"20\":\"v-71db46f9#结构变化\",\"21\":\"v-71db46f9#链表与红黑树转换时机\",\"22\":\"v-71db46f9#原理解析\",\"23\":\"v-71db46f9#node-k-v-和-treenode-k-v\",\"24\":\"v-71db46f9#put-方法\",\"25\":\"v-71db46f9#get-方法\",\"26\":\"v-71db46f9#hash-方法\",\"27\":\"v-71db46f9#resize-方法\",\"28\":\"v-71db46f9#关于红黑树\",\"29\":\"v-71db46f9#尾声\",\"30\":\"v-71db46f9@0\",\"31\":\"v-71db46f9@1\",\"32\":\"v-2560cb50\",\"33\":\"v-2560cb50#前言\",\"34\":\"v-2560cb50#事务同步接口\",\"35\":\"v-2560cb50#使用方式\",\"36\":\"v-2560cb50#基于接口\",\"37\":\"v-2560cb50#基于注解\",\"38\":\"v-2560cb50#注意事项\",\"39\":\"v-2560cb50#注解方式方法入参问题\",\"40\":\"v-2560cb50#aftercommit-aftercompletion-事务范围问题\",\"41\":\"v-2560cb50#实际场景\",\"42\":\"v-2560cb50#思考题\",\"43\":\"v-2560cb50#问题一\",\"44\":\"v-2560cb50#问题二\",\"45\":\"v-2560cb50#总结\",\"46\":\"v-2560cb50@0\",\"47\":\"v-2560cb50@1\",\"48\":\"v-09041878\",\"49\":\"v-e1e3da16\",\"50\":\"v-7783265c\",\"51\":\"v-1a2ef2a6\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,28],\"1\":[2],\"2\":[1,25],\"3\":[1,16],\"4\":[1,60],\"5\":[1,50],\"6\":[1,39],\"7\":[1,7],\"8\":[2,99],\"9\":[2,59],\"10\":[3,104],\"11\":[1],\"12\":[3,33],\"13\":[2,38],\"14\":[1,30],\"15\":[null,null,1],\"16\":[null,null,3],\"17\":[5],\"18\":[1,28],\"19\":[1,75],\"20\":[1,40],\"21\":[1,40],\"22\":[1],\"23\":[4,69],\"24\":[2,126],\"25\":[2,57],\"26\":[2,59],\"27\":[2,218],\"28\":[1,22],\"29\":[1,28],\"30\":[null,null,1],\"31\":[null,null,3],\"32\":[2],\"33\":[1,18],\"34\":[1,49],\"35\":[1],\"36\":[1,50],\"37\":[1,98],\"38\":[1],\"39\":[1,37],\"40\":[3,15],\"41\":[1,111],\"42\":[1,14],\"43\":[1,30],\"44\":[1,157],\"45\":[1,16],\"46\":[null,null,1],\"47\":[null,null,2],\"48\":[1],\"49\":[1],\"50\":[1],\"51\":[1]},\"averageFieldLength\":[1.4897212931995543,53.536954619750965,0.3936887254901961],\"storedFields\":{\"0\":{\"h\":\"关于作者\",\"t\":[\"Java 开发一枚 (●ˇ∀ˇ●) ~，博客刚切换，一些配置还有内容还需要时间慢慢缝补。\",\"2020.07.08，使用 Hexo 首次建立个人博客，也在同一天发布了第一篇文章\",\"2020.08.09，因工作琐事，加上深感自己对技术的理解还不够深入，经验也不够充足，所以停更，更专注地学习各项技术\",\"2023.09.21，时隔三年，重拾博客，从 Hexo 转向 VuePress\",\"Continue...\"]},\"1\":{\"h\":\"聊聊 HashMap\"},\"2\":{\"h\":\"前言\",\"t\":[\"Map，Java 三大集合框架之一，JDK1.2 时便已存在，是一个Key-Value键值对映射的接口，即一个Key对应一个Value。在日常开发使用中，我们常见的 Map 实现类有：HashMap、Hashtable、TreeMap、LinkedHashMap 等，用以应对不同业务情况下的数据存储与使用。而本篇的主角是 HashMap，让我们来粗浅的聊聊它吧。（注意：本篇 HashMap 的源码和原理讲解全部基于 JDK1.7）\"]},\"3\":{\"h\":\"基础\",\"t\":[\"HashMap 是基于哈希表（Hashtable）的 Map 实现类，以Key-Value形式保存数据，Key唯一，Value可重复，并采用 Hash 算法确定Key-Value的存储位置从而保证其进行数据快速存取。类图如下：\",\"HashMap 类图\"]},\"4\":{\"h\":\"结构\",\"t\":[\"HashMap 的底层结构是 数组+链表，是通过计算key的hash值来确定数组下标位置，然后将key和value作为Entry<K,V>对象进行存储。这里需要注意，是作为 Entry<K,V> 对象存储，而不是通过key确定数组下标后直接存放值。Entry<K,V> 是 Map 的内部接口，本质上是一个映射（键值对），HashMap 类中对它有一个静态实现，如下：\",\"static class Entry<K,V> implements Map.Entry<K,V> { final K key; V value; Entry<K,V> next; //链表节点中的下一个 Entry<K,V> 对象 int hash; //当前 Entry 对象的 hash 值 //构造函数 Entry(int h, K k, V v, Entry<K,V> n) { value = v; next = n; key = k; hash = h; } //其它代码省略 ... } \",\"从源码可以看出，Entry<K,V>对象保存了key、value、hash值，还保存了当前Entry<K,V>对象的下一个Entry<K,V>对象：Entry<K,V> next。这也是为什么 HasHMap 结构是数组+链表，数组其实就是Entry<K,V>类型数组，而链表则是单向的，每个节点都是一个Entry<K,V>对象，并保存了下一个Entry<K,V>节点的数据，通过一张图来简单理解下：\",\"HashMap 结构图\"]},\"5\":{\"h\":\"属性\",\"t\":[\"HashMap 内部定义的几个主要属性如下：\",\"transient Entry[] table：Entry<K,V>对象数组，长度始终保持为 2 的幂次方\",\"transient int size：HashMap 已存储的元素数量\",\"final float loadFactor：负载因子，默认是 0.75，扩容时使用\",\"static final int DEFAULT_INITIAL_CAPACITY：HashMap 的默认初始容量\",\"int threshold：阈值，当 HashMap 存储的元素数量达到该值，则会触发扩容操作\",\"transient int modCount：记录 HashMap 结构修改的次数，如修改值、重新扩容等\",\"HashMap 阈值大小计算为： capacity(容量) * loadFactor(负载因子) = threshold(阈值) ，capacity也就是构建 HashMap 时指定的容量大小（不指定则默认为 16）。一旦 HashMap 的size超过阈值，就会进行扩容操作，重新调整 HashMap 的大小以便存放更多的元素。\"]},\"6\":{\"h\":\"常用方法\",\"t\":[\"public int size()：返回 HashMap 的元素数量\",\"public boolean isEmpty()：判断 HashMap 是否为空\",\"public V put(K key, V value)：存放键值对，即数据元素\",\"public V get(Object key)：通过key获取Value`\",\"public V remove(Object key)：通过key删除元素\",\"public void clear()：清空 HashMap\",\"public boolean containsKey(Object key)：判断传递的key在 HashMap 中是否已存在\",\"public boolean containsValue(Object value)：判断传递的value是否已有key进行映射\",\"public Set keySet()：获取所有key的 Set 集合\",\"public Set> entrySet()：获取所有Entry<K,V>的 Set 集合，可以用来遍历 HashMap\"]},\"7\":{\"h\":\"方法原理\",\"t\":[\"接下来我们具体看看 HashMap 设值、取值、扩容、复制数据等方法的具体实现是怎么样的。\"]},\"8\":{\"h\":\"put 方法实现\",\"t\":[\"public V put(K key, V value) { if (key == null) return putForNullKey(value); //1.判断 key 是否为 Null，为 Null 直接存放在数组下标 0 的位置 int hash = hash(key); //2.计算 key 的 hash 值 int i = indexFor(hash, table.length); //3.通过 hash 值计算数组下标 index for (Entry<K,V> e = table[i]; e != null; e = e.next) { Object k; //4.判断 hash 值和 key 值是否相同，相同则覆盖并返回旧值 if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //5.修改次数 +1 addEntry(hash, key, value, i); //6.将 key-value 封装为 Entry 对象并添加， return null; } static int indexFor(int h, int length) { return h & (length-1); // 数组长度-1，按位与计算出下标 } void addEntry(int hash, K key, V value, int bucketIndex) { //如果加入新元素超过阈值，则扩容为原来的2倍大小 if ((size >= threshold) && (null != table[bucketIndex])) { resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); // 创建 Entry } void createEntry(int hash, K key, V value, int bucketIndex) { Entry<K,V> e = table[bucketIndex]; //若 e 不为空，则说明发生 hash 碰撞，将 Entry 插入到链表头，将原有节点(e)作为下一个节点 table[bucketIndex] = new Entry<>(hash, key, value, e); size++; //HashMap 元素数量 +1 } \",\"根据上方源码总结下步骤：\",\"判断key是否为null，为null则直接存放到数组下标为 0 的位置；\",\"计算key的 hash 值并通过该值确定数组下标位置；\",\"判断key是否重复，重复则覆盖并返回旧值；\",\"在addEntry()方法判断是否需要扩容，最后将key-value封装为Entry<K,V>对象保存。\"]},\"9\":{\"h\":\"get 方法实现\",\"t\":[\"理解了put()方法后，get()方法就简单多了，直接上源码：\",\"public V get(Object key) { if (key == null) return getForNullKey(); //1.判断 key 是否 Null，为空直接获取数组下标为 0 的元素 Entry<K,V> entry = getEntry(key); return null == entry ? null : entry.getValue(); //三目表达式判断 } final Entry<K,V> getEntry(Object key) { int hash = (key == null) ? 0 : hash(key); //计算 key 的 hash 值 //2.indexFor() 计算数组下标并循环遍历该下标处的链表节点 for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null;e = e.next) { Object k; //3.判断是否 hash 值和 key 值是否相同且不为 null，不匹配则循环判断下一节点 if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } return null; } \",\"步骤如下：\",\"判断key是否 null，为 null 直接取数组下标为 0 的元素；\",\"在getEntry()方法里计算key的hash值找到下标然后循环遍历判断key的值，存在返回值，不存在则返回null。\"]},\"10\":{\"h\":\"resize/transfer 方法实现\",\"t\":[\"这两个方法主要是数组扩容和数据复制，在 HashMap 中，这个过程称为 rehashing。源码如下：\",\"void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; //1.获取旧数组长度 //MAXIMUM_CAPACITY 的值为 1<<30，是 Integer.MAX_VALUE 的一半减1，已经大的夸张，基本不存在扩容情况 //所以重新设置阈值后直接返回 if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } //2.创建一个新的数组，大小为原来的2倍 Entry[] newTable = new Entry[newCapacity]; //3.获取是否需要重新计算 hash boolean oldAltHashing = useAltHashing; useAltHashing |= sun.misc.VM.isBooted() && (newCapacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean rehash = oldAltHashing ^ useAltHashing; //4.扩容的关键方法，旧数组数据复制到新数组 transfer(newTable, rehash); table = newTable; //5.重新计算阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; //遍历旧数组 for (Entry<K,V> e : table) { //遍历当前节点的链表 while(null != e) { Entry<K,V> next = e.next; //判断是否需要重新计算 hash if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); //计算数组下标 e.next = newTable[i]; //头插法，链表头部插入，已有的节点往后移作为 next 节点 newTable[i] = e; //头部插入 e = next; } } } \",\"过程理解起来也不难：\",\"创建大小为原来 2 倍的新数组；\",\"在transfer()方法将旧数组数据循环遍历复制到新数组（关键）；\",\"将新数组赋值给 HashMap 的table变量，并重新计算阈值。\",\"理解清楚 HashMap 的设值、取值、扩容复制原理后，基本上其它方法实现都可以很容易理解了，这里就不多赘述。\"]},\"11\":{\"h\":\"补充\"},\"12\":{\"h\":\"与 Hashtable 的区别\",\"t\":[\"HashMap\",\"key 允许为 Null（唯一）\",\"线程不安全\",\"效率较高\",\"继承于 AbstractMap<K,V>\",\"Hashtable\",\"key 不为空\",\"线程安全\",\"效率较低\",\"继承于 Dictionary<K,V>\",\"Hashtable 的key不能为空，是因为put()方法里作了判断，为空直接抛出 NPE 异常；而它之所以是线程安全，通过源码可知是因为内部方法都加上了 Synchronize同步锁，但Synchronize是重量级锁，容易引起线程上下文切换而带来线程调度的开销，因此在多线程并发应用中使用是比较少的，推荐使用 ConcurrentHashMap，其采用的是分段锁，效率比 Hashtable 要高出许多。\"]},\"13\":{\"h\":\"HashMap 死链问题\",\"t\":[\"HashMap 死链是指在 Java 并发情况下，多线程操作 HashMap 产生 Race Condition(竞用条件)，而此时 HashMap 刚好需要扩容，导致旧数据复制到新数组产生死循环。简单讲就是链表中 A(Entry) 的 next 属性指向 B(Entry)，而 B 的 next 属性又指向 A。\",\"关于死链具体情况，在左耳朵耗子-陈皓的《疫苗：Java HashMap的死循环》这篇里讲解的非常清楚，很清晰易懂。并且死链情况在 Java 8 中已经得到解决，在 Java 8 版本开始，HashMap 的结构就变为了 数组+链表+红黑树，后续新篇章也会对 Java 8 的 HashMap 作下介绍讲解。\"]},\"14\":{\"h\":\"总结\",\"t\":[\"最后来概括下 HashMap 的工作原理：当通过put()方法存值时会调用key.hashCode()计算哈希值从而获取数组下标，并将Key-Value作为 Entry<K,V> 对象进行存储，调用get()方法时同样计算key的哈希值然后获取数组下标，然后通过 key.equals()判断值是否相同，最终返回结果。当存值时若元素数量大于阈值threshold则进行扩容，大小为原来的2倍。\",\"Java 8 前的 HashMap 原理并不复杂，至于其它的一些细枝末节，在理解了上面的内容后，自己去查看源码学习，就会很轻松了。\"]},\"15\":{\"c\":[\"Java\"]},\"16\":{\"c\":[\"Java\",\"HashMap\",\"集合\"]},\"17\":{\"h\":\"Java 8 中 HashMap 的改变\"},\"18\":{\"h\":\"前言\",\"t\":[\"在聊聊 HashMap 篇中，通过 JDK1.7 的 HashMap 的几个方法：put()、get()、resize()/transfer()讲解了其原理，在最后简单描述了 HashMap 死链问题。引出了在 Java 8 中，HashMap 底层结构变化为 数组+链表+红黑树，提高了查询效率，并解决了死链问题。我们就以此作为切入点，来看看 HashMap 在 Java 8 版本有了哪些变化。\"]},\"19\":{\"h\":\"死链原因和解决方法\",\"t\":[\"Java 8 之前的 HashMap 并发扩容出现死链，原因之一是链表节点的存储方式引起，即 头插法。每当添加新元素时，都是放在链表头节点，原头节点就变成新节点的 next 节点。这就导致了并发扩容时，若链表元素 rehash 后依旧在同一个数组下标位置，则链表元素会出现逆序（或翻转），即 A-B-C 变成 C-B-A。另一个是因为复制数据是在 while 循环里遍历一个节点就插入到新的数组位置，假设有两个线程，线程一获取到 A 节点以及下一节点 B 后就被阻塞，而线程二直接完成了扩容操作，链表变成 C-B-A，当线程一恢复运行后，B 的下一节点又变成 A，死链就出现了。\",\"再次贴上复制数据的方法源码，方便大家回顾：\",\"// JDK 7 源码 void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry<K,V> e : table) { while(null != e) { Entry<K,V> next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } } } \",\"而在 Java 8 中则更改为 尾插法，即添加的新元素会放在链表尾节点，这样在扩容时就不会出现元素逆序的情况，并且在扩容方法的 while 循环复制数据中，是将索引下标处的链表节点全部遍历获取后，再存入到新数组中，这样就避免了死链问题。关于其逻辑实现在下面会讲到，可以先看下图简单对比头插法和尾插法：\",\"HashMap 7/8 链表结构\"]},\"20\":{\"h\":\"结构变化\",\"t\":[\"Java 8 中，HashMap 底层结构变为 数组+链表+红黑树，显著提高了查询效率。在 HashMap 中，获取元素可以简单分为以下两步：\",\"根据key.hashCode()获取 hash 值，然后确定数组下标 index；\",\"若数组下标位置节点key不匹配，则遍历链表，通过key.equals()查找。\",\"在 Java 8 之前只是用链表解决冲突问题，在发生碰撞问题时，这两步获取元素的时间复杂度为 O(1)+O(n)。因此，当碰撞频率高时 n 变大，查询速度就会受到影响。在 Java 8 中则利用红黑树替代链表，而红黑树是一种自平衡的二叉查找树，如此一来，获取元素的时间复杂度就变为 O(1)+O(log n)，在 n 变大时，能够理想地解决查询效率变低的问题。\"]},\"21\":{\"h\":\"链表与红黑树转换时机\",\"t\":[\"当发生哈希碰撞时，首先用链表存储，当链表节点数量大于等于 8 时，就会转换为红黑树，而一旦节点数量小于等于 6，红黑树又会转换为链表。当节点数量达到 8 时，红黑树的平均查找时间为 3(log 8)，而链表则为 4(8/2)，这才有了转换的必要。而选择 6 和 8，中间存在差值 7，是假设当链表长度大于小于 8 时，红黑树和链表就互相转换，若 HashMap 存储的元素数量在 8 徘徊，频繁增删，红黑树和链表就会频繁转换，效率将会降低。\",\"static final int TREEIFY_THRESHOLD = 8; //HashMap 默认的转换为红黑树的节点阈值 static final int UNTREEIFY_THRESHOLD = 6; // 默认的转换为链表的节点阈值 \"]},\"22\":{\"h\":\"原理解析\"},\"23\":{\"h\":\"Node<K,V> 和 TreeNode<K,V>\",\"t\":[\"在 Java 8 之前，key-value是用Entry<K,V>对象保存，Java 8 中则变为Node<K,V>，但其内部方法实现基本相同，依旧实现Map.Entry<K,V>接口，下面是源码：\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; V value; Node<K,V> next; Node(int hash, K key, V value, Node<K,V> next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } // ...其它代码省略... } \",\"重要的是内部静态类增加了TreeNode<K,V>，该类也就是红黑树节点对象，在下面源码中，TreeNode<K,V>类是继承LinkedHashMap.Entry<K,V>类，而进入该类，可以看到其实也是继承HashMap.Node<K,V>类，并含有before、after两个属性，但TreeNode<K,V>本身并没有直接使用到这两个属性，只是维护了双向链表的应用，便于在红黑树和链表之间进行转换：\",\"static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> { TreeNode<K,V> parent; // 红黑树根节点 TreeNode<K,V> left; // 左节点 TreeNode<K,V> right; // 右节点 TreeNode<K,V> prev; // 当前节点的前一节点 boolean red; // 是否为红色节点 TreeNode(int hash, K key, V val, Node<K,V> next) { super(hash, key, val, next); // 调用父类的构造方法 } // ...其它代码省略... } // LinkedHashMap.Entry<K,V> 的实现 static class Entry<K,V> extends HashMap.Node<K,V> { Entry<K,V> before, after; Entry(int hash, K key, V value, Node<K,V> next) { super(hash, key, value, next); // 调用父类 HashMap.Node<K,V> 的构造方法 } } \"]},\"24\":{\"h\":\"put 方法\",\"t\":[\"依旧是从put()方法开始，直接上源码：\",\"public V put(K key, V value) { // 1、获取 key 的 Hash 值 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; // 2、判断 table 是否为空，为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 3、计算数组下标，判断该位置是否为空，为空直接添加 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node<K,V> e; K k; // 4、判断 hash 值和 key 是否相同，相同赋值给 e if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 5、若为树节点，执行 putTreeVal() 添加 else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { // 6、遍历链表，尾插法 for (int binCount = 0; ; ++binCount) { // 6.1、next 节点为空直接添加 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 6.2、当链表节点数量 >= 8 则转换为红黑树 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 6.3、next 节点不为空，则判断是否与当前遍历节点相同 if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } // 7、e 不为空则进行覆盖并返回旧值 if (e != null) { // existing mapping for key V oldValue = e.value; // 7.1、onlyIfAbsent 表示是否覆盖已存在的值 // put()默认传递 false 覆盖， putIfAbsent()传递 true 不覆盖 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size > threshold) // 8、判断是否超过阈值，超过则扩容 resize(); afterNodeInsertion(evict); return null; } \",\"总结下步骤：\",\"获取key的 hash 值，然后进入putVal()方法，若 table 为空则先创建；\",\"计算数组下标，判断下标处元素，若为空直接新增，不为空先判断key.equals(k)；\",\"不同说明发生碰撞，判断是否为树节点，是则调用putTreeVal()新增树节点；\",\"若是链表节点，则遍历到链表尾部判断，当节点不存在则新增（尾插法）；\",\"如果链表长度大于等于TREEIFY_THRESHOLD，就将链表转换为红黑树；\",\"若节点已经存在,则替换旧值oldValue并返回；\",\"最后判断容量若大于阈值，就进行扩容resize()。\"]},\"25\":{\"h\":\"get 方法\",\"t\":[\"public V get(Object key) { Node<K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node<K,V> getNode(int hash, Object key) { Node<K,V>[] tab; Node<K,V> first, e; int n; K k; // 1、获取数组下标位置第一个节点，命中则直接返回 if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; // 2、若为树节点则调用 getTreeNode() 去获取 if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K,V>)first).getTreeNode(hash, key); // 4、若为链表则遍历判断 do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"获取元素的逻辑还是比较简单，步骤如下：\",\"计算key的 hash 值找到数组下标，若下标处第一个节点匹配则返回；\",\"若有冲突，判断是树节点还是链表节点，然后通过key.equals(k)查找匹配的节点。\"]},\"26\":{\"h\":\"Hash 方法\",\"t\":[\"在新增和获取过程中，计算下标时，先对 key 的哈希值进行 hash 操作，再进一步计算下标，如下图所示：\",\"Hash 计算\",\"对key.hashCode()的 hash 操作实现如下：\",\"static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } // 计算下标方式：(n-1) & hash \",\"在 Java 8 之前原本是直接 & 运算获取下标，但一般情况下 HashMap 长度都小于 2^16，这就导致 & 运算的一直是哈希值的低 16 位甚至更低，假设长度为 16，则下标运算的结果取决于哈希值的低 4 位（即长度为 2 的 n 次方，位运算结果取决于低 n 位）。为了让哈希值的低 16 位更随机，便让哈希值与高 16 位（h >>> 16）进行异或运算，以让低 16 位更随机散列，减少碰撞。\"]},\"27\":{\"h\":\"resize 方法\",\"t\":[\"在resize()方法上有这么一段注释：\",\"Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.\",\"其意思大概就是初始化或增加数组大小，如果数组本就为空，则按默认值进行初始化，否则，因为使用的是 2 次幂扩展（即原来大小的 2 倍），元素存放在新数组要么是原位置，要么是原位置加上 2 次幂。搭配一张图来看就会很好理解：\",\"扩容计算\",\"因为扩容为n << 1，即 2 倍，所以 n-1 就是在高位多 1 bit（红色），若多出的高位 bit 经过 & 运算为 1，则元素 index 变为 原索引+原数组容量(即 2 次幂)，为 0 则不需要变化。因此扩容时不需要重新计算 hash 值，只需要在 原 hash 值跟原数组长度 & 运算 后判断是否等于 0 来确定是否需要移动即可。举个例子，假设数组长度原本是 16，n(16) -1 = 0000 1111，n(16) = 0001 0000，因为扩容后 n(32)-1 = 0001 1111，高位多 1 bit ，所以直接同 16 进行 & 运算效果相当于只跟高位 bit 进行位运算，如下图：\",\"高位 & 运算\",\"来看下resize()方法的源码，在 6.3 处就体现了上面说的元素是否需要移动的判断：\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 1、若是超过最大值，则不扩容，任由其碰撞了 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 2、不超过最大值则扩容为原来的 2 倍 else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } // 3、若无数据，则用初始化阈值赋值 else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; // 4、若无数据并且阈值为 0，则使用默认值设置 else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 5、若新数组未设置阈值，则进入此处计算新的 threshold if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) { // 6、遍历旧数组复制数据 for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; // 6.1、若当前节点没有冲突，则计算新的数组下标直接存值 if (e.next == null) newTab[e.hash & (newCap - 1)] = e; // 6.2、若为树节点，则调用 TreeNode.split() else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // preserve order // 6.3、以下部分是遍历链表节点进行复制，并判断节点在新数组的位置 // loHead：不需要改变位置的链表头节点，hiHead：需要改变位置的链表头节点 // loTail 和 hiTail 则是对应链表尾节点 Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; // 6.3.1、为 0 说明原索引位置存值 if ((e.hash & oldCap) == 0) { if (loTail == null) // 6.3.2、尾节点为空，则链表为空，头节点指向当前遍历节点 e(仅第一次) loHead = e; else // 6.3.3、尾节点不为空，则链表存在，将尾节点指向当前遍历节点 e loTail.next = e; // 6.3.4、将尾节点指向当前遍历节点 e loTail = e; } // 6.3.5、不为 0 说明新位置是原索引 + oldCap(旧容量) else { // 与上面同理 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 6.3.6、判断两个尾节点，不为空说明链表存在，将头节点保存在相应位置 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } \",\"扩容方法实现逻辑重点在于复制数据的 for 循环中，简单分为以下几步：\",\"若当前遍历的节点元素位置没有冲突，则直接计算新的数组下标存值；\",\"若为树节点，调用TreeNode.split()方法进行具体操作；\",\"若为链表节点则进行遍历，通过元素原 hash 值与旧数组长度 & 运算判断位置是否需要移动，采用两个头节点和两个尾节点保存元素构成链表，再将链表头节点存放到新数组的相应位置。\"]},\"28\":{\"h\":\"关于红黑树\",\"t\":[\"在上面内容中，基本侧重于 HashMap 整体的实现逻辑描述，而红黑树相关的内容，如新增树节点、链表红黑树互转等则讲解不多。主要是因为红黑树结构、以及树节点平衡被打破后的处理情况等内容比较复杂，讲解起来会很啰嗦冗余，而且对不了解红黑树的读者会很不友好。此处附上文章：程序员小灰 - 什么是红黑树，供感兴趣的读者学习下红黑树的相关知识（已会可忽略），结合上面对于 HashMap 的原理解析，再去查看关于红黑树操作的源码，理解起来就会比较轻松了 (●ˇ∀ˇ●) 。\"]},\"29\":{\"h\":\"尾声\",\"t\":[\"Java 8 HashMap 原理宏观上跟以前的思路差不多，主要是在新增、获取、删除元素和扩容等方法增加了对红黑树节点的判断，重要的变化可以简单归纳为：底层结构新增红黑树、链表存储方式变为尾插法，hash() 方法优化。而这些改变对 HashMap 性能提升影响是比较大的，在Java 8 中 HashMap 的性能提升一文中含有性能测试的结果。\",\"在实际开发中，HashMap 使用是非常频繁的，掌握原理，有助于我们在使用时，若遇到异常 Bug，可以快速定位、解决问题，并且 HashMap 也是面试经典问题了。\"]},\"30\":{\"c\":[\"Java\"]},\"31\":{\"c\":[\"Java\",\"HashMap\",\"集合\"]},\"32\":{\"h\":\"Spring 事务同步\"},\"33\":{\"h\":\"前言\",\"t\":[\"事务功能在日常开发中使用并不少，本质上是为了保证一次业务请求处理过程中涉及多次 DB 数据操作时的原子性。而本篇主要讲述的事务功能是实现在事务执行的某个阶段去做某些事，即事务同步。在常规的 Web 应用中，大多是直接使用@Transactional注解方法来完成事务操作，但也有一些特殊情况，需要在事务提交前、提交后等情况下执行某些操作，如资源准备、清理、自定义操作等。\"]},\"34\":{\"h\":\"事务同步接口\",\"t\":[\"事务同步回调接口是TransactionSynchronization，其抽象实现TransactionSynchronizationAdapter源码如下：\",\"public abstract class TransactionSynchronizationAdapter implements TransactionSynchronization, Ordered { // 事务同步回调顺序，当存在多个事务同步且有顺序要去时可指定 @Override public int getOrder() { return Ordered.LOWEST_PRECEDENCE; } // 事务挂起 @Override public void suspend() { } // 事务回复 @Override public void resume() { } // 底层数据会话刷新，需要事务管理器有刷新概念，否则无操作 @Override public void flush() { } // 事务提交前 @Override public void beforeCommit(boolean readOnly) { } // 事务完成前（包括异常回滚） @Override public void beforeCompletion() { } // 事务提交后 @Override public void afterCommit() { } // 事务完成后（包括异常回滚） @Override public void afterCompletion(int status) { } } \",\"从源码可看到事务同步作用就是在事务执行的各个阶段进行方法回调，并可通过Ordered接口控制多个事务同步的执行顺序，在下方事务同步的两种使用方式本质都是利用了该抽象类来实现。 在afterCompletion方法的入参status有三种状态（在TransactionSynchronization接口有定义）：\",\"0：事务完成\",\"1：事务回滚\",\"2：未知错误\"]},\"35\":{\"h\":\"使用方式\"},\"36\":{\"h\":\"基于接口\",\"t\":[\"需要继承TransactionSynchronizationAdapte抽象类，在相应的事务阶段回调方法中实现业务逻辑\",\"在事务方法中通过TransactionSynchronizationManager事务同步管理器注册事务同步\",\"// 创建 public class TxSyncDemo extends TransactionSynchronizationAdapter { private String txName; public TxSyncDemo(String txName) { this.txName = txName; } @Override public void afterCommit() { System.out.println(\\\"事务提交后回调...\\\") } @Override public void afterCompletion(int status) { System.out.println(\\\"事务完成后回调...\\\") System.out.println(\\\"事务名称：\\\" + txName); System.out.println(\\\"事务状态：\\\" + status); } } // 事务接口方法 @RestController public class TxController { @GetMapping(\\\"txDemo\\\") @Transactional(rollbackFor = Exception.class) public void txDemo() { // 模拟 DB 操作：更新和新增 update(); save(); // 注册事务同步对象 TransactionSynchronizationManager.registerSynchronization(new TxSyncDemo(\\\"事务同步测试\\\")); } } \",\"之后调用事务接口，即可看到如下结果：\",\"控制台结果\"]},\"37\":{\"h\":\"基于注解\",\"t\":[\"注解方式需要通过@TransactionalEventListener与ApplicationEvent事件对象两者搭配使用，先看看注解的源码，如下：\",\"@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @EventListener public @interface TransactionalEventListener { // 指定事务阶段 TransactionPhase phase() default TransactionPhase.AFTER_COMMIT; // 不存在事务时，注解的方法是否依然被调用，true 则表示只要事件发布了就回调 boolean fallbackExecution() default false; // ... @AliasFor(annotation = EventListener.class, attribute = \\\"classes\\\") Class[] value() default { }; // 指定感兴趣的事件类名 @AliasFor(annotation = EventListener.class, attribute = \\\"classes\\\") Class[] classes() default { }; // 事务回调的条件，可通过 SpEL 进行编写 String condition() default \\\"\\\"; } \",\"实现步骤：\",\"创建事件对象\",\"使用注解标记方法，并通过注解属性指定回调时的事务阶段和感兴趣的事件\",\"在事务接口方法里，发布相应的事件\",\"// 步骤 1：创建事件类 // 可在这个事件类里注入其它依赖或声明业务逻辑，因此事务同步回调时可获取该事件的信息 public class TxSyncEvent extends ApplicationEvent { public TxSyncEvent(Object source) { super(source); } } // 步骤 2：使用事务注解 @Component public class TxSyncDemo { @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, classes = TxSyncEvent.class) public void afterCommit() { System.out.println(\\\"事务提交后回调...\\\"); } } // 步骤 3：事务方法里发布事件 @RestController public class TxController { @Resource private ApplicationEventPublisher publisher; @GetMapping(\\\"txDemo\\\") @Transactional(rollbackFor = Exception.class) public void txDemo() { // 模拟 DB 操作：更新和新增 update(); save(); // 发布事件 publisher.publishEvent(new TxSyncEvent(\\\"source\\\")); } } \",\"之后调用事务接口，即可看到注解方法内的内容输出，过于简单不再展示结果图片。\"]},\"38\":{\"h\":\"注意事项\"},\"39\":{\"h\":\"注解方式方法入参问题\",\"t\":[\"按@TransactionalEventListener注解classes属性是否有指定值分情况说明：\",\"无值 \",\"方法入参只能为 0 或 1 个（任意类型）\",\"若方法入参为事件类型，则代表是感兴趣的事件，等同于classes指定了该事件\",\"若方法入参为空或不为事件类型，则表示方法不关心任何事件，任何时候都不会被回调\",\"有值 \",\"只有一个值时，入参必须为该值对应的事件类型，否则抛出参数类型错误异常\",\"多个值时，则入参不需要指定\",\"经过实际测试，classes指定多个值时，入参依然可指定为某个事件类型，若事务方法发布的事件刚好与参数的事件类型一致，则可以正确回调。比如classes={A.class, B.class}，方法入参类型为 A，发布 A 事件时可正确执行，而发布 B 事件则会抛出异常。因此还是推荐不设置参数。\"]},\"40\":{\"h\":\"afterCommit / afterCompletion 事务范围问题\",\"t\":[\"这两个方法在 javadoc 上的描述是：在回调时事务资源可能仍然处于活跃状态并可访问。 经过实际测试，在这两个方法中执行 DB 数据操作，那么操作依旧会参与原事务，会等到方法执行完清理事务资源后，才会真正提交到数据库。可通过TransactionSynchronizationManager.isActualTransactionActive()来判断当前方法是否处于活跃事务中。\"]},\"41\":{\"h\":\"实际场景\",\"t\":[\"举个在我司 IM 系统中的例子，如添加好友，该请求处理步骤如下：\",\"数据库 f_req（好友请求） 表添加记录数据，删除目标好友（target）的 f_req 缓存（Redis）\",\"发送通知给 target，让其拉取最新好友请求记录（通过 Netty 异步发送通知）\",\"事务提交，数据真正落库，返回请求处理结果（success / fail）\",\"由于步骤 2 通过 Netty 的 Channel 异步发送通知，因此不受 Spring 事务管理。若只是使用事务注解标记整个处理流程，那么当执行到步骤 2 时，由于事务未提交（DB 数据未更新），当 target 收到通知后重新来查询 f_req，就只会查到旧数据（即缺少最新的请求记录），下图展示过程：假设 A + B 为好友\",\"场景示例\",\"结合上图梳理流程如下：\",\"A 发起好友请求（Request 1），服务端开启事务，DB 新增数据，删除 B 的 f_req 缓存\",\"服务端发送通知给 B，通知 B 来查询最新的 f_req 数据\",\"当服务端接收 B 的查询请求（Request 2）后，先查询缓存，由于缓存被删除，则查询 DB；因为 Request 1 的事务未提交，所以肯定只会查到旧的 f_req 记录，即 A 发送的 f_req 没了\",\"Request 1 的请求处理完成，事务提交，所有数据落库\",\"从 B 的视角来看，虽然被通知要拉取 f_req，但拿到的却都是旧数据，根本就没有 A 发出的 f_req，属实是“虚空好友请求”了。更糟糕的是，由于旧数据的查询，缓存重新被添加回来，导致图中步骤 1 的缓存删了等于没删，出现缓存与 DB 数据不一致情况，并且至少得等到下一次有用户对 B 发起 f_req，才能将本次的 f_req 数据刷新到缓存。\",\"为避免出现这种情况，就需要保证 B 发起查询请求时，A 的添加好友请求已处理完毕，数据已落库；因此便可利用事务同步来控制步骤 2 在事务完成后执行。\",\"（PS：可能读者会有疑惑，添加请求在流程中明明只有一次 DB 操作，为何还要加事务？原因是流程做了简化，添加好友的流程除了处理好友请求记录外，还会判断用户好友历史记录是否添加过目标用户，若有也会去修改 DB 数据。）\"]},\"42\":{\"h\":\"思考题\",\"t\":[\"上方说到事务同步注解方式若classes指定了多个值，方法入参推荐不指定，那么在方法体里如果获取本次事务监听的事件信息呢？\",\"afterCommit/afterCompletion方法回调时若有 DB 数据操作，在事务明明已经提交的情况下，为何还会参与原始事务，并且得等到清理资源时才提交？\",\"（PS：想想再看答案，也可以先带着问题去阅读下源码）\"]},\"43\":{\"h\":\"问题一\",\"t\":[\"第一个问题比较简单，由于事件类都需要继承ApplicationEvent作为父类，因此方法参数指定为ApplicationEvent类型即可，然后通过instanceof或Class.isAssignableForm()判断类型，再搭配上策略模式优雅代码。\",\"@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, classes = {AEvent.class, BEvent.class}) public void afterCommit(ApplicationEvent event) { if (event instanceof AEvent) { // do something... } else if (event instanceof BEvent) { // do something... } // 觉得多重 if 丑陋就使用策略模式 } \"]},\"44\":{\"h\":\"问题二\",\"t\":[\"之所以事务提交还会参与原始事务，是跟 Spring 的事务机制有关，Spring 事务的本质是获取到 DB 的连接（Connection）后修改连接的自动提交autoCommit为false（默认是true），然后由 Spring 自己控制提交的时机，从而实现事务的功能。\",\"既然修改了连接的autoCommit，那么事务执行完后就得将连接恢复到初始状态，即修改autoCommit=true。而偏偏这个操作，是在执行事务回调完成后，清理资源时才会去执行，也就导致了事务回调期间的 DB 操作都没有被提交，最后只能依赖连接的autoCommit恢复后，由连接本身去做提交操作（因为 Spring 不会再有提交操作）。\",\"连接获取后autoCommit的修改源码如下：\",\"@Override protected void doBegin(Object transaction, TransactionDefinition definition) { // 省略其它代码... Connection con = null; // 这里是从连接池获取连接的操作 try { if (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) { // 这一步从数据库连接池里获取连接 Connection newCon = obtainDataSource().getConnection(); if (logger.isDebugEnabled()) { logger.debug(\\\"Acquired Connection [\\\" + newCon + \\\"] for JDBC transaction\\\"); } // 保存连接在 ConnectionHolder 对象中 txObject.setConnectionHolder(new ConnectionHolder(newCon), true); } txObject.getConnectionHolder().setSynchronizedWithTransaction(true); con = txObject.getConnectionHolder().getConnection(); // 隔离级别与只读设置 Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition); txObject.setPreviousIsolationLevel(previousIsolationLevel); txObject.setReadOnly(definition.isReadOnly()); // Switch to manual commit if necessary. This is very expensive in some JDBC drivers, // so we don't want to do it unnecessarily (for example if we've explicitly // configured the connection pool to set it already). // 当连接默认为自动提交时，才设置为手动提交 if (con.getAutoCommit()) { // mustRestoreAutoCommit 这个变量后面恢复连接自动提交时会用到 txObject.setMustRestoreAutoCommit(true); if (logger.isDebugEnabled()) { logger.debug(\\\"Switching JDBC Connection [\\\" + con + \\\"] to manual commit\\\"); } con.setAutoCommit(false); } } catch (Throwable ex) { // 省略... } } \",\"事务完成后连接autoCommit修改源码如下：\",\"@Override protected void doCleanupAfterCompletion(Object transaction) { DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; // Remove the connection holder from the thread, if exposed. // 解绑资源 if (txObject.isNewConnectionHolder()) { TransactionSynchronizationManager.unbindResource(obtainDataSource()); } // 获取连接进行重置 Connection con = txObject.getConnectionHolder().getConnection(); try { // mustRestoreAutoCommit 变量在修改 autoCommit 为 false 时便设置为 true if (txObject.isMustRestoreAutoCommit()) { // 恢复为自动提交，执行完这一步，事务回调中的 DB 操作就会提交 con.setAutoCommit(true); } DataSourceUtils.resetConnectionAfterTransaction( con, txObject.getPreviousIsolationLevel(), txObject.isReadOnly()); } catch (Throwable ex) { logger.debug(\\\"Could not reset JDBC Connection after transaction\\\", ex); } if (txObject.isNewConnectionHolder()) { if (logger.isDebugEnabled()) { logger.debug(\\\"Releasing JDBC Connection [\\\" + con + \\\"] after transaction\\\"); } // 释放连接，将连接回收到数据库连接池 DataSourceUtils.releaseConnection(con, this.dataSource); } txObject.getConnectionHolder().clear(); } \",\"如上即为连接获取后autoCommit的修改操作。\",\"注意其中事务完成后释放连接这一步（DataSourceUtils.releaseConnection），Spring 同样会持有 DB 连接直到事务回调执行完成后清理资源才释放，所以尽量不要在事务回调中执行耗时较久的操作，否则可能导致 DB 连接无意义占用而引发连接池溢出。\"]},\"45\":{\"h\":\"总结\",\"t\":[\"Spring 事务在日常开发中应用不少，对事务的特性和使用需有所理解，避免因使用不当而带来开发问题。并且利用事务同步功能，也可达到缩小事务范围的效果。同时在事务回调中，尽量不要有 DB 操作和执行耗时较长的操作。若有必要，就新开事务执行 DB 操作，若只是代码执行耗时，则善用线程池异步处理。\"]},\"46\":{\"c\":[\"Spring\"]},\"47\":{\"c\":[\"Spring\",\"Transaction\"]},\"48\":{\"h\":\"Java\"},\"49\":{\"h\":\"Posts\"},\"50\":{\"h\":\"Spring\"},\"51\":{\"h\":\"Framework\"}},\"dirtCount\":0,\"index\":[[\"尽量不要有\",{\"1\":{\"45\":1}}],[\"同时在事务回调中\",{\"1\":{\"45\":1}}],[\"同样会持有\",{\"1\":{\"44\":1}}],[\"避免因使用不当而带来开发问题\",{\"1\":{\"45\":1}}],[\"连接无意义占用而引发连接池溢出\",{\"1\":{\"44\":1}}],[\"连接直到事务回调执行完成后清理资源才释放\",{\"1\":{\"44\":1}}],[\"连接获取后autocommit的修改源码如下\",{\"1\":{\"44\":1}}],[\"释放连接\",{\"1\":{\"44\":1}}],[\"恢复为自动提交\",{\"1\":{\"44\":1}}],[\"解绑资源\",{\"1\":{\"44\":1}}],[\"解决问题\",{\"1\":{\"29\":1}}],[\"省略\",{\"1\":{\"44\":1}}],[\"省略其它代码\",{\"1\":{\"44\":1}}],[\"隔离级别与只读设置\",{\"1\":{\"44\":1}}],[\"保存连接在\",{\"1\":{\"44\":1}}],[\"由连接本身去做提交操作\",{\"1\":{\"44\":1}}],[\"由于事件类都需要继承applicationevent作为父类\",{\"1\":{\"43\":1}}],[\"由于事务未提交\",{\"1\":{\"41\":1}}],[\"由于旧数据的查询\",{\"1\":{\"41\":1}}],[\"由于缓存被删除\",{\"1\":{\"41\":1}}],[\"由于步骤\",{\"1\":{\"41\":1}}],[\"既然修改了连接的autocommit\",{\"1\":{\"44\":1}}],[\"问题二\",{\"0\":{\"44\":1}}],[\"问题一\",{\"0\":{\"43\":1}}],[\"丑陋就使用策略模式\",{\"1\":{\"43\":1}}],[\"觉得多重\",{\"1\":{\"43\":1}}],[\"第一个问题比较简单\",{\"1\":{\"43\":1}}],[\"想想再看答案\",{\"1\":{\"42\":1}}],[\"上方说到事务同步注解方式若classes指定了多个值\",{\"1\":{\"42\":1}}],[\"上的描述是\",{\"1\":{\"40\":1}}],[\"思考题\",{\"0\":{\"42\":1}}],[\"还会判断用户好友历史记录是否添加过目标用户\",{\"1\":{\"41\":1}}],[\"还保存了当前entry<k\",{\"1\":{\"4\":1}}],[\"才设置为手动提交\",{\"1\":{\"44\":1}}],[\"才能将本次的\",{\"1\":{\"41\":1}}],[\"才会真正提交到数据库\",{\"1\":{\"40\":1}}],[\"出现缓存与\",{\"1\":{\"41\":1}}],[\"导致图中步骤\",{\"1\":{\"41\":1}}],[\"导致旧数据复制到新数组产生死循环\",{\"1\":{\"13\":1}}],[\"了\",{\"1\":{\"41\":1}}],[\"虚空好友请求\",{\"1\":{\"41\":1}}],[\"属实是\",{\"1\":{\"41\":1}}],[\"属性又指向\",{\"1\":{\"13\":1}}],[\"属性指向\",{\"1\":{\"13\":1}}],[\"属性\",{\"0\":{\"5\":1}}],[\"根本就没有\",{\"1\":{\"41\":1}}],[\"根据key\",{\"1\":{\"20\":1}}],[\"根据上方源码总结下步骤\",{\"1\":{\"8\":1}}],[\"虽然被通知要拉取\",{\"1\":{\"41\":1}}],[\"所有数据落库\",{\"1\":{\"41\":1}}],[\"所以尽量不要在事务回调中执行耗时较久的操作\",{\"1\":{\"44\":1}}],[\"所以肯定只会查到旧的\",{\"1\":{\"41\":1}}],[\"所以直接同\",{\"1\":{\"27\":1}}],[\"所以\",{\"1\":{\"27\":1}}],[\"所以重新设置阈值后直接返回\",{\"1\":{\"10\":1}}],[\"所以停更\",{\"1\":{\"0\":1}}],[\"没了\",{\"1\":{\"41\":1}}],[\"通知\",{\"1\":{\"41\":1}}],[\"通过元素原\",{\"1\":{\"27\":1}}],[\"通过源码可知是因为内部方法都加上了\",{\"1\":{\"12\":1}}],[\"通过\",{\"1\":{\"8\":1,\"18\":1,\"41\":2}}],[\"通过key\",{\"1\":{\"20\":1}}],[\"通过key删除元素\",{\"1\":{\"6\":1}}],[\"通过key获取value`\",{\"1\":{\"6\":1}}],[\"通过一张图来简单理解下\",{\"1\":{\"4\":1}}],[\"服务端发送通知给\",{\"1\":{\"41\":1}}],[\"服务端开启事务\",{\"1\":{\"41\":1}}],[\"新增数据\",{\"1\":{\"41\":1}}],[\"新增树节点\",{\"1\":{\"24\":1}}],[\"场景示例\",{\"1\":{\"41\":1}}],[\"下图展示过程\",{\"1\":{\"41\":1}}],[\"下面是源码\",{\"1\":{\"23\":1}}],[\"收到通知后重新来查询\",{\"1\":{\"41\":1}}],[\"那么事务执行完后就得将连接恢复到初始状态\",{\"1\":{\"44\":1}}],[\"那么在方法体里如果获取本次事务监听的事件信息呢\",{\"1\":{\"42\":1}}],[\"那么当执行到步骤\",{\"1\":{\"41\":1}}],[\"那么操作依旧会参与原事务\",{\"1\":{\"40\":1}}],[\"异步发送通知\",{\"1\":{\"41\":2}}],[\"异常\",{\"1\":{\"12\":1}}],[\"让其拉取最新好友请求记录\",{\"1\":{\"41\":1}}],[\"让我们来粗浅的聊聊它吧\",{\"1\":{\"2\":1}}],[\"发起查询请求时\",{\"1\":{\"41\":1}}],[\"发起\",{\"1\":{\"41\":1}}],[\"发起好友请求\",{\"1\":{\"41\":1}}],[\"发出的\",{\"1\":{\"41\":1}}],[\"发送的\",{\"1\":{\"41\":1}}],[\"发送通知给\",{\"1\":{\"41\":1}}],[\"发布\",{\"1\":{\"39\":1}}],[\"发布事件\",{\"1\":{\"37\":1}}],[\"发布相应的事件\",{\"1\":{\"37\":1}}],[\"缓存重新被添加回来\",{\"1\":{\"41\":1}}],[\"缓存\",{\"1\":{\"41\":2}}],[\"删除\",{\"1\":{\"41\":1}}],[\"删除目标好友\",{\"1\":{\"41\":1}}],[\"删除元素和扩容等方法增加了对红黑树节点的判断\",{\"1\":{\"29\":1}}],[\"表添加记录数据\",{\"1\":{\"41\":1}}],[\"表示是否覆盖已存在的值\",{\"1\":{\"24\":1}}],[\"好友请求\",{\"1\":{\"41\":1}}],[\"该请求处理步骤如下\",{\"1\":{\"41\":1}}],[\"该类也就是红黑树节点对象\",{\"1\":{\"23\":1}}],[\"系统中的例子\",{\"1\":{\"41\":1}}],[\"举个在我司\",{\"1\":{\"41\":1}}],[\"举个例子\",{\"1\":{\"27\":1}}],[\"实际场景\",{\"0\":{\"41\":1}}],[\"实现步骤\",{\"1\":{\"37\":1}}],[\"实现类\",{\"1\":{\"3\":1}}],[\"实现类有\",{\"1\":{\"2\":1}}],[\"会等到方法执行完清理事务资源后\",{\"1\":{\"40\":1}}],[\"事件则会抛出异常\",{\"1\":{\"39\":1}}],[\"事件时可正确执行\",{\"1\":{\"39\":1}}],[\"事务在日常开发中应用不少\",{\"1\":{\"45\":1}}],[\"事务的本质是获取到\",{\"1\":{\"44\":1}}],[\"事务管理\",{\"1\":{\"41\":1}}],[\"事务范围问题\",{\"0\":{\"40\":1}}],[\"事务方法里发布事件\",{\"1\":{\"37\":1}}],[\"事务接口方法\",{\"1\":{\"36\":1}}],[\"事务状态\",{\"1\":{\"36\":1}}],[\"事务名称\",{\"1\":{\"36\":1}}],[\"事务回调中的\",{\"1\":{\"44\":1}}],[\"事务回调的条件\",{\"1\":{\"37\":1}}],[\"事务回滚\",{\"1\":{\"34\":1}}],[\"事务回复\",{\"1\":{\"34\":1}}],[\"事务完成\",{\"1\":{\"34\":1}}],[\"事务完成后连接autocommit修改源码如下\",{\"1\":{\"44\":1}}],[\"事务完成后回调\",{\"1\":{\"36\":1}}],[\"事务完成后\",{\"1\":{\"34\":1}}],[\"事务完成前\",{\"1\":{\"34\":1}}],[\"事务提交\",{\"1\":{\"41\":2}}],[\"事务提交后回调\",{\"1\":{\"36\":1,\"37\":1}}],[\"事务提交后\",{\"1\":{\"34\":1}}],[\"事务提交前\",{\"1\":{\"34\":1}}],[\"事务挂起\",{\"1\":{\"34\":1}}],[\"事务功能在日常开发中使用并不少\",{\"1\":{\"33\":1}}],[\"事务同步测试\",{\"1\":{\"36\":1}}],[\"事务同步回调顺序\",{\"1\":{\"34\":1}}],[\"事务同步回调接口是transactionsynchronization\",{\"1\":{\"34\":1}}],[\"事务同步接口\",{\"0\":{\"34\":1}}],[\"事务同步\",{\"0\":{\"32\":1}}],[\"比如classes=\",{\"1\":{\"39\":1}}],[\"入参依然可指定为某个事件类型\",{\"1\":{\"39\":1}}],[\"入参必须为该值对应的事件类型\",{\"1\":{\"39\":1}}],[\"多个值时\",{\"1\":{\"39\":1}}],[\"多线程操作\",{\"1\":{\"13\":1}}],[\"有值\",{\"1\":{\"39\":1}}],[\"有助于我们在使用时\",{\"1\":{\"29\":1}}],[\"任何时候都不会被回调\",{\"1\":{\"39\":1}}],[\"任意类型\",{\"1\":{\"39\":1}}],[\"任由其碰撞了\",{\"1\":{\"27\":1}}],[\"个\",{\"1\":{\"39\":1}}],[\"或\",{\"1\":{\"39\":1}}],[\"或翻转\",{\"1\":{\"19\":1}}],[\"无值\",{\"1\":{\"39\":1}}],[\"按\",{\"1\":{\"39\":1}}],[\"按位与计算出下标\",{\"1\":{\"8\":1}}],[\"过于简单不再展示结果图片\",{\"1\":{\"37\":1}}],[\"过程理解起来也不难\",{\"1\":{\"10\":1}}],[\"步骤\",{\"1\":{\"37\":3}}],[\"步骤如下\",{\"1\":{\"9\":1,\"25\":1}}],[\"可能读者会有疑惑\",{\"1\":{\"41\":1}}],[\"可在这个事件类里注入其它依赖或声明业务逻辑\",{\"1\":{\"37\":1}}],[\"可通过transactionsynchronizationmanager\",{\"1\":{\"40\":1}}],[\"可通过\",{\"1\":{\"37\":1}}],[\"可以快速定位\",{\"1\":{\"29\":1}}],[\"可以看到其实也是继承hashmap\",{\"1\":{\"23\":1}}],[\"可以先看下图简单对比头插法和尾插法\",{\"1\":{\"19\":1}}],[\"可以用来遍历\",{\"1\":{\"6\":1}}],[\"指定感兴趣的事件类名\",{\"1\":{\"37\":1}}],[\"指定事务阶段\",{\"1\":{\"37\":1}}],[\"先查询缓存\",{\"1\":{\"41\":1}}],[\"先看看注解的源码\",{\"1\":{\"37\":1}}],[\"先对\",{\"1\":{\"26\":1}}],[\"控制台结果\",{\"1\":{\"36\":1}}],[\"之所以事务提交还会参与原始事务\",{\"1\":{\"44\":1}}],[\"之后调用事务接口\",{\"1\":{\"36\":1,\"37\":1}}],[\"之前原本是直接\",{\"1\":{\"26\":1}}],[\"之前\",{\"1\":{\"23\":1}}],[\"之前只是用链表解决冲突问题\",{\"1\":{\"20\":1}}],[\"之前的\",{\"1\":{\"19\":1}}],[\"注解方式方法入参问题\",{\"0\":{\"39\":1}}],[\"注解方式需要通过\",{\"1\":{\"37\":1}}],[\"注解的方法是否依然被调用\",{\"1\":{\"37\":1}}],[\"注册事务同步对象\",{\"1\":{\"36\":1}}],[\"注意其中事务完成后释放连接这一步\",{\"1\":{\"44\":1}}],[\"注意事项\",{\"0\":{\"38\":1}}],[\"注意\",{\"1\":{\"2\":1}}],[\"更糟糕的是\",{\"1\":{\"41\":1}}],[\"更新和新增\",{\"1\":{\"36\":1,\"37\":1}}],[\"更专注地学习各项技术\",{\"1\":{\"0\":1}}],[\"模拟\",{\"1\":{\"36\":1,\"37\":1}}],[\"未知错误\",{\"1\":{\"34\":1}}],[\"包括异常回滚\",{\"1\":{\"34\":2}}],[\"底层数据会话刷新\",{\"1\":{\"34\":1}}],[\"底层结构新增红黑树\",{\"1\":{\"29\":1}}],[\"底层结构变为\",{\"1\":{\"20\":1}}],[\"底层结构变化为\",{\"1\":{\"18\":1}}],[\"自己控制提交的时机\",{\"1\":{\"44\":1}}],[\"自己去查看源码学习\",{\"1\":{\"14\":1}}],[\"自定义操作等\",{\"1\":{\"33\":1}}],[\"清理资源时才会去执行\",{\"1\":{\"44\":1}}],[\"清理\",{\"1\":{\"33\":1}}],[\"清空\",{\"1\":{\"6\":1}}],[\"提交后等情况下执行某些操作\",{\"1\":{\"33\":1}}],[\"提高了查询效率\",{\"1\":{\"18\":1}}],[\"需要继承transactionsynchronizationadapte抽象类\",{\"1\":{\"36\":1}}],[\"需要事务管理器有刷新概念\",{\"1\":{\"34\":1}}],[\"需要在事务提交前\",{\"1\":{\"33\":1}}],[\"需要改变位置的链表头节点\",{\"1\":{\"27\":1}}],[\"大多是直接使用\",{\"1\":{\"33\":1}}],[\"大小为原来的2倍\",{\"1\":{\"10\":1,\"14\":1}}],[\"应用中\",{\"1\":{\"33\":1}}],[\"数据已落库\",{\"1\":{\"41\":1}}],[\"数据刷新到缓存\",{\"1\":{\"41\":1}}],[\"数据不一致情况\",{\"1\":{\"41\":1}}],[\"数据\",{\"1\":{\"41\":2}}],[\"数据未更新\",{\"1\":{\"41\":1}}],[\"数据真正落库\",{\"1\":{\"41\":1}}],[\"数据库\",{\"1\":{\"41\":1}}],[\"数据操作\",{\"1\":{\"40\":1,\"42\":1}}],[\"数据操作时的原子性\",{\"1\":{\"33\":1}}],[\"数组长度\",{\"1\":{\"8\":1}}],[\"数组其实就是entry<k\",{\"1\":{\"4\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"13\":1,\"18\":1,\"20\":1}}],[\"数组+链表\",{\"1\":{\"4\":1}}],[\"也可达到缩小事务范围的效果\",{\"1\":{\"45\":1}}],[\"也可以先带着问题去阅读下源码\",{\"1\":{\"42\":1}}],[\"也就导致了事务回调期间的\",{\"1\":{\"44\":1}}],[\"也是面试经典问题了\",{\"1\":{\"29\":1}}],[\"也在同一天发布了第一篇文章\",{\"1\":{\"0\":1}}],[\"掌握原理\",{\"1\":{\"29\":1}}],[\"性能提升影响是比较大的\",{\"1\":{\"29\":1}}],[\"主要是在新增\",{\"1\":{\"29\":1}}],[\"主要是因为红黑树结构\",{\"1\":{\"28\":1}}],[\"结合上图梳理流程如下\",{\"1\":{\"41\":1}}],[\"结合上面对于\",{\"1\":{\"28\":1}}],[\"结构变化\",{\"0\":{\"20\":1}}],[\"结构修改的次数\",{\"1\":{\"5\":1}}],[\"结构图\",{\"1\":{\"4\":1}}],[\"结构是数组+链表\",{\"1\":{\"4\":1}}],[\"结构\",{\"0\":{\"4\":1}}],[\"供感兴趣的读者学习下红黑树的相关知识\",{\"1\":{\"28\":1}}],[\"什么是红黑树\",{\"1\":{\"28\":1}}],[\"程序员小灰\",{\"1\":{\"28\":1}}],[\"此处附上文章\",{\"1\":{\"28\":1}}],[\"讲解起来会很啰嗦冗余\",{\"1\":{\"28\":1}}],[\"讲解了其原理\",{\"1\":{\"18\":1}}],[\"整体的实现逻辑描述\",{\"1\":{\"28\":1}}],[\"采用两个头节点和两个尾节点保存元素构成链表\",{\"1\":{\"27\":1}}],[\"简单分为以下几步\",{\"1\":{\"27\":1}}],[\"简单讲就是链表中\",{\"1\":{\"13\":1}}],[\"旧容量\",{\"1\":{\"27\":1}}],[\"旧数组数据复制到新数组\",{\"1\":{\"10\":1}}],[\"说明新位置是原索引\",{\"1\":{\"27\":1}}],[\"说明原索引位置存值\",{\"1\":{\"27\":1}}],[\"仅第一次\",{\"1\":{\"27\":1}}],[\"尾声\",{\"0\":{\"29\":1}}],[\"尾节点不为空\",{\"1\":{\"27\":1}}],[\"尾节点为空\",{\"1\":{\"27\":1}}],[\"尾插法\",{\"1\":{\"19\":1,\"24\":2}}],[\"zero\",{\"1\":{\"27\":1}}],[\"<\",{\"1\":{\"27\":4}}],[\"<<\",{\"1\":{\"27\":3}}],[\"处就体现了上面说的元素是否需要移动的判断\",{\"1\":{\"27\":1}}],[\"高位\",{\"1\":{\"27\":1}}],[\"高位多\",{\"1\":{\"27\":1}}],[\"进行编写\",{\"1\":{\"37\":1}}],[\"进行位运算\",{\"1\":{\"27\":1}}],[\"进行\",{\"1\":{\"27\":1}}],[\"进行异或运算\",{\"1\":{\"26\":1}}],[\"来查询最新的\",{\"1\":{\"41\":1}}],[\"来判断当前方法是否处于活跃事务中\",{\"1\":{\"40\":1}}],[\"来看下resize\",{\"1\":{\"27\":1}}],[\"来看看\",{\"1\":{\"18\":1}}],[\"来确定是否需要移动即可\",{\"1\":{\"27\":1}}],[\"只有一个值时\",{\"1\":{\"39\":1}}],[\"只需要在\",{\"1\":{\"27\":1}}],[\"只是维护了双向链表的应用\",{\"1\":{\"23\":1}}],[\"经过实际测试\",{\"1\":{\"39\":1,\"40\":1}}],[\"经过\",{\"1\":{\"27\":1}}],[\"经验也不够充足\",{\"1\":{\"0\":1}}],[\"红色\",{\"1\":{\"27\":1}}],[\"红黑树根节点\",{\"1\":{\"23\":1}}],[\"红黑树和链表就会频繁转换\",{\"1\":{\"21\":1}}],[\"红黑树和链表就互相转换\",{\"1\":{\"21\":1}}],[\"红黑树的平均查找时间为\",{\"1\":{\"21\":1}}],[\"红黑树又会转换为链表\",{\"1\":{\"21\":1}}],[\"搭配一张图来看就会很好理解\",{\"1\":{\"27\":1}}],[\"要么是原位置加上\",{\"1\":{\"27\":1}}],[\"要高出许多\",{\"1\":{\"12\":1}}],[\"元素存放在新数组要么是原位置\",{\"1\":{\"27\":1}}],[\"元素数量\",{\"1\":{\"8\":1}}],[\"倍\",{\"1\":{\"27\":3}}],[\"倍的新数组\",{\"1\":{\"10\":1}}],[\"次幂\",{\"1\":{\"27\":2}}],[\"次幂扩展\",{\"1\":{\"27\":1}}],[\"次方\",{\"1\":{\"26\":1}}],[\"否则可能导致\",{\"1\":{\"44\":1}}],[\"否则抛出参数类型错误异常\",{\"1\":{\"39\":1}}],[\"否则无操作\",{\"1\":{\"34\":1}}],[\"否则\",{\"1\":{\"27\":1}}],[\"want\",{\"1\":{\"44\":1}}],[\"was\",{\"1\":{\"27\":1}}],[\"web\",{\"1\":{\"33\":1}}],[\"we\",{\"1\":{\"27\":1,\"44\":2}}],[\"with\",{\"1\":{\"27\":2}}],[\"while\",{\"1\":{\"10\":1,\"19\":3,\"25\":1,\"27\":1}}],[\"减少碰撞\",{\"1\":{\"26\":1}}],[\"以及树节点平衡被打破后的处理情况等内容比较复杂\",{\"1\":{\"28\":1}}],[\"以下部分是遍历链表节点进行复制\",{\"1\":{\"27\":1}}],[\"以让低\",{\"1\":{\"26\":1}}],[\"以key\",{\"1\":{\"3\":1}}],[\"便让哈希值与高\",{\"1\":{\"26\":1}}],[\"便于在红黑树和链表之间进行转换\",{\"1\":{\"23\":1}}],[\"位更随机散列\",{\"1\":{\"26\":1}}],[\"位更随机\",{\"1\":{\"26\":1}}],[\"位运算结果取决于低\",{\"1\":{\"26\":1}}],[\"位\",{\"1\":{\"26\":3}}],[\"位甚至更低\",{\"1\":{\"26\":1}}],[\"假设\",{\"1\":{\"41\":1}}],[\"假设数组长度原本是\",{\"1\":{\"27\":1}}],[\"假设长度为\",{\"1\":{\"26\":1}}],[\"假设有两个线程\",{\"1\":{\"19\":1}}],[\"运算判断位置是否需要移动\",{\"1\":{\"27\":1}}],[\"运算效果相当于只跟高位\",{\"1\":{\"27\":1}}],[\"运算\",{\"1\":{\"27\":2}}],[\"运算为\",{\"1\":{\"27\":1}}],[\"运算的一直是哈希值的低\",{\"1\":{\"26\":1}}],[\"运算获取下标\",{\"1\":{\"26\":1}}],[\"长度都小于\",{\"1\":{\"26\":1}}],[\"长度始终保持为\",{\"1\":{\"5\":1}}],[\"对事务的特性和使用需有所理解\",{\"1\":{\"45\":1}}],[\"对key\",{\"1\":{\"26\":1}}],[\"对象中\",{\"1\":{\"44\":1}}],[\"对象进行存储\",{\"1\":{\"14\":1}}],[\"对象并添加\",{\"1\":{\"8\":1}}],[\"对象的\",{\"1\":{\"4\":1}}],[\"对象\",{\"1\":{\"4\":1}}],[\"对象存储\",{\"1\":{\"4\":1}}],[\"操作和执行耗时较长的操作\",{\"1\":{\"45\":1}}],[\"操作就会提交\",{\"1\":{\"44\":1}}],[\"操作都没有被提交\",{\"1\":{\"44\":1}}],[\"操作实现如下\",{\"1\":{\"26\":1}}],[\"操作\",{\"1\":{\"26\":1,\"36\":1,\"37\":1,\"41\":1,\"45\":1}}],[\"去获取\",{\"1\":{\"25\":1}}],[\"命中则直接返回\",{\"1\":{\"25\":1}}],[\"就新开事务执行\",{\"1\":{\"45\":1}}],[\"就需要保证\",{\"1\":{\"41\":1}}],[\"就只会查到旧数据\",{\"1\":{\"41\":1}}],[\"就是在高位多\",{\"1\":{\"27\":1}}],[\"就进行扩容resize\",{\"1\":{\"24\":1}}],[\"就将链表转换为红黑树\",{\"1\":{\"24\":1}}],[\"就会转换为红黑树\",{\"1\":{\"21\":1}}],[\"就会很轻松了\",{\"1\":{\"14\":1}}],[\"就会进行扩容操作\",{\"1\":{\"5\":1}}],[\"超过则扩容\",{\"1\":{\"24\":1}}],[\">>>\",{\"1\":{\"26\":2}}],[\">\",{\"1\":{\"24\":1,\"25\":1,\"27\":2}}],[\">=\",{\"1\":{\"8\":1,\"10\":1,\"24\":2,\"27\":2}}],[\"传递\",{\"1\":{\"24\":1}}],[\"覆盖\",{\"1\":{\"24\":1}}],[\"添加好友的流程除了处理好友请求记录外\",{\"1\":{\"41\":1}}],[\"添加请求在流程中明明只有一次\",{\"1\":{\"41\":1}}],[\"添加\",{\"1\":{\"24\":1}}],[\"执行完这一步\",{\"1\":{\"44\":1}}],[\"执行\",{\"1\":{\"24\":1}}],[\"相同赋值给\",{\"1\":{\"24\":1}}],[\"相同则覆盖并返回旧值\",{\"1\":{\"8\":1}}],[\"依旧是从put\",{\"1\":{\"24\":1}}],[\"依旧实现map\",{\"1\":{\"23\":1}}],[\"调用treenode\",{\"1\":{\"27\":1}}],[\"调用父类\",{\"1\":{\"23\":1}}],[\"调用父类的构造方法\",{\"1\":{\"23\":1}}],[\"调用get\",{\"1\":{\"14\":1}}],[\"右节点\",{\"1\":{\"23\":1}}],[\"左节点\",{\"1\":{\"23\":1}}],[\"posts\",{\"0\":{\"49\":1}}],[\"pool\",{\"1\":{\"44\":1}}],[\"power\",{\"1\":{\"27\":2}}],[\"ps\",{\"1\":{\"41\":1,\"42\":1}}],[\"phase\",{\"1\":{\"37\":2,\"43\":1}}],[\"protected\",{\"1\":{\"44\":2}}],[\"println\",{\"1\":{\"36\":4,\"37\":1}}],[\"private\",{\"1\":{\"36\":1,\"37\":1}}],[\"prepareconnectionfortransaction\",{\"1\":{\"44\":1}}],[\"precedence\",{\"1\":{\"34\":1}}],[\"preserve\",{\"1\":{\"27\":1}}],[\"previousisolationlevel\",{\"1\":{\"44\":2}}],[\"prev\",{\"1\":{\"23\":1}}],[\"placed\",{\"1\":{\"27\":1}}],[\"p\",{\"1\":{\"24\":10}}],[\"parent\",{\"1\":{\"23\":1}}],[\"publishevent\",{\"1\":{\"37\":1}}],[\"publisher\",{\"1\":{\"37\":2}}],[\"public\",{\"1\":{\"6\":10,\"8\":1,\"9\":1,\"24\":1,\"25\":1,\"34\":9,\"36\":6,\"37\":7,\"43\":1}}],[\"putifabsent\",{\"1\":{\"24\":1}}],[\"puttreeval\",{\"1\":{\"24\":2}}],[\"putval\",{\"1\":{\"24\":2}}],[\"putfornullkey\",{\"1\":{\"8\":1}}],[\"put\",{\"0\":{\"8\":1,\"24\":1},\"1\":{\"6\":1,\"8\":1,\"18\":1,\"24\":2}}],[\"但拿到的却都是旧数据\",{\"1\":{\"41\":1}}],[\"但也有一些特殊情况\",{\"1\":{\"33\":1}}],[\"但一般情况下\",{\"1\":{\"26\":1}}],[\"但treenode<k\",{\"1\":{\"23\":1}}],[\"但其内部方法实现基本相同\",{\"1\":{\"23\":1}}],[\"但synchronize是重量级锁\",{\"1\":{\"12\":1}}],[\"update\",{\"1\":{\"36\":1,\"37\":1}}],[\"unbindresource\",{\"1\":{\"44\":1}}],[\"unnecessarily\",{\"1\":{\"44\":1}}],[\"unchecked\",{\"1\":{\"27\":1}}],[\"untreeify\",{\"1\":{\"21\":1}}],[\"using\",{\"1\":{\"27\":2}}],[\"usealthashing\",{\"1\":{\"10\":3}}],[\"默认传递\",{\"1\":{\"24\":1}}],[\"默认的转换为链表的节点阈值\",{\"1\":{\"21\":1}}],[\"默认的转换为红黑树的节点阈值\",{\"1\":{\"21\":1}}],[\"默认是true\",{\"1\":{\"44\":1}}],[\"默认是\",{\"1\":{\"5\":1}}],[\"频繁增删\",{\"1\":{\"21\":1}}],[\"徘徊\",{\"1\":{\"21\":1}}],[\"和\",{\"0\":{\"23\":1},\"1\":{\"21\":1,\"27\":1}}],[\"首先用链表存储\",{\"1\":{\"21\":1}}],[\"首次建立个人博客\",{\"1\":{\"0\":1}}],[\"能够理想地解决查询效率变低的问题\",{\"1\":{\"20\":1}}],[\"查询速度就会受到影响\",{\"1\":{\"20\":1}}],[\"查找匹配的节点\",{\"1\":{\"25\":1}}],[\"查找\",{\"1\":{\"20\":1}}],[\"变量在修改\",{\"1\":{\"44\":1}}],[\"变为\",{\"1\":{\"27\":1}}],[\"变大时\",{\"1\":{\"20\":1}}],[\"变大\",{\"1\":{\"20\":1}}],[\"变成\",{\"1\":{\"19\":1}}],[\"显著提高了查询效率\",{\"1\":{\"20\":1}}],[\"再搭配上策略模式优雅代码\",{\"1\":{\"43\":1}}],[\"再去查看关于红黑树操作的源码\",{\"1\":{\"28\":1}}],[\"再将链表头节点存放到新数组的相应位置\",{\"1\":{\"27\":1}}],[\"再进一步计算下标\",{\"1\":{\"26\":1}}],[\"再存入到新数组中\",{\"1\":{\"19\":1}}],[\"再次贴上复制数据的方法源码\",{\"1\":{\"19\":1}}],[\"循环中\",{\"1\":{\"27\":1}}],[\"循环复制数据中\",{\"1\":{\"19\":1}}],[\"循环里遍历一个节点就插入到新的数组位置\",{\"1\":{\"19\":1}}],[\"源码\",{\"1\":{\"19\":1}}],[\"源码如下\",{\"1\":{\"10\":1}}],[\"方便大家回顾\",{\"1\":{\"19\":1}}],[\"方法入参推荐不指定\",{\"1\":{\"42\":1}}],[\"方法入参类型为\",{\"1\":{\"39\":1}}],[\"方法入参只能为\",{\"1\":{\"39\":1}}],[\"方法优化\",{\"1\":{\"29\":1}}],[\"方法进行具体操作\",{\"1\":{\"27\":1}}],[\"方法的源码\",{\"1\":{\"27\":1}}],[\"方法上有这么一段注释\",{\"1\":{\"27\":1}}],[\"方法开始\",{\"1\":{\"24\":1}}],[\"方法\",{\"0\":{\"24\":1,\"25\":1,\"26\":1,\"27\":1},\"1\":{\"24\":1}}],[\"方法时同样计算key的哈希值然后获取数组下标\",{\"1\":{\"14\":1}}],[\"方法存值时会调用key\",{\"1\":{\"14\":1}}],[\"方法里作了判断\",{\"1\":{\"12\":1}}],[\"方法里计算key的hash值找到下标然后循环遍历判断key的值\",{\"1\":{\"9\":1}}],[\"方法将旧数组数据循环遍历复制到新数组\",{\"1\":{\"10\":1}}],[\"方法就简单多了\",{\"1\":{\"9\":1}}],[\"方法后\",{\"1\":{\"9\":1}}],[\"方法判断是否需要扩容\",{\"1\":{\"8\":1}}],[\"方法实现\",{\"0\":{\"8\":1,\"9\":1,\"10\":1}}],[\"方法原理\",{\"0\":{\"7\":1}}],[\"另一个是因为复制数据是在\",{\"1\":{\"19\":1}}],[\"后修改连接的自动提交autocommit为false\",{\"1\":{\"44\":1}}],[\"后\",{\"1\":{\"41\":1}}],[\"后判断是否等于\",{\"1\":{\"27\":1}}],[\"后就被阻塞\",{\"1\":{\"19\":1}}],[\"后依旧在同一个数组下标位置\",{\"1\":{\"19\":1}}],[\"后续新篇章也会对\",{\"1\":{\"13\":1}}],[\"都是放在链表头节点\",{\"1\":{\"19\":1}}],[\"每当添加新元素时\",{\"1\":{\"19\":1}}],[\"每个节点都是一个entry<k\",{\"1\":{\"4\":1}}],[\"原因是流程做了简化\",{\"1\":{\"41\":1}}],[\"原因之一是链表节点的存储方式引起\",{\"1\":{\"19\":1}}],[\"原\",{\"1\":{\"27\":1}}],[\"原索引+原数组容量\",{\"1\":{\"27\":1}}],[\"原理宏观上跟以前的思路差不多\",{\"1\":{\"29\":1}}],[\"原理解析\",{\"0\":{\"22\":1}}],[\"原理并不复杂\",{\"1\":{\"14\":1}}],[\"原头节点就变成新节点的\",{\"1\":{\"19\":1}}],[\"版本有了哪些变化\",{\"1\":{\"18\":1}}],[\"版本开始\",{\"1\":{\"13\":1}}],[\"我们就以此作为切入点\",{\"1\":{\"18\":1}}],[\"我们常见的\",{\"1\":{\"2\":1}}],[\"引出了在\",{\"1\":{\"18\":1}}],[\"篇中\",{\"1\":{\"18\":1}}],[\"至于其它的一些细枝末节\",{\"1\":{\"14\":1}}],[\"前的\",{\"1\":{\"14\":1}}],[\"前言\",{\"0\":{\"2\":1,\"18\":1,\"33\":1}}],[\"最终返回结果\",{\"1\":{\"14\":1}}],[\"最后只能依赖连接的autocommit恢复后\",{\"1\":{\"44\":1}}],[\"最后判断容量若大于阈值\",{\"1\":{\"24\":1}}],[\"最后来概括下\",{\"1\":{\"14\":1}}],[\"最后将key\",{\"1\":{\"8\":1}}],[\"然后由\",{\"1\":{\"44\":1}}],[\"然后进入putval\",{\"1\":{\"24\":1}}],[\"然后确定数组下标\",{\"1\":{\"20\":1}}],[\"然后通过instanceof或class\",{\"1\":{\"43\":1}}],[\"然后通过key\",{\"1\":{\"25\":1}}],[\"然后通过\",{\"1\":{\"14\":1}}],[\"然后将key和value作为entry<k\",{\"1\":{\"4\":1}}],[\"总结下步骤\",{\"1\":{\"24\":1}}],[\"总结\",{\"0\":{\"14\":1,\"45\":1}}],[\"作下介绍讲解\",{\"1\":{\"13\":1}}],[\"作为下一个节点\",{\"1\":{\"8\":1}}],[\"8\",{\"0\":{\"17\":1},\"1\":{\"13\":3,\"14\":1,\"18\":2,\"19\":3,\"20\":3,\"21\":8,\"23\":2,\"24\":2,\"26\":1,\"29\":2}}],[\"很清晰易懂\",{\"1\":{\"13\":1}}],[\"疫苗\",{\"1\":{\"13\":1}}],[\"陈皓的\",{\"1\":{\"13\":1}}],[\"刚好需要扩容\",{\"1\":{\"13\":1}}],[\"竞用条件\",{\"1\":{\"13\":1}}],[\"runtime\",{\"1\":{\"37\":1}}],[\"rollbackfor\",{\"1\":{\"36\":1,\"37\":1}}],[\"rawtypes\",{\"1\":{\"27\":1}}],[\"race\",{\"1\":{\"13\":1}}],[\"right\",{\"1\":{\"23\":1}}],[\"releaseconnection\",{\"1\":{\"44\":2}}],[\"releasing\",{\"1\":{\"44\":1}}],[\"request\",{\"1\":{\"41\":4}}],[\"req\",{\"1\":{\"41\":11}}],[\"retentionpolicy\",{\"1\":{\"37\":1}}],[\"retention\",{\"1\":{\"37\":1}}],[\"return\",{\"1\":{\"8\":4,\"9\":4,\"10\":1,\"24\":3,\"25\":5,\"26\":1,\"27\":2,\"34\":1}}],[\"registersynchronization\",{\"1\":{\"36\":1}}],[\"readonly\",{\"1\":{\"34\":1}}],[\"reset\",{\"1\":{\"44\":1}}],[\"resetconnectionaftertransaction\",{\"1\":{\"44\":1}}],[\"resource\",{\"1\":{\"37\":1}}],[\"restcontroller\",{\"1\":{\"36\":1,\"37\":1}}],[\"resume\",{\"1\":{\"34\":1}}],[\"resize\",{\"0\":{\"10\":1,\"27\":1},\"1\":{\"8\":1,\"10\":1,\"18\":1,\"24\":2,\"27\":1}}],[\"redis\",{\"1\":{\"41\":1}}],[\"red\",{\"1\":{\"23\":1}}],[\"rehash\",{\"1\":{\"10\":4,\"19\":3}}],[\"rehashing\",{\"1\":{\"10\":1}}],[\"recordaccess\",{\"1\":{\"8\":1}}],[\"remove\",{\"1\":{\"6\":1,\"44\":1}}],[\"产生\",{\"1\":{\"13\":1}}],[\"死链就出现了\",{\"1\":{\"19\":1}}],[\"死链原因和解决方法\",{\"0\":{\"19\":1}}],[\"死链是指在\",{\"1\":{\"13\":1}}],[\"死链问题\",{\"0\":{\"13\":1},\"1\":{\"18\":1}}],[\"效率将会降低\",{\"1\":{\"21\":1}}],[\"效率比\",{\"1\":{\"12\":1}}],[\"效率较低\",{\"1\":{\"12\":1}}],[\"效率较高\",{\"1\":{\"12\":1}}],[\"其抽象实现transactionsynchronizationadapter源码如下\",{\"1\":{\"34\":1}}],[\"其意思大概就是初始化或增加数组大小\",{\"1\":{\"27\":1}}],[\"其采用的是分段锁\",{\"1\":{\"12\":1}}],[\"其它代码省略\",{\"1\":{\"4\":1,\"23\":2}}],[\"推荐使用\",{\"1\":{\"12\":1}}],[\"因为\",{\"1\":{\"41\":1,\"44\":1}}],[\"因为扩容后\",{\"1\":{\"27\":1}}],[\"因为扩容为n\",{\"1\":{\"27\":1}}],[\"因为使用的是\",{\"1\":{\"27\":1}}],[\"因此方法参数指定为applicationevent类型即可\",{\"1\":{\"43\":1}}],[\"因此便可利用事务同步来控制步骤\",{\"1\":{\"41\":1}}],[\"因此不受\",{\"1\":{\"41\":1}}],[\"因此还是推荐不设置参数\",{\"1\":{\"39\":1}}],[\"因此事务同步回调时可获取该事件的信息\",{\"1\":{\"37\":1}}],[\"因此扩容时不需要重新计算\",{\"1\":{\"27\":1}}],[\"因此\",{\"1\":{\"20\":1}}],[\"因此在多线程并发应用中使用是比较少的\",{\"1\":{\"12\":1}}],[\"因工作琐事\",{\"1\":{\"0\":1}}],[\"容易引起线程上下文切换而带来线程调度的开销\",{\"1\":{\"12\":1}}],[\"容量\",{\"1\":{\"5\":1}}],[\"datasource\",{\"1\":{\"44\":1}}],[\"datasourcetransactionobject\",{\"1\":{\"44\":2}}],[\"datasourceutils\",{\"1\":{\"44\":4}}],[\"drivers\",{\"1\":{\"44\":1}}],[\"debug\",{\"1\":{\"44\":4}}],[\"definition\",{\"1\":{\"44\":3}}],[\"defaults\",{\"1\":{\"27\":1}}],[\"default\",{\"1\":{\"5\":1,\"27\":4,\"37\":5}}],[\"db\",{\"1\":{\"33\":1,\"36\":1,\"37\":1,\"40\":1,\"41\":6,\"42\":1,\"44\":5,\"45\":2}}],[\"docleanupaftercompletion\",{\"1\":{\"44\":1}}],[\"documented\",{\"1\":{\"37\":1}}],[\"don\",{\"1\":{\"44\":1}}],[\"dobegin\",{\"1\":{\"44\":1}}],[\"double\",{\"1\":{\"27\":1}}],[\"doubles\",{\"1\":{\"27\":1}}],[\"do\",{\"1\":{\"25\":1,\"27\":1,\"43\":2,\"44\":1}}],[\"dictionary<k\",{\"1\":{\"12\":1}}],[\"线程一获取到\",{\"1\":{\"19\":1}}],[\"线程安全\",{\"1\":{\"12\":1}}],[\"线程不安全\",{\"1\":{\"12\":1}}],[\"继承于\",{\"1\":{\"12\":2}}],[\"唯一\",{\"1\":{\"12\":1}}],[\"允许为\",{\"1\":{\"12\":1}}],[\"与上面同理\",{\"1\":{\"27\":1}}],[\"与\",{\"0\":{\"12\":1}}],[\"补充\",{\"0\":{\"11\":1}}],[\"理解起来就会比较轻松了\",{\"1\":{\"28\":1}}],[\"理解清楚\",{\"1\":{\"10\":1}}],[\"理解了put\",{\"1\":{\"9\":1}}],[\"关于红黑树\",{\"0\":{\"28\":1}}],[\"关于其逻辑实现在下面会讲到\",{\"1\":{\"19\":1}}],[\"关于死链具体情况\",{\"1\":{\"13\":1}}],[\"关于作者\",{\"0\":{\"0\":1}}],[\"关键\",{\"1\":{\"10\":1}}],[\"头节点指向当前遍历节点\",{\"1\":{\"27\":1}}],[\"头部插入\",{\"1\":{\"10\":1}}],[\"头插法\",{\"1\":{\"10\":1,\"19\":1}}],[\"节点不为空\",{\"1\":{\"24\":1}}],[\"节点为空直接添加\",{\"1\":{\"24\":1}}],[\"节点以及下一节点\",{\"1\":{\"19\":1}}],[\"节点\",{\"1\":{\"10\":1,\"19\":1}}],[\"链表存储方式变为尾插法\",{\"1\":{\"29\":1}}],[\"链表红黑树互转等则讲解不多\",{\"1\":{\"28\":1}}],[\"链表与红黑树转换时机\",{\"0\":{\"21\":1}}],[\"链表结构\",{\"1\":{\"19\":1}}],[\"链表变成\",{\"1\":{\"19\":1}}],[\"链表头部插入\",{\"1\":{\"10\":1}}],[\"链表节点中的下一个\",{\"1\":{\"4\":1}}],[\"遍历链表\",{\"1\":{\"24\":1}}],[\"遍历当前节点的链表\",{\"1\":{\"10\":1}}],[\"遍历旧数组复制数据\",{\"1\":{\"27\":1}}],[\"遍历旧数组\",{\"1\":{\"10\":1}}],[\"++j\",{\"1\":{\"27\":1}}],[\"++size\",{\"1\":{\"24\":1}}],[\"++modcount\",{\"1\":{\"24\":1}}],[\"++bincount\",{\"1\":{\"24\":1}}],[\"+o\",{\"1\":{\"20\":2}}],[\"+\",{\"1\":{\"10\":1,\"27\":2,\"36\":2,\"41\":1,\"44\":6}}],[\"+1\",{\"1\":{\"8\":2}}],[\"^\",{\"1\":{\"10\":1,\"26\":1}}],[\"autocommit\",{\"1\":{\"44\":1}}],[\"acquired\",{\"1\":{\"44\":1}}],[\"accord\",{\"1\":{\"27\":1}}],[\"aevent\",{\"1\":{\"43\":2}}],[\"applicationeventpublisher\",{\"1\":{\"37\":1}}],[\"applicationevent\",{\"1\":{\"37\":1,\"43\":1}}],[\"annotation\",{\"1\":{\"37\":3}}],[\"abstract\",{\"1\":{\"34\":1}}],[\"abstractmap<k\",{\"1\":{\"12\":1}}],[\"attribute\",{\"1\":{\"37\":2}}],[\"at\",{\"1\":{\"27\":1}}],[\"are\",{\"1\":{\"27\":1}}],[\"already\",{\"1\":{\"44\":1}}],[\"aliasfor\",{\"1\":{\"37\":2}}],[\"allocates\",{\"1\":{\"27\":1}}],[\"always\",{\"1\":{\"25\":1}}],[\"alternative\",{\"1\":{\"10\":1}}],[\"aftercompletion方法回调时若有\",{\"1\":{\"42\":1}}],[\"aftercompletion\",{\"0\":{\"40\":1},\"1\":{\"34\":1,\"36\":1}}],[\"aftercommit\",{\"0\":{\"40\":1},\"1\":{\"34\":1,\"36\":1,\"37\":1,\"42\":1,\"43\":1}}],[\"afternodeinsertion\",{\"1\":{\"24\":1}}],[\"afternodeaccess\",{\"1\":{\"24\":1}}],[\"after\",{\"1\":{\"23\":1,\"37\":2,\"43\":1,\"44\":2}}],[\"after两个属性\",{\"1\":{\"23\":1}}],[\"a\",{\"1\":{\"13\":2,\"19\":5,\"27\":1,\"39\":3,\"41\":5}}],[\"addentry\",{\"1\":{\"8\":2}}],[\"|=\",{\"1\":{\"10\":1}}],[\"||\",{\"1\":{\"8\":1,\"9\":1,\"24\":4,\"25\":2,\"44\":1}}],[\"基于注解\",{\"0\":{\"37\":1}}],[\"基于接口\",{\"0\":{\"36\":1}}],[\"基本侧重于\",{\"1\":{\"28\":1}}],[\"基本上其它方法实现都可以很容易理解了\",{\"1\":{\"10\":1}}],[\"基本不存在扩容情况\",{\"1\":{\"10\":1}}],[\"基础\",{\"0\":{\"3\":1}}],[\"已会可忽略\",{\"1\":{\"28\":1}}],[\"已有的节点往后移作为\",{\"1\":{\"10\":1}}],[\"已经大的夸张\",{\"1\":{\"10\":1}}],[\"已存储的元素数量\",{\"1\":{\"5\":1}}],[\"获取连接进行重置\",{\"1\":{\"44\":1}}],[\"获取数组下标位置第一个节点\",{\"1\":{\"25\":1}}],[\"获取key的\",{\"1\":{\"24\":1}}],[\"获取元素的逻辑还是比较简单\",{\"1\":{\"25\":1}}],[\"获取元素的时间复杂度就变为\",{\"1\":{\"20\":1}}],[\"获取元素可以简单分为以下两步\",{\"1\":{\"20\":1}}],[\"获取\",{\"1\":{\"20\":1,\"24\":1,\"29\":1}}],[\"获取是否需要重新计算\",{\"1\":{\"10\":1}}],[\"获取旧数组长度\",{\"1\":{\"10\":1}}],[\"获取所有entry<k\",{\"1\":{\"6\":1}}],[\"获取所有key的\",{\"1\":{\"6\":1}}],[\"中间存在差值\",{\"1\":{\"21\":1}}],[\"中则变为node<k\",{\"1\":{\"23\":1}}],[\"中则利用红黑树替代链表\",{\"1\":{\"20\":1}}],[\"中则更改为\",{\"1\":{\"19\":1}}],[\"中已经得到解决\",{\"1\":{\"13\":1}}],[\"中\",{\"0\":{\"17\":1},\"1\":{\"10\":1,\"18\":1,\"20\":2,\"29\":1}}],[\"中是否已存在\",{\"1\":{\"6\":1}}],[\"三目表达式判断\",{\"1\":{\"9\":1}}],[\"三大集合框架之一\",{\"1\":{\"2\":1}}],[\"直接取数组下标为\",{\"1\":{\"9\":1}}],[\"直接上源码\",{\"1\":{\"9\":1,\"24\":1}}],[\"直接存放在数组下标\",{\"1\":{\"8\":1}}],[\"在这两个方法中执行\",{\"1\":{\"40\":1}}],[\"在回调时事务资源可能仍然处于活跃状态并可访问\",{\"1\":{\"40\":1}}],[\"在事务明明已经提交的情况下\",{\"1\":{\"42\":1}}],[\"在事务完成后执行\",{\"1\":{\"41\":1}}],[\"在事务接口方法里\",{\"1\":{\"37\":1}}],[\"在事务方法中通过transactionsynchronizationmanager事务同步管理器注册事务同步\",{\"1\":{\"36\":1}}],[\"在相应的事务阶段回调方法中实现业务逻辑\",{\"1\":{\"36\":1}}],[\"在transactionsynchronization接口有定义\",{\"1\":{\"34\":1}}],[\"在transfer\",{\"1\":{\"10\":1}}],[\"在aftercompletion方法的入参status有三种状态\",{\"1\":{\"34\":1}}],[\"在addentry\",{\"1\":{\"8\":1}}],[\"在下方事务同步的两种使用方式本质都是利用了该抽象类来实现\",{\"1\":{\"34\":1}}],[\"在下面源码中\",{\"1\":{\"23\":1}}],[\"在常规的\",{\"1\":{\"33\":1}}],[\"在实际开发中\",{\"1\":{\"29\":1}}],[\"在java\",{\"1\":{\"29\":1}}],[\"在上面内容中\",{\"1\":{\"28\":1}}],[\"在resize\",{\"1\":{\"27\":1}}],[\"在新增和获取过程中\",{\"1\":{\"26\":1}}],[\"在发生碰撞问题时\",{\"1\":{\"20\":1}}],[\"在最后简单描述了\",{\"1\":{\"18\":1}}],[\"在聊聊\",{\"1\":{\"18\":1}}],[\"在理解了上面的内容后\",{\"1\":{\"14\":1}}],[\"在左耳朵耗子\",{\"1\":{\"13\":1}}],[\"在\",{\"1\":{\"10\":1,\"13\":1,\"18\":1,\"20\":4,\"23\":1,\"26\":1,\"27\":1}}],[\"在getentry\",{\"1\":{\"9\":1}}],[\"在日常开发使用中\",{\"1\":{\"2\":1}}],[\"插入到链表头\",{\"1\":{\"8\":1}}],[\"碰撞\",{\"1\":{\"8\":1}}],[\"不会再有提交操作\",{\"1\":{\"44\":1}}],[\"不存在事务时\",{\"1\":{\"37\":1}}],[\"不存在则返回null\",{\"1\":{\"9\":1}}],[\"不为\",{\"1\":{\"27\":1}}],[\"不为空说明链表存在\",{\"1\":{\"27\":1}}],[\"不为空先判断key\",{\"1\":{\"24\":1}}],[\"不为空则进行覆盖并返回旧值\",{\"1\":{\"24\":1}}],[\"不为空\",{\"1\":{\"8\":1,\"12\":1}}],[\"不需要改变位置的链表头节点\",{\"1\":{\"27\":1}}],[\"不超过最大值则扩容为原来的\",{\"1\":{\"27\":1}}],[\"不同说明发生碰撞\",{\"1\":{\"24\":1}}],[\"不覆盖\",{\"1\":{\"24\":1}}],[\"不匹配则循环判断下一节点\",{\"1\":{\"9\":1}}],[\"不指定则默认为\",{\"1\":{\"5\":1}}],[\"若只是代码执行耗时\",{\"1\":{\"45\":1}}],[\"若只是使用事务注解标记整个处理流程\",{\"1\":{\"41\":1}}],[\"若有必要\",{\"1\":{\"45\":1}}],[\"若有也会去修改\",{\"1\":{\"41\":1}}],[\"若有冲突\",{\"1\":{\"25\":1}}],[\"若事务方法发布的事件刚好与参数的事件类型一致\",{\"1\":{\"39\":1}}],[\"若方法入参为空或不为事件类型\",{\"1\":{\"39\":1}}],[\"若方法入参为事件类型\",{\"1\":{\"39\":1}}],[\"若遇到异常\",{\"1\":{\"29\":1}}],[\"若当前遍历的节点元素位置没有冲突\",{\"1\":{\"27\":1}}],[\"若当前节点没有冲突\",{\"1\":{\"27\":1}}],[\"若新数组未设置阈值\",{\"1\":{\"27\":1}}],[\"若无数据并且阈值为\",{\"1\":{\"27\":1}}],[\"若无数据\",{\"1\":{\"27\":1}}],[\"若是超过最大值\",{\"1\":{\"27\":1}}],[\"若是链表节点\",{\"1\":{\"24\":1}}],[\"若多出的高位\",{\"1\":{\"27\":1}}],[\"若下标处第一个节点匹配则返回\",{\"1\":{\"25\":1}}],[\"若节点已经存在\",{\"1\":{\"24\":1}}],[\"若为链表节点则进行遍历\",{\"1\":{\"27\":1}}],[\"若为链表则遍历判断\",{\"1\":{\"25\":1}}],[\"若为空直接新增\",{\"1\":{\"24\":1}}],[\"若为树节点则调用\",{\"1\":{\"25\":1}}],[\"若为树节点\",{\"1\":{\"24\":1,\"27\":2}}],[\"若数组下标位置节点key不匹配\",{\"1\":{\"20\":1}}],[\"若链表元素\",{\"1\":{\"19\":1}}],[\"若\",{\"1\":{\"8\":1,\"21\":1,\"24\":1}}],[\"创建事件类\",{\"1\":{\"37\":1}}],[\"创建事件对象\",{\"1\":{\"37\":1}}],[\"创建大小为原来\",{\"1\":{\"10\":1}}],[\"创建一个新的数组\",{\"1\":{\"10\":1}}],[\"创建\",{\"1\":{\"8\":1,\"36\":1}}],[\"则善用线程池异步处理\",{\"1\":{\"45\":1}}],[\"则查询\",{\"1\":{\"41\":1}}],[\"则可以正确回调\",{\"1\":{\"39\":1}}],[\"则入参不需要指定\",{\"1\":{\"39\":1}}],[\"则表示方法不关心任何事件\",{\"1\":{\"39\":1}}],[\"则表示只要事件发布了就回调\",{\"1\":{\"37\":1}}],[\"则代表是感兴趣的事件\",{\"1\":{\"39\":1}}],[\"则直接计算新的数组下标存值\",{\"1\":{\"27\":1}}],[\"则链表存在\",{\"1\":{\"27\":1}}],[\"则链表为空\",{\"1\":{\"27\":1}}],[\"则链表元素会出现逆序\",{\"1\":{\"19\":1}}],[\"则是对应链表尾节点\",{\"1\":{\"27\":1}}],[\"则调用\",{\"1\":{\"27\":1}}],[\"则计算新的数组下标直接存值\",{\"1\":{\"27\":1}}],[\"则进入此处计算新的\",{\"1\":{\"27\":1}}],[\"则使用默认值设置\",{\"1\":{\"27\":1}}],[\"则用初始化阈值赋值\",{\"1\":{\"27\":1}}],[\"则不扩容\",{\"1\":{\"27\":1}}],[\"则不需要变化\",{\"1\":{\"27\":1}}],[\"则元素\",{\"1\":{\"27\":1}}],[\"则按默认值进行初始化\",{\"1\":{\"27\":1}}],[\"则下标运算的结果取决于哈希值的低\",{\"1\":{\"26\":1}}],[\"则替换旧值oldvalue并返回\",{\"1\":{\"24\":1}}],[\"则遍历到链表尾部判断\",{\"1\":{\"24\":1}}],[\"则遍历链表\",{\"1\":{\"20\":1}}],[\"则判断是否与当前遍历节点相同\",{\"1\":{\"24\":1}}],[\"则转换为红黑树\",{\"1\":{\"24\":1}}],[\"则说明发生\",{\"1\":{\"8\":1}}],[\"则扩容为原来的2倍大小\",{\"1\":{\"8\":1}}],[\"则会触发扩容操作\",{\"1\":{\"5\":1}}],[\"bug\",{\"1\":{\"29\":1}}],[\"bucketindex\",{\"1\":{\"8\":7}}],[\"bit\",{\"1\":{\"27\":4}}],[\"bin\",{\"1\":{\"27\":1}}],[\"bincount\",{\"1\":{\"24\":2}}],[\"bevent\",{\"1\":{\"43\":2}}],[\"because\",{\"1\":{\"27\":1}}],[\"beforecompletion\",{\"1\":{\"34\":1}}],[\"beforecommit\",{\"1\":{\"34\":1}}],[\"before\",{\"1\":{\"23\":1}}],[\"break\",{\"1\":{\"24\":2}}],[\"b\",{\"1\":{\"13\":2,\"19\":5,\"39\":2,\"41\":8}}],[\"boolean\",{\"1\":{\"6\":3,\"10\":3,\"19\":1,\"23\":1,\"24\":2,\"34\":1,\"37\":1}}],[\"封装为\",{\"1\":{\"8\":1}}],[\"将连接回收到数据库连接池\",{\"1\":{\"44\":1}}],[\"将头节点保存在相应位置\",{\"1\":{\"27\":1}}],[\"将尾节点指向当前遍历节点\",{\"1\":{\"27\":2}}],[\"将新数组赋值给\",{\"1\":{\"10\":1}}],[\"将原有节点\",{\"1\":{\"8\":1}}],[\"将\",{\"1\":{\"8\":2}}],[\"6\",{\"1\":{\"8\":1,\"21\":3,\"24\":4,\"27\":12}}],[\"修改次数\",{\"1\":{\"8\":1}}],[\"5\",{\"1\":{\"8\":1,\"10\":1,\"24\":1,\"27\":2}}],[\"obtaindatasource\",{\"1\":{\"44\":2}}],[\"object\",{\"1\":{\"6\":4,\"8\":1,\"9\":3,\"25\":2,\"26\":1,\"37\":1,\"44\":2}}],[\"out\",{\"1\":{\"36\":4,\"37\":1}}],[\"override\",{\"1\":{\"34\":8,\"36\":2,\"44\":2}}],[\"offset\",{\"1\":{\"27\":1}}],[\"of\",{\"1\":{\"27\":2}}],[\"otherwise\",{\"1\":{\"27\":1}}],[\"ordered\",{\"1\":{\"34\":2}}],[\"order\",{\"1\":{\"27\":1}}],[\"or\",{\"1\":{\"27\":2}}],[\"onlyifabsent\",{\"1\":{\"24\":3}}],[\"o\",{\"1\":{\"20\":2}}],[\"oldthr\",{\"1\":{\"27\":4}}],[\"oldtab\",{\"1\":{\"27\":7}}],[\"oldtable\",{\"1\":{\"10\":2}}],[\"oldcap\",{\"1\":{\"27\":10}}],[\"oldcapacity\",{\"1\":{\"10\":2}}],[\"oldalthashing\",{\"1\":{\"10\":2}}],[\"oldvalue\",{\"1\":{\"8\":2,\"24\":3}}],[\"4\",{\"1\":{\"8\":1,\"10\":1,\"21\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":2}}],[\"event\",{\"1\":{\"43\":3}}],[\"eventlistener\",{\"1\":{\"37\":3}}],[\"evict\",{\"1\":{\"24\":2}}],[\"either\",{\"1\":{\"27\":1}}],[\"each\",{\"1\":{\"27\":1}}],[\"elementtype\",{\"1\":{\"37\":2}}],[\"elements\",{\"1\":{\"27\":1}}],[\"else\",{\"1\":{\"24\":3,\"27\":8,\"43\":1}}],[\"ex\",{\"1\":{\"44\":3}}],[\"example\",{\"1\":{\"44\":1}}],[\"exposed\",{\"1\":{\"44\":1}}],[\"explicitly\",{\"1\":{\"44\":1}}],[\"expensive\",{\"1\":{\"44\":1}}],[\"expansion\",{\"1\":{\"27\":1}}],[\"exception\",{\"1\":{\"36\":1,\"37\":1}}],[\"existing\",{\"1\":{\"24\":1}}],[\"extends\",{\"1\":{\"23\":2,\"36\":1,\"37\":1}}],[\"equals\",{\"1\":{\"8\":1,\"9\":1,\"14\":1,\"20\":1,\"24\":3,\"25\":3}}],[\"e\",{\"1\":{\"8\":13,\"9\":7,\"10\":10,\"19\":10,\"24\":13,\"25\":10,\"27\":19}}],[\"entry<>\",{\"1\":{\"8\":1}}],[\"entry<k\",{\"1\":{\"4\":9,\"5\":1,\"8\":2,\"9\":3,\"10\":2,\"14\":1,\"19\":2,\"23\":7}}],[\"entryset\",{\"1\":{\"6\":1}}],[\"entry\",{\"1\":{\"4\":2,\"5\":1,\"8\":3,\"9\":3,\"10\":4,\"13\":2,\"19\":1,\"23\":1}}],[\"32\",{\"1\":{\"27\":1}}],[\"3\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"21\":1,\"24\":2,\"27\":10,\"37\":1}}],[\"计算下标方式\",{\"1\":{\"26\":1}}],[\"计算下标时\",{\"1\":{\"26\":1}}],[\"计算哈希值从而获取数组下标\",{\"1\":{\"14\":1}}],[\"计算数组下标\",{\"1\":{\"10\":1,\"24\":2}}],[\"计算数组下标并循环遍历该下标处的链表节点\",{\"1\":{\"9\":1}}],[\"计算key的\",{\"1\":{\"8\":1,\"25\":1}}],[\"计算\",{\"1\":{\"8\":1,\"9\":1,\"26\":1}}],[\"为何还会参与原始事务\",{\"1\":{\"42\":1}}],[\"为何还要加事务\",{\"1\":{\"41\":1}}],[\"为避免出现这种情况\",{\"1\":{\"41\":1}}],[\"为好友\",{\"1\":{\"41\":1}}],[\"为了让哈希值的低\",{\"1\":{\"26\":1}}],[\"为空则先创建\",{\"1\":{\"24\":1}}],[\"为空则创建\",{\"1\":{\"24\":1}}],[\"为空直接添加\",{\"1\":{\"24\":1}}],[\"为空直接抛出\",{\"1\":{\"12\":1}}],[\"为空直接获取数组下标为\",{\"1\":{\"9\":1}}],[\"为null则直接存放到数组下标为\",{\"1\":{\"8\":1}}],[\"为\",{\"1\":{\"8\":1,\"9\":1,\"27\":2,\"44\":1}}],[\"1111\",{\"1\":{\"27\":2}}],[\"1st\",{\"1\":{\"24\":1}}],[\"1<<30\",{\"1\":{\"10\":1}}],[\"1\",{\"1\":{\"8\":3,\"9\":1,\"10\":2,\"20\":2,\"24\":6,\"25\":2,\"26\":1,\"27\":13,\"34\":1,\"37\":1,\"39\":1,\"41\":4}}],[\"16\",{\"1\":{\"5\":1,\"26\":7,\"27\":4}}],[\"复制数据等方法的具体实现是怎么样的\",{\"1\":{\"7\":1}}],[\"扩容方法实现逻辑重点在于复制数据的\",{\"1\":{\"27\":1}}],[\"扩容计算\",{\"1\":{\"27\":1}}],[\"扩容复制原理后\",{\"1\":{\"10\":1}}],[\"扩容的关键方法\",{\"1\":{\"10\":1}}],[\"扩容\",{\"1\":{\"7\":1}}],[\"扩容时使用\",{\"1\":{\"5\":1}}],[\"取值\",{\"1\":{\"7\":1,\"10\":1}}],[\"设值\",{\"1\":{\"7\":1}}],[\"接下来我们具体看看\",{\"1\":{\"7\":1}}],[\"集合\",{\"1\":{\"6\":2},\"2\":{\"16\":1,\"31\":1}}],[\"getpreviousisolationlevel\",{\"1\":{\"44\":1}}],[\"getautocommit\",{\"1\":{\"44\":1}}],[\"getconnection\",{\"1\":{\"44\":3}}],[\"getconnectionholder\",{\"1\":{\"44\":5}}],[\"getmapping\",{\"1\":{\"36\":1,\"37\":1}}],[\"getorder\",{\"1\":{\"34\":1}}],[\"gettreenode\",{\"1\":{\"25\":2}}],[\"getnode\",{\"1\":{\"25\":2}}],[\"getvalue\",{\"1\":{\"9\":1}}],[\"getentry\",{\"1\":{\"9\":2}}],[\"getfornullkey\",{\"1\":{\"9\":1}}],[\"get\",{\"0\":{\"9\":1,\"25\":1},\"1\":{\"6\":1,\"9\":2,\"18\":1,\"25\":1}}],[\"即修改autocommit=true\",{\"1\":{\"44\":1}}],[\"即缺少最新的请求记录\",{\"1\":{\"41\":1}}],[\"即可看到注解方法内的内容输出\",{\"1\":{\"37\":1}}],[\"即可看到如下结果\",{\"1\":{\"36\":1}}],[\"即事务同步\",{\"1\":{\"33\":1}}],[\"即原来大小的\",{\"1\":{\"27\":1}}],[\"即长度为\",{\"1\":{\"26\":1}}],[\"即添加的新元素会放在链表尾节点\",{\"1\":{\"19\":1}}],[\"即\",{\"1\":{\"19\":2,\"27\":2,\"41\":1}}],[\"即数据元素\",{\"1\":{\"6\":1}}],[\"即一个key对应一个value\",{\"1\":{\"2\":1}}],[\"存储的元素数量在\",{\"1\":{\"21\":1}}],[\"存储的元素数量达到该值\",{\"1\":{\"5\":1}}],[\"存在返回值\",{\"1\":{\"9\":1}}],[\"存放键值对\",{\"1\":{\"6\":1}}],[\"判断类型\",{\"1\":{\"43\":1}}],[\"判断两个尾节点\",{\"1\":{\"27\":1}}],[\"判断是树节点还是链表节点\",{\"1\":{\"25\":1}}],[\"判断是否为树节点\",{\"1\":{\"24\":1}}],[\"判断是否超过阈值\",{\"1\":{\"24\":1}}],[\"判断是否需要重新计算\",{\"1\":{\"10\":1}}],[\"判断是否\",{\"1\":{\"9\":1}}],[\"判断下标处元素\",{\"1\":{\"24\":1}}],[\"判断该位置是否为空\",{\"1\":{\"24\":1}}],[\"判断值是否相同\",{\"1\":{\"14\":1}}],[\"判断key是否\",{\"1\":{\"9\":1}}],[\"判断key是否重复\",{\"1\":{\"8\":1}}],[\"判断key是否为null\",{\"1\":{\"8\":1}}],[\"判断传递的value是否已有key进行映射\",{\"1\":{\"6\":1}}],[\"判断传递的key在\",{\"1\":{\"6\":1}}],[\"判断\",{\"1\":{\"6\":1,\"8\":2,\"9\":1,\"24\":2}}],[\"返回请求处理结果\",{\"1\":{\"41\":1}}],[\"返回\",{\"1\":{\"6\":1}}],[\"常用方法\",{\"0\":{\"6\":1}}],[\"一旦\",{\"1\":{\"5\":1}}],[\"一些配置还有内容还需要时间慢慢缝补\",{\"1\":{\"0\":1}}],[\"重要的变化可以简单归纳为\",{\"1\":{\"29\":1}}],[\"重要的是内部静态类增加了treenode<k\",{\"1\":{\"23\":1}}],[\"重复则覆盖并返回旧值\",{\"1\":{\"8\":1}}],[\"重新计算阈值\",{\"1\":{\"10\":1}}],[\"重新调整\",{\"1\":{\"5\":1}}],[\"重新扩容等\",{\"1\":{\"5\":1}}],[\"重拾博客\",{\"1\":{\"0\":1}}],[\"如上即为连接获取后autocommit的修改操作\",{\"1\":{\"44\":1}}],[\"如添加好友\",{\"1\":{\"41\":1}}],[\"如资源准备\",{\"1\":{\"33\":1}}],[\"如新增树节点\",{\"1\":{\"28\":1}}],[\"如果数组本就为空\",{\"1\":{\"27\":1}}],[\"如果链表长度大于等于treeify\",{\"1\":{\"24\":1}}],[\"如果加入新元素超过阈值\",{\"1\":{\"8\":1}}],[\"如此一来\",{\"1\":{\"20\":1}}],[\"如修改值\",{\"1\":{\"5\":1}}],[\"如下图\",{\"1\":{\"27\":1}}],[\"如下图所示\",{\"1\":{\"26\":1}}],[\"如下\",{\"1\":{\"4\":1,\"37\":1}}],[\"记录\",{\"1\":{\"5\":1,\"41\":1}}],[\"method\",{\"1\":{\"37\":1}}],[\"move\",{\"1\":{\"27\":1}}],[\"modcount++\",{\"1\":{\"8\":1}}],[\"modcount\",{\"1\":{\"5\":1}}],[\"mustrestoreautocommit\",{\"1\":{\"44\":2}}],[\"must\",{\"1\":{\"27\":1}}],[\"min\",{\"1\":{\"10\":1}}],[\"misc\",{\"1\":{\"10\":1}}],[\"manual\",{\"1\":{\"44\":2}}],[\"math\",{\"1\":{\"10\":1}}],[\"max\",{\"1\":{\"10\":2,\"27\":2}}],[\"maximum\",{\"1\":{\"10\":3,\"27\":4}}],[\"mapping\",{\"1\":{\"24\":1}}],[\"map\",{\"1\":{\"2\":2,\"3\":1,\"4\":2,\"23\":1}}],[\"当连接默认为自动提交时\",{\"1\":{\"44\":1}}],[\"当服务端接收\",{\"1\":{\"41\":1}}],[\"当存在多个事务同步且有顺序要去时可指定\",{\"1\":{\"34\":1}}],[\"当存值时若元素数量大于阈值threshold则进行扩容\",{\"1\":{\"14\":1}}],[\"当节点不存在则新增\",{\"1\":{\"24\":1}}],[\"当节点数量达到\",{\"1\":{\"21\":1}}],[\"当链表节点数量\",{\"1\":{\"24\":1}}],[\"当链表节点数量大于等于\",{\"1\":{\"21\":1}}],[\"当发生哈希碰撞时\",{\"1\":{\"21\":1}}],[\"当碰撞频率高时\",{\"1\":{\"20\":1}}],[\"当线程一恢复运行后\",{\"1\":{\"19\":1}}],[\"当通过put\",{\"1\":{\"14\":1}}],[\"当\",{\"1\":{\"5\":1,\"41\":1}}],[\"当前节点的前一节点\",{\"1\":{\"23\":1}}],[\"当前\",{\"1\":{\"4\":1}}],[\"阈值大小计算为\",{\"1\":{\"5\":1}}],[\"阈值\",{\"1\":{\"5\":2}}],[\"负载因子\",{\"1\":{\"5\":2}}],[\"left\",{\"1\":{\"23\":1}}],[\"length\",{\"1\":{\"8\":5,\"9\":1,\"10\":2,\"19\":1,\"24\":2,\"25\":1,\"27\":1}}],[\"lowest\",{\"1\":{\"34\":1}}],[\"lotail\",{\"1\":{\"27\":7}}],[\"lohead\",{\"1\":{\"27\":4}}],[\"load\",{\"1\":{\"27\":1}}],[\"loadfactor\",{\"1\":{\"5\":2,\"10\":1,\"27\":1}}],[\"logger\",{\"1\":{\"44\":7}}],[\"log\",{\"1\":{\"20\":1,\"21\":1}}],[\"linkedhashmap\",{\"1\":{\"2\":1,\"23\":2}}],[\"framework\",{\"0\":{\"51\":1}}],[\"from\",{\"1\":{\"27\":1,\"44\":1}}],[\"f\",{\"1\":{\"41\":11}}],[\"flush\",{\"1\":{\"34\":1}}],[\"float\",{\"1\":{\"5\":1,\"27\":3}}],[\"ft\",{\"1\":{\"27\":3}}],[\"fail\",{\"1\":{\"41\":1}}],[\"fallbackexecution\",{\"1\":{\"37\":1}}],[\"false\",{\"1\":{\"24\":2,\"37\":1,\"44\":2}}],[\"factor\",{\"1\":{\"27\":1}}],[\"field\",{\"1\":{\"27\":1}}],[\"first\",{\"1\":{\"25\":9}}],[\"final\",{\"1\":{\"4\":1,\"5\":2,\"9\":1,\"21\":2,\"23\":3,\"24\":1,\"25\":1,\"26\":1,\"27\":1}}],[\"for\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"19\":1,\"24\":3,\"27\":2,\"44\":2}}],[\"switching\",{\"1\":{\"44\":1}}],[\"switch\",{\"1\":{\"44\":1}}],[\"so\",{\"1\":{\"44\":1}}],[\"some\",{\"1\":{\"44\":1}}],[\"something\",{\"1\":{\"43\":2}}],[\"source\",{\"1\":{\"37\":3}}],[\"save\",{\"1\":{\"36\":1,\"37\":1}}],[\"same\",{\"1\":{\"27\":1}}],[\"system\",{\"1\":{\"36\":4,\"37\":1}}],[\"synchronize同步锁\",{\"1\":{\"12\":1}}],[\"string\",{\"1\":{\"36\":2,\"37\":1}}],[\"status\",{\"1\":{\"34\":1,\"36\":2}}],[\"static\",{\"1\":{\"4\":1,\"5\":1,\"8\":1,\"21\":2,\"23\":3,\"26\":1}}],[\"stay\",{\"1\":{\"27\":1}}],[\"spel\",{\"1\":{\"37\":1}}],[\"spring\",{\"0\":{\"32\":1,\"50\":1},\"1\":{\"41\":1,\"44\":5,\"45\":1},\"2\":{\"46\":1,\"47\":1}}],[\"split\",{\"1\":{\"27\":3}}],[\"signifies\",{\"1\":{\"27\":1}}],[\"size++\",{\"1\":{\"8\":1}}],[\"size\",{\"1\":{\"5\":1,\"6\":1,\"8\":1,\"27\":1}}],[\"success\",{\"1\":{\"41\":1}}],[\"suspend\",{\"1\":{\"34\":1}}],[\"suppresswarnings\",{\"1\":{\"27\":1}}],[\"super\",{\"1\":{\"23\":2,\"37\":1}}],[\"sun\",{\"1\":{\"10\":1}}],[\"setautocommit\",{\"1\":{\"44\":2}}],[\"setmustrestoreautocommit\",{\"1\":{\"44\":1}}],[\"setreadonly\",{\"1\":{\"44\":1}}],[\"setpreviousisolationlevel\",{\"1\":{\"44\":1}}],[\"setsynchronizedwithtransaction\",{\"1\":{\"44\":1}}],[\"setconnectionholder\",{\"1\":{\"44\":1}}],[\"set>\",{\"1\":{\"6\":1}}],[\"set\",{\"1\":{\"6\":3,\"44\":1}}],[\"t\",{\"1\":{\"44\":1}}],[\"to\",{\"1\":{\"44\":4}}],[\"type\",{\"1\":{\"37\":1}}],[\"txobject\",{\"1\":{\"44\":16}}],[\"txsyncevent\",{\"1\":{\"37\":4}}],[\"txsyncdemo\",{\"1\":{\"36\":3,\"37\":1}}],[\"txdemo\",{\"1\":{\"36\":2,\"37\":2}}],[\"txcontroller\",{\"1\":{\"36\":1,\"37\":1}}],[\"txname\",{\"1\":{\"36\":5}}],[\"two\",{\"1\":{\"27\":2}}],[\"target\",{\"1\":{\"27\":1,\"37\":1,\"41\":3}}],[\"tab\",{\"1\":{\"24\":8,\"25\":4}}],[\"table\",{\"1\":{\"5\":1,\"8\":7,\"9\":2,\"10\":3,\"19\":1,\"24\":3,\"25\":1,\"27\":4}}],[\"thread\",{\"1\":{\"44\":1}}],[\"threshold\",{\"1\":{\"5\":2,\"8\":1,\"10\":3,\"21\":2,\"24\":3,\"27\":8}}],[\"throwable\",{\"1\":{\"44\":2}}],[\"the\",{\"1\":{\"27\":2,\"44\":3}}],[\"this\",{\"1\":{\"8\":1,\"23\":4,\"24\":1,\"27\":1,\"36\":1,\"44\":2}}],[\"try\",{\"1\":{\"44\":2}}],[\"true\",{\"1\":{\"24\":2,\"37\":1,\"44\":5}}],[\"treenode\",{\"1\":{\"23\":1,\"24\":1,\"25\":1,\"27\":2}}],[\"treenode<k\",{\"0\":{\"23\":1},\"1\":{\"23\":6,\"24\":1,\"25\":1,\"27\":1}}],[\"treeifybin\",{\"1\":{\"24\":1}}],[\"treeify\",{\"1\":{\"21\":1,\"24\":1}}],[\"treemap\",{\"1\":{\"2\":1}}],[\"transactiondefinition\",{\"1\":{\"44\":1}}],[\"transaction\",{\"1\":{\"44\":6},\"2\":{\"47\":1}}],[\"transactionphase\",{\"1\":{\"37\":3,\"43\":1}}],[\"transactionaleventlistener注解classes属性是否有指定值分情况说明\",{\"1\":{\"39\":1}}],[\"transactionaleventlistener\",{\"1\":{\"37\":2,\"43\":1}}],[\"transactionaleventlistener与applicationevent事件对象两者搭配使用\",{\"1\":{\"37\":1}}],[\"transactional\",{\"1\":{\"36\":1,\"37\":1}}],[\"transactional注解方法来完成事务操作\",{\"1\":{\"33\":1}}],[\"transactionsynchronizationmanager\",{\"1\":{\"36\":1,\"44\":1}}],[\"transactionsynchronization\",{\"1\":{\"34\":1}}],[\"transactionsynchronizationadapter\",{\"1\":{\"34\":1,\"36\":1}}],[\"transfer\",{\"0\":{\"10\":1},\"1\":{\"10\":2,\"18\":1,\"19\":1}}],[\"transient\",{\"1\":{\"5\":3}}],[\"内部定义的几个主要属性如下\",{\"1\":{\"5\":1}}],[\"并通过注解属性指定回调时的事务阶段和感兴趣的事件\",{\"1\":{\"37\":1}}],[\"并可通过ordered接口控制多个事务同步的执行顺序\",{\"1\":{\"34\":1}}],[\"并判断节点在新数组的位置\",{\"1\":{\"27\":1}}],[\"并含有before\",{\"1\":{\"23\":1}}],[\"并且利用事务同步功能\",{\"1\":{\"45\":1}}],[\"并且得等到清理资源时才提交\",{\"1\":{\"42\":1}}],[\"并且至少得等到下一次有用户对\",{\"1\":{\"41\":1}}],[\"并且\",{\"1\":{\"29\":1}}],[\"并且在扩容方法的\",{\"1\":{\"19\":1}}],[\"并且死链情况在\",{\"1\":{\"13\":1}}],[\"并发扩容出现死链\",{\"1\":{\"19\":1}}],[\"并发情况下\",{\"1\":{\"13\":1}}],[\"并解决了死链问题\",{\"1\":{\"18\":1}}],[\"并将key\",{\"1\":{\"14\":1}}],[\"并重新计算阈值\",{\"1\":{\"10\":1}}],[\"并保存了下一个entry<k\",{\"1\":{\"4\":1}}],[\"并采用\",{\"1\":{\"3\":1}}],[\"这个变量后面恢复连接自动提交时会用到\",{\"1\":{\"44\":1}}],[\"这个过程称为\",{\"1\":{\"10\":1}}],[\"这一步从数据库连接池里获取连接\",{\"1\":{\"44\":1}}],[\"这就导致\",{\"1\":{\"26\":1}}],[\"这就导致了并发扩容时\",{\"1\":{\"19\":1}}],[\"这才有了转换的必要\",{\"1\":{\"21\":1}}],[\"这两个方法在\",{\"1\":{\"40\":1}}],[\"这两个方法主要是数组扩容和数据复制\",{\"1\":{\"10\":1}}],[\"这两步获取元素的时间复杂度为\",{\"1\":{\"20\":1}}],[\"这样就避免了死链问题\",{\"1\":{\"19\":1}}],[\"这样在扩容时就不会出现元素逆序的情况\",{\"1\":{\"19\":1}}],[\"这篇里讲解的非常清楚\",{\"1\":{\"13\":1}}],[\"这里是从连接池获取连接的操作\",{\"1\":{\"44\":1}}],[\"这里就不多赘述\",{\"1\":{\"10\":1}}],[\"这里需要注意\",{\"1\":{\"4\":1}}],[\"这也是为什么\",{\"1\":{\"4\":1}}],[\"==\",{\"1\":{\"8\":3,\"9\":5,\"10\":2,\"19\":1,\"24\":9,\"25\":5,\"26\":1,\"27\":6}}],[\"=\",{\"1\":{\"4\":4,\"5\":1,\"8\":14,\"9\":7,\"10\":16,\"19\":8,\"21\":2,\"23\":4,\"24\":20,\"25\":14,\"26\":1,\"27\":43,\"36\":2,\"37\":7,\"43\":2,\"44\":6}}],[\"not\",{\"1\":{\"44\":1}}],[\"node\",{\"1\":{\"23\":1,\"25\":1,\"27\":1}}],[\"node<k\",{\"0\":{\"23\":1},\"1\":{\"23\":8,\"24\":3,\"25\":4,\"27\":8}}],[\"npe\",{\"1\":{\"12\":1}}],[\"necessary\",{\"1\":{\"44\":1}}],[\"netty\",{\"1\":{\"41\":2}}],[\"newcon\",{\"1\":{\"44\":3}}],[\"newcap\",{\"1\":{\"27\":8}}],[\"newcapacity\",{\"1\":{\"10\":6,\"19\":2}}],[\"newtab\",{\"1\":{\"27\":7}}],[\"newtable\",{\"1\":{\"10\":7,\"19\":4}}],[\"newthr\",{\"1\":{\"27\":6}}],[\"newnode\",{\"1\":{\"24\":2}}],[\"new\",{\"1\":{\"8\":1,\"10\":1,\"27\":2,\"36\":1,\"37\":1,\"44\":1}}],[\"next\",{\"1\":{\"4\":3,\"8\":1,\"9\":1,\"10\":5,\"13\":2,\"19\":5,\"23\":8,\"24\":4,\"25\":2,\"27\":9}}],[\"null\",{\"1\":{\"8\":7,\"9\":11,\"10\":2,\"12\":1,\"19\":2,\"24\":10,\"25\":9,\"26\":1,\"27\":17,\"44\":1}}],[\"n\",{\"1\":{\"4\":2,\"20\":4,\"24\":4,\"25\":3,\"26\":3,\"27\":4}}],[\"构造函数\",{\"1\":{\"4\":1}}],[\"值与旧数组长度\",{\"1\":{\"27\":1}}],[\"值跟原数组长度\",{\"1\":{\"27\":1}}],[\"值找到数组下标\",{\"1\":{\"25\":1}}],[\"值并通过该值确定数组下标位置\",{\"1\":{\"8\":1}}],[\"值是否相同且不为\",{\"1\":{\"9\":1}}],[\"值是否相同\",{\"1\":{\"8\":1}}],[\"值和\",{\"1\":{\"8\":1,\"9\":1,\"24\":1}}],[\"值计算数组下标\",{\"1\":{\"8\":1}}],[\"值\",{\"1\":{\"4\":1,\"8\":1,\"9\":1,\"20\":1,\"24\":2,\"27\":1}}],[\"it\",{\"1\":{\"44\":2}}],[\"im\",{\"1\":{\"41\":1}}],[\"implements\",{\"1\":{\"4\":1,\"23\":1,\"34\":1}}],[\"ismustrestoreautocommit\",{\"1\":{\"44\":1}}],[\"isnewconnectionholder\",{\"1\":{\"44\":2}}],[\"is\",{\"1\":{\"44\":1}}],[\"isreadonly\",{\"1\":{\"44\":2}}],[\"isdebugenabled\",{\"1\":{\"44\":3}}],[\"issynchronizedwithtransaction\",{\"1\":{\"44\":1}}],[\"isassignableform\",{\"1\":{\"43\":1}}],[\"isactualtransactionactive\",{\"1\":{\"40\":1}}],[\"isbooted\",{\"1\":{\"10\":1}}],[\"isempty\",{\"1\":{\"6\":1}}],[\"i\",{\"1\":{\"8\":3,\"10\":3,\"19\":3,\"24\":3}}],[\"if\",{\"1\":{\"8\":3,\"9\":2,\"10\":2,\"19\":1,\"24\":10,\"25\":5,\"27\":15,\"43\":3,\"44\":11}}],[\"in\",{\"1\":{\"27\":4,\"44\":1}}],[\"instanceof\",{\"1\":{\"24\":1,\"25\":1,\"27\":1,\"43\":2}}],[\"index\",{\"1\":{\"8\":1,\"20\":1,\"27\":2}}],[\"indexfor\",{\"1\":{\"8\":3,\"9\":2,\"10\":1,\"19\":1}}],[\"initializes\",{\"1\":{\"27\":1}}],[\"initial\",{\"1\":{\"5\":1,\"27\":6}}],[\"interface\",{\"1\":{\"37\":1}}],[\"integer\",{\"1\":{\"10\":2,\"27\":2,\"44\":1}}],[\"int\",{\"1\":{\"4\":2,\"5\":4,\"6\":1,\"8\":9,\"9\":1,\"10\":5,\"19\":2,\"21\":2,\"23\":4,\"24\":3,\"25\":2,\"26\":2,\"27\":6,\"34\":2,\"36\":1}}],[\"keyset\",{\"1\":{\"6\":1}}],[\"key\",{\"1\":{\"4\":2,\"6\":4,\"8\":17,\"9\":13,\"10\":2,\"12\":2,\"14\":1,\"19\":2,\"23\":9,\"24\":18,\"25\":13,\"26\":4}}],[\"key唯一\",{\"1\":{\"3\":1}}],[\"k\",{\"1\":{\"4\":4,\"6\":1,\"8\":6,\"9\":3,\"23\":4,\"24\":9,\"25\":7}}],[\"catch\",{\"1\":{\"44\":2}}],[\"capacity也就是构建\",{\"1\":{\"5\":1}}],[\"capacity\",{\"1\":{\"5\":2,\"10\":3,\"27\":9}}],[\"channel\",{\"1\":{\"41\":1}}],[\"check\",{\"1\":{\"25\":1}}],[\"could\",{\"1\":{\"44\":1}}],[\"component\",{\"1\":{\"37\":1}}],[\"commit\",{\"1\":{\"37\":2,\"43\":1,\"44\":2}}],[\"configured\",{\"1\":{\"44\":1}}],[\"con\",{\"1\":{\"44\":11}}],[\"connectionholder\",{\"1\":{\"44\":2}}],[\"connection\",{\"1\":{\"44\":10}}],[\"condition\",{\"1\":{\"13\":1,\"37\":1}}],[\"concurrenthashmap\",{\"1\":{\"12\":1}}],[\"containsvalue\",{\"1\":{\"6\":1}}],[\"containskey\",{\"1\":{\"6\":1}}],[\"continue\",{\"1\":{\"0\":1}}],[\"c\",{\"1\":{\"19\":3}}],[\"createentry\",{\"1\":{\"8\":2}}],[\"clear\",{\"1\":{\"6\":1,\"44\":1}}],[\"classes指定多个值时\",{\"1\":{\"39\":1}}],[\"classes\",{\"1\":{\"37\":4,\"43\":1}}],[\"class\",{\"1\":{\"4\":1,\"23\":3,\"34\":1,\"36\":3,\"37\":9,\"39\":2,\"43\":2}}],[\"类中对它有一个静态实现\",{\"1\":{\"4\":1}}],[\"类图\",{\"1\":{\"3\":1}}],[\"类图如下\",{\"1\":{\"3\":1}}],[\"键值对\",{\"1\":{\"4\":1}}],[\"本质上是为了保证一次业务请求处理过程中涉及多次\",{\"1\":{\"33\":1}}],[\"本质上是一个映射\",{\"1\":{\"4\":1}}],[\"本篇\",{\"1\":{\"2\":1}}],[\"而偏偏这个操作\",{\"1\":{\"44\":1}}],[\"而发布\",{\"1\":{\"39\":1}}],[\"而本篇主要讲述的事务功能是实现在事务执行的某个阶段去做某些事\",{\"1\":{\"33\":1}}],[\"而本篇的主角是\",{\"1\":{\"2\":1}}],[\"而这些改变对\",{\"1\":{\"29\":1}}],[\"而且对不了解红黑树的读者会很不友好\",{\"1\":{\"28\":1}}],[\"而红黑树相关的内容\",{\"1\":{\"28\":1}}],[\"而红黑树是一种自平衡的二叉查找树\",{\"1\":{\"20\":1}}],[\"而进入该类\",{\"1\":{\"23\":1}}],[\"而选择\",{\"1\":{\"21\":1}}],[\"而链表则为\",{\"1\":{\"21\":1}}],[\"而链表则是单向的\",{\"1\":{\"4\":1}}],[\"而一旦节点数量小于等于\",{\"1\":{\"21\":1}}],[\"而在\",{\"1\":{\"19\":1}}],[\"而线程二直接完成了扩容操作\",{\"1\":{\"19\":1}}],[\"而\",{\"1\":{\"13\":1}}],[\"而此时\",{\"1\":{\"13\":1}}],[\"而它之所以是线程安全\",{\"1\":{\"12\":1}}],[\"而不是通过key确定数组下标后直接存放值\",{\"1\":{\"4\":1}}],[\"算法确定key\",{\"1\":{\"3\":1}}],[\"的连接\",{\"1\":{\"44\":1}}],[\"的事务机制有关\",{\"1\":{\"44\":1}}],[\"的事务未提交\",{\"1\":{\"41\":1}}],[\"的添加好友请求已处理完毕\",{\"1\":{\"41\":1}}],[\"的缓存删了等于没删\",{\"1\":{\"41\":1}}],[\"的视角来看\",{\"1\":{\"41\":1}}],[\"的请求处理完成\",{\"1\":{\"41\":1}}],[\"的查询请求\",{\"1\":{\"41\":1}}],[\"的性能提升一文中含有性能测试的结果\",{\"1\":{\"29\":1}}],[\"的原理解析\",{\"1\":{\"28\":1}}],[\"的哈希值进行\",{\"1\":{\"26\":1}}],[\"的构造方法\",{\"1\":{\"23\":1}}],[\"的实现\",{\"1\":{\"23\":1}}],[\"的下一节点又变成\",{\"1\":{\"19\":1}}],[\"的几个方法\",{\"1\":{\"18\":1}}],[\"的改变\",{\"0\":{\"17\":1}}],[\"的工作原理\",{\"1\":{\"14\":1}}],[\"的结构就变为了\",{\"1\":{\"13\":1}}],[\"的key不能为空\",{\"1\":{\"12\":1}}],[\"的区别\",{\"0\":{\"12\":1}}],[\"的设值\",{\"1\":{\"10\":1}}],[\"的table变量\",{\"1\":{\"10\":1}}],[\"的一半减1\",{\"1\":{\"10\":1}}],[\"的值为\",{\"1\":{\"10\":1}}],[\"的元素\",{\"1\":{\"9\":2}}],[\"的元素数量\",{\"1\":{\"6\":1}}],[\"的位置\",{\"1\":{\"8\":2}}],[\"的大小以便存放更多的元素\",{\"1\":{\"5\":1}}],[\"的size超过阈值\",{\"1\":{\"5\":1}}],[\"的默认初始容量\",{\"1\":{\"5\":1}}],[\"的幂次方\",{\"1\":{\"5\":1}}],[\"的内部接口\",{\"1\":{\"4\":1}}],[\"的底层结构是\",{\"1\":{\"4\":1}}],[\"的\",{\"1\":{\"3\":1,\"8\":1,\"9\":1,\"13\":3,\"18\":1,\"24\":1,\"26\":2,\"41\":3}}],[\"的源码和原理讲解全部基于\",{\"1\":{\"2\":1}}],[\"是在执行事务回调完成后\",{\"1\":{\"44\":1}}],[\"是跟\",{\"1\":{\"44\":1}}],[\"是则调用puttreeval\",{\"1\":{\"24\":1}}],[\"是假设当链表长度大于小于\",{\"1\":{\"21\":1}}],[\"是将索引下标处的链表节点全部遍历获取后\",{\"1\":{\"19\":1}}],[\"是因为put\",{\"1\":{\"12\":1}}],[\"是否相同\",{\"1\":{\"24\":1}}],[\"是否\",{\"1\":{\"9\":1}}],[\"是否为红色节点\",{\"1\":{\"23\":1}}],[\"是否为\",{\"1\":{\"8\":1}}],[\"是否为空\",{\"1\":{\"6\":1,\"24\":1}}],[\"是\",{\"1\":{\"4\":1,\"10\":1}}],[\"是作为\",{\"1\":{\"4\":1}}],[\"是通过计算key的hash值来确定数组下标位置\",{\"1\":{\"4\":1}}],[\"是基于哈希表\",{\"1\":{\"3\":1}}],[\"是一个key\",{\"1\":{\"2\":1}}],[\"75\",{\"1\":{\"5\":1}}],[\"7\",{\"1\":{\"2\":1,\"18\":1,\"19\":2,\"21\":1,\"24\":2}}],[\"用以应对不同业务情况下的数据存储与使用\",{\"1\":{\"2\":1}}],[\"等同于classes指定了该事件\",{\"1\":{\"39\":1}}],[\"等\",{\"1\":{\"2\":1}}],[\"ve\",{\"1\":{\"44\":1}}],[\"very\",{\"1\":{\"44\":1}}],[\"val\",{\"1\":{\"23\":2}}],[\"value是用entry<k\",{\"1\":{\"23\":1}}],[\"value作为\",{\"1\":{\"14\":1}}],[\"value封装为entry<k\",{\"1\":{\"8\":1}}],[\"value\",{\"1\":{\"4\":3,\"6\":2,\"8\":11,\"10\":2,\"23\":6,\"24\":9,\"25\":1,\"27\":2,\"37\":1}}],[\"value的存储位置从而保证其进行数据快速存取\",{\"1\":{\"3\":1}}],[\"value可重复\",{\"1\":{\"3\":1}}],[\"value形式保存数据\",{\"1\":{\"3\":1}}],[\"value键值对映射的接口\",{\"1\":{\"2\":1}}],[\"vm\",{\"1\":{\"10\":1}}],[\"void\",{\"1\":{\"6\":1,\"8\":2,\"10\":2,\"19\":1,\"34\":7,\"36\":3,\"37\":2,\"43\":1,\"44\":2}}],[\"v\",{\"1\":{\"4\":4,\"6\":4,\"8\":5,\"9\":1,\"23\":4,\"24\":5,\"25\":1}}],[\"v>本身并没有直接使用到这两个属性\",{\"1\":{\"23\":1}}],[\"v>类\",{\"1\":{\"23\":2}}],[\"v>类是继承linkedhashmap\",{\"1\":{\"23\":1}}],[\"v>类型数组\",{\"1\":{\"4\":1}}],[\"v>接口\",{\"1\":{\"23\":1}}],[\"v>的\",{\"1\":{\"6\":1}}],[\"v>节点的数据\",{\"1\":{\"4\":1}}],[\"v>对象保存\",{\"1\":{\"8\":1,\"23\":1}}],[\"v>对象保存了key\",{\"1\":{\"4\":1}}],[\"v>对象数组\",{\"1\":{\"5\":1}}],[\"v>对象\",{\"1\":{\"4\":2}}],[\"v>对象的下一个entry<k\",{\"1\":{\"4\":1}}],[\"v>对象进行存储\",{\"1\":{\"4\":1}}],[\"v>\",{\"0\":{\"23\":2},\"1\":{\"4\":8,\"8\":2,\"9\":3,\"10\":2,\"12\":2,\"14\":1,\"19\":2,\"23\":19,\"24\":4,\"25\":5,\"27\":9}}],[\"vuepress\",{\"1\":{\"0\":1}}],[\"时便设置为\",{\"1\":{\"44\":1}}],[\"时便已存在\",{\"1\":{\"2\":1}}],[\"时\",{\"1\":{\"21\":3,\"41\":1}}],[\"时指定的容量大小\",{\"1\":{\"5\":1}}],[\"时隔三年\",{\"1\":{\"0\":1}}],[\"jdbc\",{\"1\":{\"44\":5}}],[\"jdk\",{\"1\":{\"19\":1}}],[\"jdk1\",{\"1\":{\"2\":2,\"18\":1}}],[\"j\",{\"1\":{\"27\":7}}],[\"javadoc\",{\"1\":{\"40\":1}}],[\"java\",{\"0\":{\"17\":1,\"48\":1},\"1\":{\"0\":1,\"2\":1,\"13\":5,\"14\":1,\"18\":2,\"19\":2,\"20\":3,\"23\":2,\"26\":1,\"29\":1},\"2\":{\"15\":1,\"16\":1,\"30\":1,\"31\":1}}],[\"hasconnectionholder\",{\"1\":{\"44\":1}}],[\"hashcode\",{\"1\":{\"14\":1,\"20\":1,\"26\":2}}],[\"hashing\",{\"1\":{\"10\":1}}],[\"hash值\",{\"1\":{\"4\":1}}],[\"hash\",{\"0\":{\"26\":1},\"1\":{\"3\":1,\"4\":3,\"8\":18,\"9\":7,\"10\":5,\"19\":3,\"20\":1,\"23\":8,\"24\":14,\"25\":9,\"26\":5,\"27\":5,\"29\":1}}],[\"hashtable\",{\"0\":{\"12\":1},\"1\":{\"2\":1,\"3\":1,\"12\":3}}],[\"hashmap的死循环\",{\"1\":{\"13\":1}}],[\"hashmap\",{\"0\":{\"1\":1,\"13\":1,\"17\":1},\"1\":{\"2\":3,\"3\":2,\"4\":4,\"5\":9,\"6\":5,\"7\":1,\"8\":1,\"10\":3,\"12\":1,\"13\":5,\"14\":2,\"18\":5,\"19\":2,\"20\":2,\"21\":2,\"23\":2,\"26\":1,\"28\":2,\"29\":5},\"2\":{\"16\":1,\"31\":1}}],[\"hitail\",{\"1\":{\"27\":7}}],[\"hihead\",{\"1\":{\"27\":4}}],[\"held\",{\"1\":{\"27\":1}}],[\"hexo\",{\"1\":{\"0\":2}}],[\"holder\",{\"1\":{\"10\":1,\"44\":1}}],[\"h\",{\"1\":{\"4\":2,\"8\":2,\"26\":4}}],[\"聊聊\",{\"0\":{\"1\":1}}],[\"转向\",{\"1\":{\"0\":1}}],[\"从而实现事务的功能\",{\"1\":{\"44\":1}}],[\"从源码可看到事务同步作用就是在事务执行的各个阶段进行方法回调\",{\"1\":{\"34\":1}}],[\"从源码可以看出\",{\"1\":{\"4\":1}}],[\"从\",{\"1\":{\"0\":1,\"41\":1}}],[\"2^16\",{\"1\":{\"26\":1}}],[\"2\",{\"1\":{\"2\":1,\"5\":1,\"8\":2,\"9\":1,\"10\":2,\"21\":1,\"24\":2,\"25\":1,\"26\":1,\"27\":9,\"34\":1,\"37\":1,\"41\":4}}],[\"21\",{\"1\":{\"0\":1}}],[\"2023\",{\"1\":{\"0\":1}}],[\"2020\",{\"1\":{\"0\":2}}],[\"加上深感自己对技术的理解还不够深入\",{\"1\":{\"0\":1}}],[\"使用事务注解\",{\"1\":{\"37\":1}}],[\"使用注解标记方法\",{\"1\":{\"37\":1}}],[\"使用方式\",{\"0\":{\"35\":1}}],[\"使用是非常频繁的\",{\"1\":{\"29\":1}}],[\"使用\",{\"1\":{\"0\":1}}],[\"0001\",{\"1\":{\"27\":2}}],[\"0000\",{\"1\":{\"27\":2}}],[\"0\",{\"1\":{\"5\":1,\"8\":3,\"9\":3,\"10\":1,\"19\":1,\"24\":2,\"25\":1,\"26\":1,\"27\":12,\"34\":1,\"39\":1}}],[\"09\",{\"1\":{\"0\":2}}],[\"08\",{\"1\":{\"0\":2}}],[\"07\",{\"1\":{\"0\":1}}],[\"博客刚切换\",{\"1\":{\"0\":1}}],[\"~\",{\"1\":{\"0\":1}}],[\"●ˇ∀ˇ●\",{\"1\":{\"0\":1,\"28\":1}}],[\"开发一枚\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
