const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":88,\"nextId\":88,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-e005054c\",\"2\":\"v-e005054c#前言\",\"3\":\"v-e005054c#基础\",\"4\":\"v-e005054c#结构\",\"5\":\"v-e005054c#属性\",\"6\":\"v-e005054c#常用方法\",\"7\":\"v-e005054c#方法原理\",\"8\":\"v-e005054c#put-方法实现\",\"9\":\"v-e005054c#get-方法实现\",\"10\":\"v-e005054c#resize-transfer-方法实现\",\"11\":\"v-e005054c#补充\",\"12\":\"v-e005054c#与-hashtable-的区别\",\"13\":\"v-e005054c#hashmap-死链问题\",\"14\":\"v-e005054c#总结\",\"15\":\"v-e005054c@0\",\"16\":\"v-e005054c@1\",\"17\":\"v-71db46f9\",\"18\":\"v-71db46f9#前言\",\"19\":\"v-71db46f9#死链原因和解决方法\",\"20\":\"v-71db46f9#结构变化\",\"21\":\"v-71db46f9#链表与红黑树转换时机\",\"22\":\"v-71db46f9#原理解析\",\"23\":\"v-71db46f9#node-k-v-和-treenode-k-v\",\"24\":\"v-71db46f9#put-方法\",\"25\":\"v-71db46f9#get-方法\",\"26\":\"v-71db46f9#hash-方法\",\"27\":\"v-71db46f9#resize-方法\",\"28\":\"v-71db46f9#关于红黑树\",\"29\":\"v-71db46f9#尾声\",\"30\":\"v-71db46f9@0\",\"31\":\"v-71db46f9@1\",\"32\":\"v-a973e02c\",\"33\":\"v-a973e02c#什么是类的加载\",\"34\":\"v-a973e02c#类的加载过程\",\"35\":\"v-a973e02c#加载\",\"36\":\"v-a973e02c#连接\",\"37\":\"v-a973e02c#验证-确保被加载的类的正确性\",\"38\":\"v-a973e02c#准备-为类的静态变量分配内存-并将其初始化为默认值\",\"39\":\"v-a973e02c#解析-把常量池内的符号引用转换为直接引用\",\"40\":\"v-a973e02c#初始化\",\"41\":\"v-a973e02c#类加载器\",\"42\":\"v-a973e02c#双亲委派模型\",\"43\":\"v-a973e02c#自定义类加载器\",\"44\":\"v-a973e02c#总结\",\"45\":\"v-a973e02c#参考资料\",\"46\":\"v-a973e02c@0\",\"47\":\"v-a973e02c@1\",\"48\":\"v-3d8443f8\",\"49\":\"v-3d8443f8#什么是-jvm\",\"50\":\"v-3d8443f8#概念\",\"51\":\"v-3d8443f8#理解\",\"52\":\"v-3d8443f8#jvm-内存模型\",\"53\":\"v-3d8443f8#程序计数器-私有\",\"54\":\"v-3d8443f8#虚拟机栈-私有\",\"55\":\"v-3d8443f8#栈帧-stack-frame-结构\",\"56\":\"v-3d8443f8#异常-exception\",\"57\":\"v-3d8443f8#本地方法栈-私有\",\"58\":\"v-3d8443f8#堆-共享\",\"59\":\"v-3d8443f8#异常-exception-1\",\"60\":\"v-3d8443f8#方法区-共享\",\"61\":\"v-3d8443f8#运行时常量池\",\"62\":\"v-3d8443f8#补充\",\"63\":\"v-3d8443f8#总结\",\"64\":\"v-3d8443f8#参考资料\",\"65\":\"v-3d8443f8#花絮\",\"66\":\"v-3d8443f8@0\",\"67\":\"v-3d8443f8@1\",\"68\":\"v-2560cb50\",\"69\":\"v-2560cb50#前言\",\"70\":\"v-2560cb50#事务同步接口\",\"71\":\"v-2560cb50#使用方式\",\"72\":\"v-2560cb50#基于接口\",\"73\":\"v-2560cb50#基于注解\",\"74\":\"v-2560cb50#注意事项\",\"75\":\"v-2560cb50#注解方式方法入参问题\",\"76\":\"v-2560cb50#aftercommit-aftercompletion-事务范围问题\",\"77\":\"v-2560cb50#实际场景\",\"78\":\"v-2560cb50#思考题\",\"79\":\"v-2560cb50#问题一\",\"80\":\"v-2560cb50#问题二\",\"81\":\"v-2560cb50#总结\",\"82\":\"v-2560cb50@0\",\"83\":\"v-2560cb50@1\",\"84\":\"v-09041878\",\"85\":\"v-e1e3da16\",\"86\":\"v-7783265c\",\"87\":\"v-1a2ef2a6\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,28],\"1\":[2],\"2\":[1,25],\"3\":[1,16],\"4\":[1,60],\"5\":[1,50],\"6\":[1,39],\"7\":[1,7],\"8\":[2,99],\"9\":[2,59],\"10\":[3,104],\"11\":[1],\"12\":[3,33],\"13\":[2,38],\"14\":[1,30],\"15\":[null,null,1],\"16\":[null,null,3],\"17\":[5],\"18\":[1,28],\"19\":[1,75],\"20\":[1,40],\"21\":[1,40],\"22\":[1],\"23\":[4,69],\"24\":[2,126],\"25\":[2,57],\"26\":[2,59],\"27\":[2,218],\"28\":[1,22],\"29\":[1,28],\"30\":[null,null,1],\"31\":[null,null,3],\"32\":[2,14],\"33\":[1,43],\"34\":[1,10],\"35\":[1,17],\"36\":[1,4],\"37\":[2,23],\"38\":[3,27],\"39\":[2,29],\"40\":[1,64],\"41\":[1,47],\"42\":[1,36],\"43\":[1,22],\"44\":[1,24],\"45\":[1,5],\"46\":[null,null,1],\"47\":[null,null,2],\"48\":[2],\"49\":[2],\"50\":[1,30],\"51\":[1,49],\"52\":[2,33],\"53\":[3,24],\"54\":[3,18],\"55\":[4,16],\"56\":[3,8],\"57\":[3,22],\"58\":[3,51],\"59\":[3,6],\"60\":[3,53],\"61\":[1,30],\"62\":[1,38],\"63\":[1,18],\"64\":[1,21],\"65\":[1,31],\"66\":[null,null,1],\"67\":[null,null,2],\"68\":[2],\"69\":[1,18],\"70\":[1,49],\"71\":[1],\"72\":[1,50],\"73\":[1,98],\"74\":[1],\"75\":[1,37],\"76\":[3,15],\"77\":[1,111],\"78\":[1,14],\"79\":[1,30],\"80\":[1,157],\"81\":[1,16],\"82\":[null,null,1],\"83\":[null,null,2],\"84\":[1],\"85\":[1],\"86\":[1],\"87\":[1]},\"averageFieldLength\":[1.6052452316474295,42.70896290369307,0.4517933092354589],\"storedFields\":{\"0\":{\"h\":\"关于作者\",\"t\":[\"Java 开发一枚 (●ˇ∀ˇ●) ~，博客刚切换，一些配置还有内容还需要时间慢慢缝补。\",\"2020.07.08，使用 Hexo 首次建立个人博客，也在同一天发布了第一篇文章\",\"2020.08.09，因工作琐事，加上深感自己对技术的理解还不够深入，经验也不够充足，所以停更，更专注地学习各项技术\",\"2023.09.21，时隔三年，重拾博客，从 Hexo 转向 VuePress\",\"Continue...\"]},\"1\":{\"h\":\"聊聊 HashMap\"},\"2\":{\"h\":\"前言\",\"t\":[\"Map，Java 三大集合框架之一，JDK1.2 时便已存在，是一个Key-Value键值对映射的接口，即一个Key对应一个Value。在日常开发使用中，我们常见的 Map 实现类有：HashMap、Hashtable、TreeMap、LinkedHashMap 等，用以应对不同业务情况下的数据存储与使用。而本篇的主角是 HashMap，让我们来粗浅的聊聊它吧。（注意：本篇 HashMap 的源码和原理讲解全部基于 JDK1.7）\"]},\"3\":{\"h\":\"基础\",\"t\":[\"HashMap 是基于哈希表（Hashtable）的 Map 实现类，以Key-Value形式保存数据，Key唯一，Value可重复，并采用 Hash 算法确定Key-Value的存储位置从而保证其进行数据快速存取。类图如下：\",\"HashMap 类图\"]},\"4\":{\"h\":\"结构\",\"t\":[\"HashMap 的底层结构是 数组+链表，是通过计算key的hash值来确定数组下标位置，然后将key和value作为Entry<K,V>对象进行存储。这里需要注意，是作为 Entry<K,V> 对象存储，而不是通过key确定数组下标后直接存放值。Entry<K,V> 是 Map 的内部接口，本质上是一个映射（键值对），HashMap 类中对它有一个静态实现，如下：\",\"static class Entry<K,V> implements Map.Entry<K,V> { final K key; V value; Entry<K,V> next; //链表节点中的下一个 Entry<K,V> 对象 int hash; //当前 Entry 对象的 hash 值 //构造函数 Entry(int h, K k, V v, Entry<K,V> n) { value = v; next = n; key = k; hash = h; } //其它代码省略 ... } \",\"从源码可以看出，Entry<K,V>对象保存了key、value、hash值，还保存了当前Entry<K,V>对象的下一个Entry<K,V>对象：Entry<K,V> next。这也是为什么 HasHMap 结构是数组+链表，数组其实就是Entry<K,V>类型数组，而链表则是单向的，每个节点都是一个Entry<K,V>对象，并保存了下一个Entry<K,V>节点的数据，通过一张图来简单理解下：\",\"HashMap 结构图\"]},\"5\":{\"h\":\"属性\",\"t\":[\"HashMap 内部定义的几个主要属性如下：\",\"transient Entry[] table：Entry<K,V>对象数组，长度始终保持为 2 的幂次方\",\"transient int size：HashMap 已存储的元素数量\",\"final float loadFactor：负载因子，默认是 0.75，扩容时使用\",\"static final int DEFAULT_INITIAL_CAPACITY：HashMap 的默认初始容量\",\"int threshold：阈值，当 HashMap 存储的元素数量达到该值，则会触发扩容操作\",\"transient int modCount：记录 HashMap 结构修改的次数，如修改值、重新扩容等\",\"HashMap 阈值大小计算为： capacity(容量) * loadFactor(负载因子) = threshold(阈值) ，capacity也就是构建 HashMap 时指定的容量大小（不指定则默认为 16）。一旦 HashMap 的size超过阈值，就会进行扩容操作，重新调整 HashMap 的大小以便存放更多的元素。\"]},\"6\":{\"h\":\"常用方法\",\"t\":[\"public int size()：返回 HashMap 的元素数量\",\"public boolean isEmpty()：判断 HashMap 是否为空\",\"public V put(K key, V value)：存放键值对，即数据元素\",\"public V get(Object key)：通过key获取Value`\",\"public V remove(Object key)：通过key删除元素\",\"public void clear()：清空 HashMap\",\"public boolean containsKey(Object key)：判断传递的key在 HashMap 中是否已存在\",\"public boolean containsValue(Object value)：判断传递的value是否已有key进行映射\",\"public Set keySet()：获取所有key的 Set 集合\",\"public Set> entrySet()：获取所有Entry<K,V>的 Set 集合，可以用来遍历 HashMap\"]},\"7\":{\"h\":\"方法原理\",\"t\":[\"接下来我们具体看看 HashMap 设值、取值、扩容、复制数据等方法的具体实现是怎么样的。\"]},\"8\":{\"h\":\"put 方法实现\",\"t\":[\"public V put(K key, V value) { if (key == null) return putForNullKey(value); //1.判断 key 是否为 Null，为 Null 直接存放在数组下标 0 的位置 int hash = hash(key); //2.计算 key 的 hash 值 int i = indexFor(hash, table.length); //3.通过 hash 值计算数组下标 index for (Entry<K,V> e = table[i]; e != null; e = e.next) { Object k; //4.判断 hash 值和 key 值是否相同，相同则覆盖并返回旧值 if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; //5.修改次数 +1 addEntry(hash, key, value, i); //6.将 key-value 封装为 Entry 对象并添加， return null; } static int indexFor(int h, int length) { return h & (length-1); // 数组长度-1，按位与计算出下标 } void addEntry(int hash, K key, V value, int bucketIndex) { //如果加入新元素超过阈值，则扩容为原来的2倍大小 if ((size >= threshold) && (null != table[bucketIndex])) { resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); // 创建 Entry } void createEntry(int hash, K key, V value, int bucketIndex) { Entry<K,V> e = table[bucketIndex]; //若 e 不为空，则说明发生 hash 碰撞，将 Entry 插入到链表头，将原有节点(e)作为下一个节点 table[bucketIndex] = new Entry<>(hash, key, value, e); size++; //HashMap 元素数量 +1 } \",\"根据上方源码总结下步骤：\",\"判断key是否为null，为null则直接存放到数组下标为 0 的位置；\",\"计算key的 hash 值并通过该值确定数组下标位置；\",\"判断key是否重复，重复则覆盖并返回旧值；\",\"在addEntry()方法判断是否需要扩容，最后将key-value封装为Entry<K,V>对象保存。\"]},\"9\":{\"h\":\"get 方法实现\",\"t\":[\"理解了put()方法后，get()方法就简单多了，直接上源码：\",\"public V get(Object key) { if (key == null) return getForNullKey(); //1.判断 key 是否 Null，为空直接获取数组下标为 0 的元素 Entry<K,V> entry = getEntry(key); return null == entry ? null : entry.getValue(); //三目表达式判断 } final Entry<K,V> getEntry(Object key) { int hash = (key == null) ? 0 : hash(key); //计算 key 的 hash 值 //2.indexFor() 计算数组下标并循环遍历该下标处的链表节点 for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null;e = e.next) { Object k; //3.判断是否 hash 值和 key 值是否相同且不为 null，不匹配则循环判断下一节点 if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } return null; } \",\"步骤如下：\",\"判断key是否 null，为 null 直接取数组下标为 0 的元素；\",\"在getEntry()方法里计算key的hash值找到下标然后循环遍历判断key的值，存在返回值，不存在则返回null。\"]},\"10\":{\"h\":\"resize/transfer 方法实现\",\"t\":[\"这两个方法主要是数组扩容和数据复制，在 HashMap 中，这个过程称为 rehashing。源码如下：\",\"void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; //1.获取旧数组长度 //MAXIMUM_CAPACITY 的值为 1<<30，是 Integer.MAX_VALUE 的一半减1，已经大的夸张，基本不存在扩容情况 //所以重新设置阈值后直接返回 if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } //2.创建一个新的数组，大小为原来的2倍 Entry[] newTable = new Entry[newCapacity]; //3.获取是否需要重新计算 hash boolean oldAltHashing = useAltHashing; useAltHashing |= sun.misc.VM.isBooted() && (newCapacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean rehash = oldAltHashing ^ useAltHashing; //4.扩容的关键方法，旧数组数据复制到新数组 transfer(newTable, rehash); table = newTable; //5.重新计算阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); } void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; //遍历旧数组 for (Entry<K,V> e : table) { //遍历当前节点的链表 while(null != e) { Entry<K,V> next = e.next; //判断是否需要重新计算 hash if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); //计算数组下标 e.next = newTable[i]; //头插法，链表头部插入，已有的节点往后移作为 next 节点 newTable[i] = e; //头部插入 e = next; } } } \",\"过程理解起来也不难：\",\"创建大小为原来 2 倍的新数组；\",\"在transfer()方法将旧数组数据循环遍历复制到新数组（关键）；\",\"将新数组赋值给 HashMap 的table变量，并重新计算阈值。\",\"理解清楚 HashMap 的设值、取值、扩容复制原理后，基本上其它方法实现都可以很容易理解了，这里就不多赘述。\"]},\"11\":{\"h\":\"补充\"},\"12\":{\"h\":\"与 Hashtable 的区别\",\"t\":[\"HashMap\",\"key 允许为 Null（唯一）\",\"线程不安全\",\"效率较高\",\"继承于 AbstractMap<K,V>\",\"Hashtable\",\"key 不为空\",\"线程安全\",\"效率较低\",\"继承于 Dictionary<K,V>\",\"Hashtable 的key不能为空，是因为put()方法里作了判断，为空直接抛出 NPE 异常；而它之所以是线程安全，通过源码可知是因为内部方法都加上了 Synchronize同步锁，但Synchronize是重量级锁，容易引起线程上下文切换而带来线程调度的开销，因此在多线程并发应用中使用是比较少的，推荐使用 ConcurrentHashMap，其采用的是分段锁，效率比 Hashtable 要高出许多。\"]},\"13\":{\"h\":\"HashMap 死链问题\",\"t\":[\"HashMap 死链是指在 Java 并发情况下，多线程操作 HashMap 产生 Race Condition(竞用条件)，而此时 HashMap 刚好需要扩容，导致旧数据复制到新数组产生死循环。简单讲就是链表中 A(Entry) 的 next 属性指向 B(Entry)，而 B 的 next 属性又指向 A。\",\"关于死链具体情况，在左耳朵耗子-陈皓的《疫苗：Java HashMap的死循环》这篇里讲解的非常清楚，很清晰易懂。并且死链情况在 Java 8 中已经得到解决，在 Java 8 版本开始，HashMap 的结构就变为了 数组+链表+红黑树，后续新篇章也会对 Java 8 的 HashMap 作下介绍讲解。\"]},\"14\":{\"h\":\"总结\",\"t\":[\"最后来概括下 HashMap 的工作原理：当通过put()方法存值时会调用key.hashCode()计算哈希值从而获取数组下标，并将Key-Value作为 Entry<K,V> 对象进行存储，调用get()方法时同样计算key的哈希值然后获取数组下标，然后通过 key.equals()判断值是否相同，最终返回结果。当存值时若元素数量大于阈值threshold则进行扩容，大小为原来的2倍。\",\"Java 8 前的 HashMap 原理并不复杂，至于其它的一些细枝末节，在理解了上面的内容后，自己去查看源码学习，就会很轻松了。\"]},\"15\":{\"c\":[\"Java\"]},\"16\":{\"c\":[\"Java\",\"HashMap\",\"集合\"]},\"17\":{\"h\":\"Java 8 中 HashMap 的改变\"},\"18\":{\"h\":\"前言\",\"t\":[\"在聊聊 HashMap 篇中，通过 JDK1.7 的 HashMap 的几个方法：put()、get()、resize()/transfer()讲解了其原理，在最后简单描述了 HashMap 死链问题。引出了在 Java 8 中，HashMap 底层结构变化为 数组+链表+红黑树，提高了查询效率，并解决了死链问题。我们就以此作为切入点，来看看 HashMap 在 Java 8 版本有了哪些变化。\"]},\"19\":{\"h\":\"死链原因和解决方法\",\"t\":[\"Java 8 之前的 HashMap 并发扩容出现死链，原因之一是链表节点的存储方式引起，即 头插法。每当添加新元素时，都是放在链表头节点，原头节点就变成新节点的 next 节点。这就导致了并发扩容时，若链表元素 rehash 后依旧在同一个数组下标位置，则链表元素会出现逆序（或翻转），即 A-B-C 变成 C-B-A。另一个是因为复制数据是在 while 循环里遍历一个节点就插入到新的数组位置，假设有两个线程，线程一获取到 A 节点以及下一节点 B 后就被阻塞，而线程二直接完成了扩容操作，链表变成 C-B-A，当线程一恢复运行后，B 的下一节点又变成 A，死链就出现了。\",\"再次贴上复制数据的方法源码，方便大家回顾：\",\"// JDK 7 源码 void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry<K,V> e : table) { while(null != e) { Entry<K,V> next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } } } \",\"而在 Java 8 中则更改为 尾插法，即添加的新元素会放在链表尾节点，这样在扩容时就不会出现元素逆序的情况，并且在扩容方法的 while 循环复制数据中，是将索引下标处的链表节点全部遍历获取后，再存入到新数组中，这样就避免了死链问题。关于其逻辑实现在下面会讲到，可以先看下图简单对比头插法和尾插法：\",\"HashMap 7/8 链表结构\"]},\"20\":{\"h\":\"结构变化\",\"t\":[\"Java 8 中，HashMap 底层结构变为 数组+链表+红黑树，显著提高了查询效率。在 HashMap 中，获取元素可以简单分为以下两步：\",\"根据key.hashCode()获取 hash 值，然后确定数组下标 index；\",\"若数组下标位置节点key不匹配，则遍历链表，通过key.equals()查找。\",\"在 Java 8 之前只是用链表解决冲突问题，在发生碰撞问题时，这两步获取元素的时间复杂度为 O(1)+O(n)。因此，当碰撞频率高时 n 变大，查询速度就会受到影响。在 Java 8 中则利用红黑树替代链表，而红黑树是一种自平衡的二叉查找树，如此一来，获取元素的时间复杂度就变为 O(1)+O(log n)，在 n 变大时，能够理想地解决查询效率变低的问题。\"]},\"21\":{\"h\":\"链表与红黑树转换时机\",\"t\":[\"当发生哈希碰撞时，首先用链表存储，当链表节点数量大于等于 8 时，就会转换为红黑树，而一旦节点数量小于等于 6，红黑树又会转换为链表。当节点数量达到 8 时，红黑树的平均查找时间为 3(log 8)，而链表则为 4(8/2)，这才有了转换的必要。而选择 6 和 8，中间存在差值 7，是假设当链表长度大于小于 8 时，红黑树和链表就互相转换，若 HashMap 存储的元素数量在 8 徘徊，频繁增删，红黑树和链表就会频繁转换，效率将会降低。\",\"static final int TREEIFY_THRESHOLD = 8; //HashMap 默认的转换为红黑树的节点阈值 static final int UNTREEIFY_THRESHOLD = 6; // 默认的转换为链表的节点阈值 \"]},\"22\":{\"h\":\"原理解析\"},\"23\":{\"h\":\"Node<K,V> 和 TreeNode<K,V>\",\"t\":[\"在 Java 8 之前，key-value是用Entry<K,V>对象保存，Java 8 中则变为Node<K,V>，但其内部方法实现基本相同，依旧实现Map.Entry<K,V>接口，下面是源码：\",\"static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; V value; Node<K,V> next; Node(int hash, K key, V value, Node<K,V> next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } // ...其它代码省略... } \",\"重要的是内部静态类增加了TreeNode<K,V>，该类也就是红黑树节点对象，在下面源码中，TreeNode<K,V>类是继承LinkedHashMap.Entry<K,V>类，而进入该类，可以看到其实也是继承HashMap.Node<K,V>类，并含有before、after两个属性，但TreeNode<K,V>本身并没有直接使用到这两个属性，只是维护了双向链表的应用，便于在红黑树和链表之间进行转换：\",\"static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> { TreeNode<K,V> parent; // 红黑树根节点 TreeNode<K,V> left; // 左节点 TreeNode<K,V> right; // 右节点 TreeNode<K,V> prev; // 当前节点的前一节点 boolean red; // 是否为红色节点 TreeNode(int hash, K key, V val, Node<K,V> next) { super(hash, key, val, next); // 调用父类的构造方法 } // ...其它代码省略... } // LinkedHashMap.Entry<K,V> 的实现 static class Entry<K,V> extends HashMap.Node<K,V> { Entry<K,V> before, after; Entry(int hash, K key, V value, Node<K,V> next) { super(hash, key, value, next); // 调用父类 HashMap.Node<K,V> 的构造方法 } } \"]},\"24\":{\"h\":\"put 方法\",\"t\":[\"依旧是从put()方法开始，直接上源码：\",\"public V put(K key, V value) { // 1、获取 key 的 Hash 值 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; // 2、判断 table 是否为空，为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 3、计算数组下标，判断该位置是否为空，为空直接添加 if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node<K,V> e; K k; // 4、判断 hash 值和 key 是否相同，相同赋值给 e if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 5、若为树节点，执行 putTreeVal() 添加 else if (p instanceof TreeNode) e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { // 6、遍历链表，尾插法 for (int binCount = 0; ; ++binCount) { // 6.1、next 节点为空直接添加 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 6.2、当链表节点数量 >= 8 则转换为红黑树 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 6.3、next 节点不为空，则判断是否与当前遍历节点相同 if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } // 7、e 不为空则进行覆盖并返回旧值 if (e != null) { // existing mapping for key V oldValue = e.value; // 7.1、onlyIfAbsent 表示是否覆盖已存在的值 // put()默认传递 false 覆盖， putIfAbsent()传递 true 不覆盖 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size > threshold) // 8、判断是否超过阈值，超过则扩容 resize(); afterNodeInsertion(evict); return null; } \",\"总结下步骤：\",\"获取key的 hash 值，然后进入putVal()方法，若 table 为空则先创建；\",\"计算数组下标，判断下标处元素，若为空直接新增，不为空先判断key.equals(k)；\",\"不同说明发生碰撞，判断是否为树节点，是则调用putTreeVal()新增树节点；\",\"若是链表节点，则遍历到链表尾部判断，当节点不存在则新增（尾插法）；\",\"如果链表长度大于等于TREEIFY_THRESHOLD，就将链表转换为红黑树；\",\"若节点已经存在,则替换旧值oldValue并返回；\",\"最后判断容量若大于阈值，就进行扩容resize()。\"]},\"25\":{\"h\":\"get 方法\",\"t\":[\"public V get(Object key) { Node<K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node<K,V> getNode(int hash, Object key) { Node<K,V>[] tab; Node<K,V> first, e; int n; K k; // 1、获取数组下标位置第一个节点，命中则直接返回 if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; // 2、若为树节点则调用 getTreeNode() 去获取 if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K,V>)first).getTreeNode(hash, key); // 4、若为链表则遍历判断 do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"获取元素的逻辑还是比较简单，步骤如下：\",\"计算key的 hash 值找到数组下标，若下标处第一个节点匹配则返回；\",\"若有冲突，判断是树节点还是链表节点，然后通过key.equals(k)查找匹配的节点。\"]},\"26\":{\"h\":\"Hash 方法\",\"t\":[\"在新增和获取过程中，计算下标时，先对 key 的哈希值进行 hash 操作，再进一步计算下标，如下图所示：\",\"Hash 计算\",\"对key.hashCode()的 hash 操作实现如下：\",\"static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } // 计算下标方式：(n-1) & hash \",\"在 Java 8 之前原本是直接 & 运算获取下标，但一般情况下 HashMap 长度都小于 2^16，这就导致 & 运算的一直是哈希值的低 16 位甚至更低，假设长度为 16，则下标运算的结果取决于哈希值的低 4 位（即长度为 2 的 n 次方，位运算结果取决于低 n 位）。为了让哈希值的低 16 位更随机，便让哈希值与高 16 位（h >>> 16）进行异或运算，以让低 16 位更随机散列，减少碰撞。\"]},\"27\":{\"h\":\"resize 方法\",\"t\":[\"在resize()方法上有这么一段注释：\",\"Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.\",\"其意思大概就是初始化或增加数组大小，如果数组本就为空，则按默认值进行初始化，否则，因为使用的是 2 次幂扩展（即原来大小的 2 倍），元素存放在新数组要么是原位置，要么是原位置加上 2 次幂。搭配一张图来看就会很好理解：\",\"扩容计算\",\"因为扩容为n << 1，即 2 倍，所以 n-1 就是在高位多 1 bit（红色），若多出的高位 bit 经过 & 运算为 1，则元素 index 变为 原索引+原数组容量(即 2 次幂)，为 0 则不需要变化。因此扩容时不需要重新计算 hash 值，只需要在 原 hash 值跟原数组长度 & 运算 后判断是否等于 0 来确定是否需要移动即可。举个例子，假设数组长度原本是 16，n(16) -1 = 0000 1111，n(16) = 0001 0000，因为扩容后 n(32)-1 = 0001 1111，高位多 1 bit ，所以直接同 16 进行 & 运算效果相当于只跟高位 bit 进行位运算，如下图：\",\"高位 & 运算\",\"来看下resize()方法的源码，在 6.3 处就体现了上面说的元素是否需要移动的判断：\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 1、若是超过最大值，则不扩容，任由其碰撞了 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 2、不超过最大值则扩容为原来的 2 倍 else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } // 3、若无数据，则用初始化阈值赋值 else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; // 4、若无数据并且阈值为 0，则使用默认值设置 else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 5、若新数组未设置阈值，则进入此处计算新的 threshold if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) { // 6、遍历旧数组复制数据 for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; // 6.1、若当前节点没有冲突，则计算新的数组下标直接存值 if (e.next == null) newTab[e.hash & (newCap - 1)] = e; // 6.2、若为树节点，则调用 TreeNode.split() else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // preserve order // 6.3、以下部分是遍历链表节点进行复制，并判断节点在新数组的位置 // loHead：不需要改变位置的链表头节点，hiHead：需要改变位置的链表头节点 // loTail 和 hiTail 则是对应链表尾节点 Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; // 6.3.1、为 0 说明原索引位置存值 if ((e.hash & oldCap) == 0) { if (loTail == null) // 6.3.2、尾节点为空，则链表为空，头节点指向当前遍历节点 e(仅第一次) loHead = e; else // 6.3.3、尾节点不为空，则链表存在，将尾节点指向当前遍历节点 e loTail.next = e; // 6.3.4、将尾节点指向当前遍历节点 e loTail = e; } // 6.3.5、不为 0 说明新位置是原索引 + oldCap(旧容量) else { // 与上面同理 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 6.3.6、判断两个尾节点，不为空说明链表存在，将头节点保存在相应位置 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } \",\"扩容方法实现逻辑重点在于复制数据的 for 循环中，简单分为以下几步：\",\"若当前遍历的节点元素位置没有冲突，则直接计算新的数组下标存值；\",\"若为树节点，调用TreeNode.split()方法进行具体操作；\",\"若为链表节点则进行遍历，通过元素原 hash 值与旧数组长度 & 运算判断位置是否需要移动，采用两个头节点和两个尾节点保存元素构成链表，再将链表头节点存放到新数组的相应位置。\"]},\"28\":{\"h\":\"关于红黑树\",\"t\":[\"在上面内容中，基本侧重于 HashMap 整体的实现逻辑描述，而红黑树相关的内容，如新增树节点、链表红黑树互转等则讲解不多。主要是因为红黑树结构、以及树节点平衡被打破后的处理情况等内容比较复杂，讲解起来会很啰嗦冗余，而且对不了解红黑树的读者会很不友好。此处附上文章：程序员小灰 - 什么是红黑树，供感兴趣的读者学习下红黑树的相关知识（已会可忽略），结合上面对于 HashMap 的原理解析，再去查看关于红黑树操作的源码，理解起来就会比较轻松了 (●ˇ∀ˇ●) 。\"]},\"29\":{\"h\":\"尾声\",\"t\":[\"Java 8 HashMap 原理宏观上跟以前的思路差不多，主要是在新增、获取、删除元素和扩容等方法增加了对红黑树节点的判断，重要的变化可以简单归纳为：底层结构新增红黑树、链表存储方式变为尾插法，hash() 方法优化。而这些改变对 HashMap 性能提升影响是比较大的，在Java 8 中 HashMap 的性能提升一文中含有性能测试的结果。\",\"在实际开发中，HashMap 使用是非常频繁的，掌握原理，有助于我们在使用时，若遇到异常 Bug，可以快速定位、解决问题，并且 HashMap 也是面试经典问题了。\"]},\"30\":{\"c\":[\"Java\"]},\"31\":{\"c\":[\"Java\",\"HashMap\",\"集合\"]},\"32\":{\"h\":\"JVM 类加载机制\",\"t\":[\"在 JVM-内存模型 篇已经详细讲解了 JVM 内存模型的结构，如果想先了解 JVM 的内存模型，可以戳一下链接先去看看哦。这一篇，我将着重描述 Java 类加载机制，在 JVM 中类的加载到底经历了哪些过程。\"]},\"33\":{\"h\":\"什么是类的加载\",\"t\":[\"类的加载指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在 JVM 运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终结果是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并提供了访问方法区内的数据结构的接口。\",\"我们可以简单看张图理解下：\",\"类加载\",\"从图片我们知道，类加载完毕后，类的数据全部都存放在 JVM 的方法区，堆区只是提供了一个入口去调用相应的对象数据，比如Class.newInstance()，所以到这里，我们也能理解为什么 Java 对象都存放在堆区的原因。\",\"类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError 错误），如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。（此段引用于 纯洁的微笑-Java 类加载机制）\"]},\"34\":{\"h\":\"类的加载过程\",\"t\":[\"如下图所示，JVM 类加载主要经历五个部分：加载、连接、初始化、使用、卸载。接下来一一讲解每个部分都做了什么。\",\"类加载过程\"]},\"35\":{\"h\":\"加载\",\"t\":[\"加载是类加载过程的第一个阶段，主要是查找并加载类的二进制数据，而这一阶段也就会在堆区生成一个 java.lang.Class 对象，作为入口用于访问该对象在方法区里的数据结构。而且这一步也是可控的，我们可以使用默认的类加载器，也可以自定义类加载器对 Java 文件进行加载（关于 类加载器 👈下面有做简单介绍）。\"]},\"36\":{\"h\":\"连接\",\"t\":[\"连接细化分下来，其实有三步，分别为以下三个部分：\"]},\"37\":{\"h\":\"验证：确保被加载的类的正确性\",\"t\":[\"这是连接的第一步，判断当前 Class 文件的字节流信息是否符合当前 JVM 规范要求，大致会进行以下四个部分的验证：\",\"文件格式验证：验证字节流是否符合 Class 文件格式的规范\",\"元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求\",\"字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的\",\"符号引用验证：确保”解析”动作能正确执行\"]},\"38\":{\"h\":\"准备：为类的静态变量分配内存，并将其初始化为默认值\",\"t\":[\"这一步主要是在方法区中为类变量分配内存，并初始化类变量的值。\",\"比如声明如下，value的值在准备阶段会被初始化为 0，而不是 80，即数据类型的默认初始值，实际值的初始化会在 初始化 阶段（下面会讲到）：\",\"public static int value = 80; \",\"但如果是下面的声明方式，则会直接赋值为 8080，在编译阶段会为 value 生成 ConstantValue 属性，并在准备阶段赋值为 8080：\",\"public static final int value = 8080; \"]},\"39\":{\"h\":\"解析：把常量池内的符号引用转换为直接引用\",\"t\":[\"主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用，符号引用类型常见如下：\",\"CONSTANT_Class_info\",\"CONSTANT_Field_info\",\"CONSTANT_Method_info\",\"符号引用：一组符号来描述目标，可以是任何字面量，它与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。\",\"直接引用：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，当有了直接引用，就说明引用的目标在内存已经存在。\"]},\"40\":{\"h\":\"初始化\",\"t\":[\"为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化，Java 中为类变量进行初始值设定有两种方式：(1) 声明类变量时指定值；(2) 在静态代码块赋值。\",\"初始化的步骤如下：\",\"假如这个类还没有被加载和连接，则程序先加载并连接该类\",\"假如该类的直接父类还没有被初始化，则先初始化其直接父类\",\"假如类中有初始化语句，则系统依次执行这些初始化语句\",\"类初始化其实是执行类构造器方法的过程，编译器会自动收集类中的类变量赋值操作和静态代码块的语句合并而成，并且 JVM 会保证子构造器方法执行前，父类构造器已经执行完毕。如果一个类中既没有类变量也没有静态代码块，那么编译器可以不为这个类生成构造器方法。\",\"而初始化只有在对类的主动使用时才会触发，触发方式大概有以下几种：\",\"创建类的实例，也就是 new 的方式\",\"访问某个类或接口的静态变量，或者对该静态变量赋值\",\"调用类的静态方法反射（如Class.forName(\\\"com.Test\\\")）\",\"初始化某个类的子类，则其父类也会被初始化\",\"Java 虚拟机启动时被标明为启动类的类，直接使用 java.exe 命令来运行某个主类\",\"不会触发类初始化的情况如下：\",\"通过子类引用父类的静态字段，只会触发父类的初始化，而子类不会初始化\",\"定义数组对象，不会触发该类的初始化\",\"常量在编译期间会存入调用类的常量池，但本质上并没有直接引用定义常量的类，所以也不会触发初始化\",\"通过类名获取 Class 对象（Test.Class），不会触发\",\"通过Class.forName()加载指定类时，如果指定参数initialize为 false ，不会触发类初 始化，因为该参数是告诉虚拟机是否要对类进行初始化\"]},\"41\":{\"h\":\"类加载器\",\"t\":[\"类加载经过 初始化 这一步后，就已经可以正常使用，这个过程走下来，其实在最初的 加载 这一步开发者可以控制外，其它都是由 JVM 自行完成。而控制加载过程，则需要使用到类加载器。\",\"我们先简单了解下 JVM 提供的三种类加载器，如下图所示：\",\"类加载器\",\"启动类加载器(Bootstrap ClassLoader) ：负责加载 JAVA_HOME\\\\lib 目录中的，或通过 -Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。\",\"扩展类加载器(Extension ClassLoader) ：负责加载 JAVA_HOME\\\\lib\\\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。\",\"应用程序类加载器(Application ClassLoader）：负责加载用户路径（classpath）上的类库。\"]},\"42\":{\"h\":\"双亲委派模型\",\"t\":[\"在上面类加器图中我们可以看到，当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。这样子的好处是保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。\",\"而类加载器存在以下机制：\",\"全盘负责：当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。\",\"父类委托：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。\",\"缓存机制：缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效。\"]},\"43\":{\"h\":\"自定义类加载器\",\"t\":[\"当然，如果有需要，我们也可以自定义类加载器，只要 继承 ClassLoader 并重写其 loadClass() 方法，然后编写加载的具体逻辑代码即可。但这里有个要注意的点，如果直接重写 loadClass() 方法，有可能会破坏原本的双亲委派模型哦，具体如何避免该问题，就得查看浏览下 loadClass() 方法的源码了。而自定义实现类加载器的有 Tomcat、Java 代码生成器之类的案例，有兴趣的读者也可了解下。\"]},\"44\":{\"h\":\"总结\",\"t\":[\"本篇主要讲解 JVM 类加载机制，意在让读者明白 Java 文件编写后 JVM 是如何处理并正确使用，并理解类加载器的执行机制。当然本篇并不算全面细致的讲解，也有忽略的细节，如 连接-验证 步骤若是反复验证影响了加载效率该如何做，启动类加载器无法被 Java 程序直接引用等问题。\",\"但事无巨细，很多问题都是在某些情况下触发，都是要读者们在实际应用中去注意、发现并解决这些问题，久而久之，不仅问题解决了，还能更深入的理解其核心原理。\"]},\"45\":{\"h\":\"参考资料\",\"t\":[\"《深入理解Java虚拟机》第7章 / 周志明 / 机械工业出版社\"]},\"46\":{\"c\":[\"Java\"]},\"47\":{\"c\":[\"Java\",\"JVM\"]},\"48\":{\"h\":\"JVM 内存模型\"},\"49\":{\"h\":\"什么是 JVM\"},\"50\":{\"h\":\"概念\",\"t\":[\"JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，是一种用于计算设备的规范、能够运行 Java 字节码的虚拟机，拥有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。\",\"引入 Java 虚拟机后，Java 语言开发的程序在不同平台上运行时不需要重新编译。JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 JVM 上运行的字节码（.class），就可以在多种平台上不加修改地运行。对于 JVM，除了 Oracle，也有其它的开源或闭源实现。（摘自维基百科）\"]},\"51\":{\"h\":\"理解\",\"t\":[\"Java 是一门可跨平台的语言，但其本身并不能跨平台，而是通过 JVM 来实现。是通过 JVM 将编译好的文件解释成平台系统（Mac、Linux、Windows 等）可执行的机器码，然后系统加以运行，实现 “一次编译，到处运行” 的效果。\",\"学习 JVM，可以围绕四个部分进行：\",\"类的加载机制\",\"内存模型\",\"GC 算法、垃圾回收\",\"GC 分析、命令调优\",\"本篇着重于 JVM 内存模型的讲解，作为 Java 开发人员，平常或多或少会有这样的疑问，堆内存空间应当设置多大？OOM（OutOfMemoryError）异常到底涉及了运行时数据内存哪块区域？JVM 内存调优从哪里入手？\",\"在理解了 JVM 内存模型后，我们就可以知道，平常编写的 Java 文件信息是如何被 JVM 管理、存放，Java 方法执行时生成的变量、返回结果等 JVM 又是如何操作，堆内存大小如何设置等等。\"]},\"52\":{\"h\":\"JVM 内存模型\",\"t\":[\"Java 程序的开发，并不需要像 C/C++ 开发一样时刻关注内存的释放，而是全权交由 JVM 去管理，JVM 内存模型主要是指运行时内存模型，分为 线程私有 和 线程共享 数据区两大类：\",\"线程私有：程序计数器、虚拟机栈、本地方法栈；\",\"线程共享：Java 堆（Heap）、方法区（包含运行时常量池）。\",\"线程私有数据区域生命周期与线程相同，依赖用户线程的启动（结束）而创建（销毁）；线程共享数据区域则随虚拟机的启动（关闭）而创建（销毁）。\",\"JVM 内存模型结构图（绿色共享，橙色私有）：\",\"内存模型\"]},\"53\":{\"h\":\"程序计数器（私有）\",\"t\":[\"程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器，每个线程都有一个独立的计数器，互不影响。通过该计数器，JVM 解释器就知道下一步要执行的字节码指令位置，而分支、循环、跳转、异常处理、线程恢复等基础功能也都依赖于该计数器来实现。\",\"如果线程正在执行的是一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，若为 Native 方法，则计数器的值为空（Undefined），并且该内存区域是唯一一个在虚拟机中没有规定任何 OOM 异常情况的区域。\"]},\"54\":{\"h\":\"虚拟机栈（私有）\",\"t\":[\"是描述 Java 方法执行的内存模型，每个方法（不含 Native）在执行时都会创建一个栈帧，方法执行过程，就对应着虚拟机栈的入栈到出栈的过程。（现在明白平常用 IDE 调试时点击 Drop Frame 是回退到方法执行前的原因了吧 (●’◡’●)）\"]},\"55\":{\"h\":\"栈帧（Stack Frame）结构\",\"t\":[\"局部变量表\",\"操作栈\",\"动态链接\",\"方法返回地址\",\"额外附加信息\",\"栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。\"]},\"56\":{\"h\":\"异常（Exception）\",\"t\":[\"JVM 规范规定该区域有两种异常：\",\"StackOverFlowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出；\",\"OutOfMemoryError：当 JVM 动态扩展到无法申请足够内存时抛出。\"]},\"57\":{\"h\":\"本地方法栈（私有）\",\"t\":[\"本地方法栈的作用其实与虚拟机栈类似，区别只在于 本地方法栈是为 Native 方法 服务，而虚拟机栈是为 Java 方法 服务。虚拟机规范中对本地方法栈中的方法使用的语言、方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。有的虚拟机实现也将本地方法栈和虚拟机栈合并，如 HotSpot 虚拟机。\",\"对于异常抛出规范，也与虚拟机栈相同，分别是 StackOverFlowError 和 OutOfMemoryError。\"]},\"58\":{\"h\":\"堆（共享）\",\"t\":[\"Java 堆（Heap）是 JVM 管理的最大的一块内存，也是 GC（Garbage Collection，垃圾收集）的重点照顾对象，存放的是几乎所有的对象实例和数组数据。（JIT 编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在 Java 堆，而是栈内存）\",\"由于主流 JVM 实现对于 GC 采用分代收集算法，因此从 GC 角度来看，Java 堆可分为：\",\"新生代（Eden 区、From Servivor 区、To Servivor 区）\",\"老年代\",\"可以简单的理解新生代主要是存放新创建的对象，而老年代则是存放生命周期或存活时间较长的对象。并且 JVM 在新生代的 Eden 区开辟了一小块内存区域，即 分配缓冲区（TLAB - Thread-local allocation buffer，线程私有），因为 Java 程序中很多对象都是小对象且用过即丢，不存在线程共享和适合被快速 GC ，所以小对象通常会被 JVM 优先分配在 TLAB 上，好处是分配内存效率高。\"]},\"59\":{\"h\":\"异常（Exception）\",\"t\":[\"JVM 规范规定该区域可抛出异常： OutOfMemoryError，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时抛出。\"]},\"60\":{\"h\":\"方法区（共享）\",\"t\":[\"方法区主要存放的是虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等，而 GC 在此区域出现频率较低，主要针对的是常量池的回收和类型的卸载，GC 不会在主程序运行期对方法区进行清理，所以容易随着加载的 Class 增多导致类膨胀，从而引发 OutOfMemoryError 异常。\",\"方法区也常被称为**“永久代（Permanent Generation）”**，这是因为 **HotSpot 虚拟机（Sun JDK 和 Open JDK 自带的虚拟机实现）**的设计团队选择把 GC 分代收集扩展至方法区（也可以理解为是用永久代方法实现了方法区），从而在 GC 方面与 Java 堆保持一致。\",\"在 Java 8 后，永久代则被替换为**“元空间（Metaspace）”**，当然了，后者依然是基于 HotSpot 虚拟机，两者区别主要在于：元空间并不在虚拟机中，而是使用本地内存。因此元空间的大小仅受本地内存限制，基本不存在 OOM 异常问题。并且类的元数据放入本地内存，字符串池和静态变量等则放入到 Java 堆中。\"]},\"61\":{\"h\":\"运行时常量池\",\"t\":[\"作为方法区的一部分，用于存放编译期生产的各种字面量和符号引用，运行时常量池除了编译期产生的 Class 文件的常量池，还可以在运行期间，将新的常量加入常量池，比如 String 类的 intern() 方法。该区域不会抛出 OutOfMemoryError 异常。\",\"字面量：与 Java 语言层面的常量概念相近，包含文本字符串、声明为 final 的常量值等；\",\"符号引用：编译语言层面的概念，包括以下三类： \",\"类和接口的全限定名；\",\"字段的名称和描述符；\",\"方法的名称和描述符。\"]},\"62\":{\"h\":\"补充\",\"t\":[\"关于堆、栈内存的大小设置，可以通过 IDE（IDEA、Eclipse）或 Web 容器（Tomcat ）等来配置，可通过下图来了解参数所控制的区域分别是什么。\",\"堆栈设置\",\"参数控制：\",\"-Xms：设置堆的最小空间大小；\",\"-Xmx：设置堆的最大空间大小；\",\"-XX:NewSize：设置新生代最小空间大小；\",\"-XX:MaxNewSize：设置新生代最大空间大小；\",\"-XX:PermSize：设置永久代最小空间大小；（JDK 8 后无效）\",\"-XX:MaxPermSize：设置永久代最大空间大小；（JDK 8 后无效）\",\"-XX:MetaspaceSize：设置元空间最小空间大小；（JDK 8 后有效）\",\"-XX:MaxMetaspaceSize：设置元空间最大空间大小；（JDK 8 后有效）\",\"-Xss：设置每个线程的堆栈大小。\"]},\"63\":{\"h\":\"总结\",\"t\":[\"本篇主要说明 JVM 内存结构及其概念，意在让大伙了解 JVM 结构是个什么样子，而了解 JVM 是如何管理内存、如何处理 Java 程序运行所产生的数据，可以启发我们在内存管理、性能分析和调优方面的思维。作为 Java 开发者，想要强化个人的技术，扩展自己的思维，JVM 是一道必须攻破的关卡。\"]},\"64\":{\"h\":\"参考资料\",\"t\":[\"《深入理解Java虚拟机》第2章 / 周志明 / 机械工业出版社\",\"《Java虚拟机规范》/ 作者:Tim Lindholm、Frank Yellin 等 / 译者:爱飞翔、周志明等 / 机械工业出版社\",\"技术博客：Java 虚拟机：JVM 内存模型，作者：方志朋\"]},\"65\":{\"h\":\"花絮\",\"t\":[\"本篇是我第一次编写的博客文章，之所以以 JVM 知识为开头，也是因为对于 JVM 的内容一直都是仅凭记忆，就导致容易遗忘，而且很多知识点都是零零散散，没有连结成知识网，也没有做一些知识记录，加上本人也想通过搭建一个博客网站，来总结自己一路学习的技术和知识，并分享给别人，因此便有了这个开头。\",\"博客的编写，尤其是技术类，要考虑的细节还是挺多，如技术原理、常用实现方式、个人实际使用经验、流行程度、更新迭代等。总的来说，这对于我个人的知识总结能力也大有脾益，对一门新技术，我崇尚的是从不会、到了解掌握、再到能讲解给别人听让别人理解。\",\"路漫漫其修远兮，吾将上下而求索。\"]},\"66\":{\"c\":[\"Java\"]},\"67\":{\"c\":[\"Java\",\"JVM\"]},\"68\":{\"h\":\"Spring 事务同步\"},\"69\":{\"h\":\"前言\",\"t\":[\"事务功能在日常开发中使用并不少，本质上是为了保证一次业务请求处理过程中涉及多次 DB 数据操作时的原子性。而本篇主要讲述的事务功能是实现在事务执行的某个阶段去做某些事，即事务同步。在常规的 Web 应用中，大多是直接使用@Transactional注解方法来完成事务操作，但也有一些特殊情况，需要在事务提交前、提交后等情况下执行某些操作，如资源准备、清理、自定义操作等。\"]},\"70\":{\"h\":\"事务同步接口\",\"t\":[\"事务同步回调接口是TransactionSynchronization，其抽象实现TransactionSynchronizationAdapter源码如下：\",\"public abstract class TransactionSynchronizationAdapter implements TransactionSynchronization, Ordered { // 事务同步回调顺序，当存在多个事务同步且有顺序要去时可指定 @Override public int getOrder() { return Ordered.LOWEST_PRECEDENCE; } // 事务挂起 @Override public void suspend() { } // 事务回复 @Override public void resume() { } // 底层数据会话刷新，需要事务管理器有刷新概念，否则无操作 @Override public void flush() { } // 事务提交前 @Override public void beforeCommit(boolean readOnly) { } // 事务完成前（包括异常回滚） @Override public void beforeCompletion() { } // 事务提交后 @Override public void afterCommit() { } // 事务完成后（包括异常回滚） @Override public void afterCompletion(int status) { } } \",\"从源码可看到事务同步作用就是在事务执行的各个阶段进行方法回调，并可通过Ordered接口控制多个事务同步的执行顺序，在下方事务同步的两种使用方式本质都是利用了该抽象类来实现。 在afterCompletion方法的入参status有三种状态（在TransactionSynchronization接口有定义）：\",\"0：事务完成\",\"1：事务回滚\",\"2：未知错误\"]},\"71\":{\"h\":\"使用方式\"},\"72\":{\"h\":\"基于接口\",\"t\":[\"需要继承TransactionSynchronizationAdapte抽象类，在相应的事务阶段回调方法中实现业务逻辑\",\"在事务方法中通过TransactionSynchronizationManager事务同步管理器注册事务同步\",\"// 创建 public class TxSyncDemo extends TransactionSynchronizationAdapter { private String txName; public TxSyncDemo(String txName) { this.txName = txName; } @Override public void afterCommit() { System.out.println(\\\"事务提交后回调...\\\") } @Override public void afterCompletion(int status) { System.out.println(\\\"事务完成后回调...\\\") System.out.println(\\\"事务名称：\\\" + txName); System.out.println(\\\"事务状态：\\\" + status); } } // 事务接口方法 @RestController public class TxController { @GetMapping(\\\"txDemo\\\") @Transactional(rollbackFor = Exception.class) public void txDemo() { // 模拟 DB 操作：更新和新增 update(); save(); // 注册事务同步对象 TransactionSynchronizationManager.registerSynchronization(new TxSyncDemo(\\\"事务同步测试\\\")); } } \",\"之后调用事务接口，即可看到如下结果：\",\"控制台结果\"]},\"73\":{\"h\":\"基于注解\",\"t\":[\"注解方式需要通过@TransactionalEventListener与ApplicationEvent事件对象两者搭配使用，先看看注解的源码，如下：\",\"@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @EventListener public @interface TransactionalEventListener { // 指定事务阶段 TransactionPhase phase() default TransactionPhase.AFTER_COMMIT; // 不存在事务时，注解的方法是否依然被调用，true 则表示只要事件发布了就回调 boolean fallbackExecution() default false; // ... @AliasFor(annotation = EventListener.class, attribute = \\\"classes\\\") Class[] value() default { }; // 指定感兴趣的事件类名 @AliasFor(annotation = EventListener.class, attribute = \\\"classes\\\") Class[] classes() default { }; // 事务回调的条件，可通过 SpEL 进行编写 String condition() default \\\"\\\"; } \",\"实现步骤：\",\"创建事件对象\",\"使用注解标记方法，并通过注解属性指定回调时的事务阶段和感兴趣的事件\",\"在事务接口方法里，发布相应的事件\",\"// 步骤 1：创建事件类 // 可在这个事件类里注入其它依赖或声明业务逻辑，因此事务同步回调时可获取该事件的信息 public class TxSyncEvent extends ApplicationEvent { public TxSyncEvent(Object source) { super(source); } } // 步骤 2：使用事务注解 @Component public class TxSyncDemo { @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, classes = TxSyncEvent.class) public void afterCommit() { System.out.println(\\\"事务提交后回调...\\\"); } } // 步骤 3：事务方法里发布事件 @RestController public class TxController { @Resource private ApplicationEventPublisher publisher; @GetMapping(\\\"txDemo\\\") @Transactional(rollbackFor = Exception.class) public void txDemo() { // 模拟 DB 操作：更新和新增 update(); save(); // 发布事件 publisher.publishEvent(new TxSyncEvent(\\\"source\\\")); } } \",\"之后调用事务接口，即可看到注解方法内的内容输出，过于简单不再展示结果图片。\"]},\"74\":{\"h\":\"注意事项\"},\"75\":{\"h\":\"注解方式方法入参问题\",\"t\":[\"按@TransactionalEventListener注解classes属性是否有指定值分情况说明：\",\"无值 \",\"方法入参只能为 0 或 1 个（任意类型）\",\"若方法入参为事件类型，则代表是感兴趣的事件，等同于classes指定了该事件\",\"若方法入参为空或不为事件类型，则表示方法不关心任何事件，任何时候都不会被回调\",\"有值 \",\"只有一个值时，入参必须为该值对应的事件类型，否则抛出参数类型错误异常\",\"多个值时，则入参不需要指定\",\"经过实际测试，classes指定多个值时，入参依然可指定为某个事件类型，若事务方法发布的事件刚好与参数的事件类型一致，则可以正确回调。比如classes={A.class, B.class}，方法入参类型为 A，发布 A 事件时可正确执行，而发布 B 事件则会抛出异常。因此还是推荐不设置参数。\"]},\"76\":{\"h\":\"afterCommit / afterCompletion 事务范围问题\",\"t\":[\"这两个方法在 javadoc 上的描述是：在回调时事务资源可能仍然处于活跃状态并可访问。 经过实际测试，在这两个方法中执行 DB 数据操作，那么操作依旧会参与原事务，会等到方法执行完清理事务资源后，才会真正提交到数据库。可通过TransactionSynchronizationManager.isActualTransactionActive()来判断当前方法是否处于活跃事务中。\"]},\"77\":{\"h\":\"实际场景\",\"t\":[\"举个在我司 IM 系统中的例子，如添加好友，该请求处理步骤如下：\",\"数据库 f_req（好友请求） 表添加记录数据，删除目标好友（target）的 f_req 缓存（Redis）\",\"发送通知给 target，让其拉取最新好友请求记录（通过 Netty 异步发送通知）\",\"事务提交，数据真正落库，返回请求处理结果（success / fail）\",\"由于步骤 2 通过 Netty 的 Channel 异步发送通知，因此不受 Spring 事务管理。若只是使用事务注解标记整个处理流程，那么当执行到步骤 2 时，由于事务未提交（DB 数据未更新），当 target 收到通知后重新来查询 f_req，就只会查到旧数据（即缺少最新的请求记录），下图展示过程：假设 A + B 为好友\",\"场景示例\",\"结合上图梳理流程如下：\",\"A 发起好友请求（Request 1），服务端开启事务，DB 新增数据，删除 B 的 f_req 缓存\",\"服务端发送通知给 B，通知 B 来查询最新的 f_req 数据\",\"当服务端接收 B 的查询请求（Request 2）后，先查询缓存，由于缓存被删除，则查询 DB；因为 Request 1 的事务未提交，所以肯定只会查到旧的 f_req 记录，即 A 发送的 f_req 没了\",\"Request 1 的请求处理完成，事务提交，所有数据落库\",\"从 B 的视角来看，虽然被通知要拉取 f_req，但拿到的却都是旧数据，根本就没有 A 发出的 f_req，属实是“虚空好友请求”了。更糟糕的是，由于旧数据的查询，缓存重新被添加回来，导致图中步骤 1 的缓存删了等于没删，出现缓存与 DB 数据不一致情况，并且至少得等到下一次有用户对 B 发起 f_req，才能将本次的 f_req 数据刷新到缓存。\",\"为避免出现这种情况，就需要保证 B 发起查询请求时，A 的添加好友请求已处理完毕，数据已落库；因此便可利用事务同步来控制步骤 2 在事务完成后执行。\",\"（PS：可能读者会有疑惑，添加请求在流程中明明只有一次 DB 操作，为何还要加事务？原因是流程做了简化，添加好友的流程除了处理好友请求记录外，还会判断用户好友历史记录是否添加过目标用户，若有也会去修改 DB 数据。）\"]},\"78\":{\"h\":\"思考题\",\"t\":[\"上方说到事务同步注解方式若classes指定了多个值，方法入参推荐不指定，那么在方法体里如果获取本次事务监听的事件信息呢？\",\"afterCommit/afterCompletion方法回调时若有 DB 数据操作，在事务明明已经提交的情况下，为何还会参与原始事务，并且得等到清理资源时才提交？\",\"（PS：想想再看答案，也可以先带着问题去阅读下源码）\"]},\"79\":{\"h\":\"问题一\",\"t\":[\"第一个问题比较简单，由于事件类都需要继承ApplicationEvent作为父类，因此方法参数指定为ApplicationEvent类型即可，然后通过instanceof或Class.isAssignableForm()判断类型，再搭配上策略模式优雅代码。\",\"@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, classes = {AEvent.class, BEvent.class}) public void afterCommit(ApplicationEvent event) { if (event instanceof AEvent) { // do something... } else if (event instanceof BEvent) { // do something... } // 觉得多重 if 丑陋就使用策略模式 } \"]},\"80\":{\"h\":\"问题二\",\"t\":[\"之所以事务提交还会参与原始事务，是跟 Spring 的事务机制有关，Spring 事务的本质是获取到 DB 的连接（Connection）后修改连接的自动提交autoCommit为false（默认是true），然后由 Spring 自己控制提交的时机，从而实现事务的功能。\",\"既然修改了连接的autoCommit，那么事务执行完后就得将连接恢复到初始状态，即修改autoCommit=true。而偏偏这个操作，是在执行事务回调完成后，清理资源时才会去执行，也就导致了事务回调期间的 DB 操作都没有被提交，最后只能依赖连接的autoCommit恢复后，由连接本身去做提交操作（因为 Spring 不会再有提交操作）。\",\"连接获取后autoCommit的修改源码如下：\",\"@Override protected void doBegin(Object transaction, TransactionDefinition definition) { // 省略其它代码... Connection con = null; // 这里是从连接池获取连接的操作 try { if (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) { // 这一步从数据库连接池里获取连接 Connection newCon = obtainDataSource().getConnection(); if (logger.isDebugEnabled()) { logger.debug(\\\"Acquired Connection [\\\" + newCon + \\\"] for JDBC transaction\\\"); } // 保存连接在 ConnectionHolder 对象中 txObject.setConnectionHolder(new ConnectionHolder(newCon), true); } txObject.getConnectionHolder().setSynchronizedWithTransaction(true); con = txObject.getConnectionHolder().getConnection(); // 隔离级别与只读设置 Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition); txObject.setPreviousIsolationLevel(previousIsolationLevel); txObject.setReadOnly(definition.isReadOnly()); // Switch to manual commit if necessary. This is very expensive in some JDBC drivers, // so we don't want to do it unnecessarily (for example if we've explicitly // configured the connection pool to set it already). // 当连接默认为自动提交时，才设置为手动提交 if (con.getAutoCommit()) { // mustRestoreAutoCommit 这个变量后面恢复连接自动提交时会用到 txObject.setMustRestoreAutoCommit(true); if (logger.isDebugEnabled()) { logger.debug(\\\"Switching JDBC Connection [\\\" + con + \\\"] to manual commit\\\"); } con.setAutoCommit(false); } } catch (Throwable ex) { // 省略... } } \",\"事务完成后连接autoCommit修改源码如下：\",\"@Override protected void doCleanupAfterCompletion(Object transaction) { DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; // Remove the connection holder from the thread, if exposed. // 解绑资源 if (txObject.isNewConnectionHolder()) { TransactionSynchronizationManager.unbindResource(obtainDataSource()); } // 获取连接进行重置 Connection con = txObject.getConnectionHolder().getConnection(); try { // mustRestoreAutoCommit 变量在修改 autoCommit 为 false 时便设置为 true if (txObject.isMustRestoreAutoCommit()) { // 恢复为自动提交，执行完这一步，事务回调中的 DB 操作就会提交 con.setAutoCommit(true); } DataSourceUtils.resetConnectionAfterTransaction( con, txObject.getPreviousIsolationLevel(), txObject.isReadOnly()); } catch (Throwable ex) { logger.debug(\\\"Could not reset JDBC Connection after transaction\\\", ex); } if (txObject.isNewConnectionHolder()) { if (logger.isDebugEnabled()) { logger.debug(\\\"Releasing JDBC Connection [\\\" + con + \\\"] after transaction\\\"); } // 释放连接，将连接回收到数据库连接池 DataSourceUtils.releaseConnection(con, this.dataSource); } txObject.getConnectionHolder().clear(); } \",\"如上即为连接获取后autoCommit的修改操作。\",\"注意其中事务完成后释放连接这一步（DataSourceUtils.releaseConnection），Spring 同样会持有 DB 连接直到事务回调执行完成后清理资源才释放，所以尽量不要在事务回调中执行耗时较久的操作，否则可能导致 DB 连接无意义占用而引发连接池溢出。\"]},\"81\":{\"h\":\"总结\",\"t\":[\"Spring 事务在日常开发中应用不少，对事务的特性和使用需有所理解，避免因使用不当而带来开发问题。并且利用事务同步功能，也可达到缩小事务范围的效果。同时在事务回调中，尽量不要有 DB 操作和执行耗时较长的操作。若有必要，就新开事务执行 DB 操作，若只是代码执行耗时，则善用线程池异步处理。\"]},\"82\":{\"c\":[\"Spring\"]},\"83\":{\"c\":[\"Spring\",\"Transaction\"]},\"84\":{\"h\":\"Java\"},\"85\":{\"h\":\"Posts\"},\"86\":{\"h\":\"Spring\"},\"87\":{\"h\":\"Framework\"}},\"dirtCount\":0,\"index\":[[\"尽量不要有\",{\"1\":{\"81\":1}}],[\"避免因使用不当而带来开发问题\",{\"1\":{\"81\":1}}],[\"同时在事务回调中\",{\"1\":{\"81\":1}}],[\"同时也被用来处理动态链接\",{\"1\":{\"55\":1}}],[\"同样会持有\",{\"1\":{\"80\":1}}],[\"释放连接\",{\"1\":{\"80\":1}}],[\"恢复为自动提交\",{\"1\":{\"80\":1}}],[\"省略\",{\"1\":{\"80\":1}}],[\"省略其它代码\",{\"1\":{\"80\":1}}],[\"隔离级别与只读设置\",{\"1\":{\"80\":1}}],[\"保存连接在\",{\"1\":{\"80\":1}}],[\"由连接本身去做提交操作\",{\"1\":{\"80\":1}}],[\"由于事件类都需要继承applicationevent作为父类\",{\"1\":{\"79\":1}}],[\"由于事务未提交\",{\"1\":{\"77\":1}}],[\"由于旧数据的查询\",{\"1\":{\"77\":1}}],[\"由于缓存被删除\",{\"1\":{\"77\":1}}],[\"由于步骤\",{\"1\":{\"77\":1}}],[\"由于主流\",{\"1\":{\"58\":1}}],[\"既然修改了连接的autocommit\",{\"1\":{\"80\":1}}],[\"问题二\",{\"0\":{\"80\":1}}],[\"问题一\",{\"0\":{\"79\":1}}],[\"丑陋就使用策略模式\",{\"1\":{\"79\":1}}],[\"觉得多重\",{\"1\":{\"79\":1}}],[\"想想再看答案\",{\"1\":{\"78\":1}}],[\"想要强化个人的技术\",{\"1\":{\"63\":1}}],[\"思考题\",{\"0\":{\"78\":1}}],[\"才设置为手动提交\",{\"1\":{\"80\":1}}],[\"才能将本次的\",{\"1\":{\"77\":1}}],[\"才会真正提交到数据库\",{\"1\":{\"76\":1}}],[\"才会尝试执行加载任务\",{\"1\":{\"42\":1}}],[\"出现缓存与\",{\"1\":{\"77\":1}}],[\"导致图中步骤\",{\"1\":{\"77\":1}}],[\"导致旧数据复制到新数组产生死循环\",{\"1\":{\"13\":1}}],[\"了\",{\"1\":{\"77\":1}}],[\"虚空好友请求\",{\"1\":{\"77\":1}}],[\"虚拟机规范中对本地方法栈中的方法使用的语言\",{\"1\":{\"57\":1}}],[\"虚拟机规范的\",{\"1\":{\"39\":1}}],[\"虚拟机栈\",{\"0\":{\"54\":1},\"1\":{\"52\":1}}],[\"虚拟机后\",{\"1\":{\"50\":1}}],[\"虚拟机\",{\"1\":{\"50\":1,\"57\":1,\"60\":2,\"64\":1}}],[\"虚拟机认可\",{\"1\":{\"41\":1}}],[\"虚拟机启动时被标明为启动类的类\",{\"1\":{\"40\":1}}],[\"属实是\",{\"1\":{\"77\":1}}],[\"属性又指向\",{\"1\":{\"13\":1}}],[\"属性指向\",{\"1\":{\"13\":1}}],[\"属性\",{\"0\":{\"5\":1},\"1\":{\"38\":1}}],[\"根本就没有\",{\"1\":{\"77\":1}}],[\"根据key\",{\"1\":{\"20\":1}}],[\"根据上方源码总结下步骤\",{\"1\":{\"8\":1}}],[\"虽然被通知要拉取\",{\"1\":{\"77\":1}}],[\"没了\",{\"1\":{\"77\":1}}],[\"没有连结成知识网\",{\"1\":{\"65\":1}}],[\"通知\",{\"1\":{\"77\":1}}],[\"通过该计数器\",{\"1\":{\"53\":1}}],[\"通过class\",{\"1\":{\"40\":1}}],[\"通过类名获取\",{\"1\":{\"40\":1}}],[\"通过子类引用父类的静态字段\",{\"1\":{\"40\":1}}],[\"通过数据流和控制流分析\",{\"1\":{\"37\":1}}],[\"通过元素原\",{\"1\":{\"27\":1}}],[\"通过源码可知是因为内部方法都加上了\",{\"1\":{\"12\":1}}],[\"通过\",{\"1\":{\"8\":1,\"18\":1,\"77\":2}}],[\"通过key\",{\"1\":{\"20\":1}}],[\"通过key删除元素\",{\"1\":{\"6\":1}}],[\"通过key获取value`\",{\"1\":{\"6\":1}}],[\"通过一张图来简单理解下\",{\"1\":{\"4\":1}}],[\"场景示例\",{\"1\":{\"77\":1}}],[\"下图展示过程\",{\"1\":{\"77\":1}}],[\"下面会讲到\",{\"1\":{\"38\":1}}],[\"下面是源码\",{\"1\":{\"23\":1}}],[\"收到通知后重新来查询\",{\"1\":{\"77\":1}}],[\"异步发送通知\",{\"1\":{\"77\":2}}],[\"异常问题\",{\"1\":{\"60\":1}}],[\"异常情况的区域\",{\"1\":{\"53\":1}}],[\"异常处理\",{\"1\":{\"53\":1}}],[\"异常到底涉及了运行时数据内存哪块区域\",{\"1\":{\"51\":1}}],[\"异常\",{\"0\":{\"56\":1,\"59\":1},\"1\":{\"12\":1,\"60\":1,\"61\":1}}],[\"让其拉取最新好友请求记录\",{\"1\":{\"77\":1}}],[\"让我们来粗浅的聊聊它吧\",{\"1\":{\"2\":1}}],[\"缓存重新被添加回来\",{\"1\":{\"77\":1}}],[\"缓存\",{\"1\":{\"77\":2}}],[\"缓存机制将会保证所有加载过的\",{\"1\":{\"42\":1}}],[\"缓存机制\",{\"1\":{\"42\":1}}],[\"删除\",{\"1\":{\"77\":1}}],[\"删除目标好友\",{\"1\":{\"77\":1}}],[\"删除元素和扩容等方法增加了对红黑树节点的判断\",{\"1\":{\"29\":1}}],[\"表添加记录数据\",{\"1\":{\"77\":1}}],[\"表示是否覆盖已存在的值\",{\"1\":{\"24\":1}}],[\"好友请求\",{\"1\":{\"77\":1}}],[\"好处是分配内存效率高\",{\"1\":{\"58\":1}}],[\"举个在我司\",{\"1\":{\"77\":1}}],[\"举个例子\",{\"1\":{\"27\":1}}],[\"事件则会抛出异常\",{\"1\":{\"75\":1}}],[\"事件时可正确执行\",{\"1\":{\"75\":1}}],[\"事务在日常开发中应用不少\",{\"1\":{\"81\":1}}],[\"事务的本质是获取到\",{\"1\":{\"80\":1}}],[\"事务管理\",{\"1\":{\"77\":1}}],[\"事务范围问题\",{\"0\":{\"76\":1}}],[\"事务方法里发布事件\",{\"1\":{\"73\":1}}],[\"事务接口方法\",{\"1\":{\"72\":1}}],[\"事务状态\",{\"1\":{\"72\":1}}],[\"事务名称\",{\"1\":{\"72\":1}}],[\"事务回调中的\",{\"1\":{\"80\":1}}],[\"事务回调的条件\",{\"1\":{\"73\":1}}],[\"事务回滚\",{\"1\":{\"70\":1}}],[\"事务回复\",{\"1\":{\"70\":1}}],[\"事务完成\",{\"1\":{\"70\":1}}],[\"事务完成后连接autocommit修改源码如下\",{\"1\":{\"80\":1}}],[\"事务完成后回调\",{\"1\":{\"72\":1}}],[\"事务完成后\",{\"1\":{\"70\":1}}],[\"事务完成前\",{\"1\":{\"70\":1}}],[\"事务提交\",{\"1\":{\"77\":2}}],[\"事务提交后回调\",{\"1\":{\"72\":1,\"73\":1}}],[\"事务提交后\",{\"1\":{\"70\":1}}],[\"事务提交前\",{\"1\":{\"70\":1}}],[\"事务挂起\",{\"1\":{\"70\":1}}],[\"事务功能在日常开发中使用并不少\",{\"1\":{\"69\":1}}],[\"事务同步测试\",{\"1\":{\"72\":1}}],[\"事务同步回调顺序\",{\"1\":{\"70\":1}}],[\"事务同步回调接口是transactionsynchronization\",{\"1\":{\"70\":1}}],[\"事务同步接口\",{\"0\":{\"70\":1}}],[\"事务同步\",{\"0\":{\"68\":1}}],[\"入参依然可指定为某个事件类型\",{\"1\":{\"75\":1}}],[\"入参必须为该值对应的事件类型\",{\"1\":{\"75\":1}}],[\"多个值时\",{\"1\":{\"75\":1}}],[\"多线程操作\",{\"1\":{\"13\":1}}],[\"任何时候都不会被回调\",{\"1\":{\"75\":1}}],[\"任意类型\",{\"1\":{\"75\":1}}],[\"任由其碰撞了\",{\"1\":{\"27\":1}}],[\"个\",{\"1\":{\"75\":1}}],[\"个人实际使用经验\",{\"1\":{\"65\":1}}],[\"无值\",{\"1\":{\"75\":1}}],[\"无论方法是正常完成还是异常完成\",{\"1\":{\"55\":1}}],[\"过于简单不再展示结果图片\",{\"1\":{\"73\":1}}],[\"过程理解起来也不难\",{\"1\":{\"10\":1}}],[\"发起查询请求时\",{\"1\":{\"77\":1}}],[\"发起\",{\"1\":{\"77\":1}}],[\"发起好友请求\",{\"1\":{\"77\":1}}],[\"发出的\",{\"1\":{\"77\":1}}],[\"发送的\",{\"1\":{\"77\":1}}],[\"发送通知给\",{\"1\":{\"77\":1}}],[\"发布\",{\"1\":{\"75\":1}}],[\"发布事件\",{\"1\":{\"73\":1}}],[\"发布相应的事件\",{\"1\":{\"73\":1}}],[\"发现并解决这些问题\",{\"1\":{\"44\":1}}],[\"指定感兴趣的事件类名\",{\"1\":{\"73\":1}}],[\"指定事务阶段\",{\"1\":{\"73\":1}}],[\"控制台结果\",{\"1\":{\"72\":1}}],[\"注解方式方法入参问题\",{\"0\":{\"75\":1}}],[\"注解方式需要通过\",{\"1\":{\"73\":1}}],[\"注解的方法是否依然被调用\",{\"1\":{\"73\":1}}],[\"注册事务同步对象\",{\"1\":{\"72\":1}}],[\"注意其中事务完成后释放连接这一步\",{\"1\":{\"80\":1}}],[\"注意事项\",{\"0\":{\"74\":1}}],[\"注意\",{\"1\":{\"2\":1}}],[\"模拟\",{\"1\":{\"72\":1,\"73\":1}}],[\"未知错误\",{\"1\":{\"70\":1}}],[\"底层数据会话刷新\",{\"1\":{\"70\":1}}],[\"底层结构新增红黑树\",{\"1\":{\"29\":1}}],[\"底层结构变为\",{\"1\":{\"20\":1}}],[\"底层结构变化为\",{\"1\":{\"18\":1}}],[\"清理资源时才会去执行\",{\"1\":{\"80\":1}}],[\"清理\",{\"1\":{\"69\":1}}],[\"清空\",{\"1\":{\"6\":1}}],[\"需要继承transactionsynchronizationadapte抽象类\",{\"1\":{\"72\":1}}],[\"需要事务管理器有刷新概念\",{\"1\":{\"70\":1}}],[\"需要在事务提交前\",{\"1\":{\"69\":1}}],[\"需要改变位置的链表头节点\",{\"1\":{\"27\":1}}],[\"应用中\",{\"1\":{\"69\":1}}],[\"应用程序类加载器\",{\"1\":{\"41\":1}}],[\"吾将上下而求索\",{\"1\":{\"65\":1}}],[\"路漫漫其修远兮\",{\"1\":{\"65\":1}}],[\"到了解掌握\",{\"1\":{\"65\":1}}],[\"到处运行\",{\"1\":{\"51\":1}}],[\"总的来说\",{\"1\":{\"65\":1}}],[\"总结下步骤\",{\"1\":{\"24\":1}}],[\"总结\",{\"0\":{\"14\":1,\"44\":1,\"63\":1,\"81\":1}}],[\"更糟糕的是\",{\"1\":{\"77\":1}}],[\"更新和新增\",{\"1\":{\"72\":1,\"73\":1}}],[\"更新迭代等\",{\"1\":{\"65\":1}}],[\"更专注地学习各项技术\",{\"1\":{\"0\":1}}],[\"流行程度\",{\"1\":{\"65\":1}}],[\"尤其是技术类\",{\"1\":{\"65\":1}}],[\"博客的编写\",{\"1\":{\"65\":1}}],[\"博客刚切换\",{\"1\":{\"0\":1}}],[\"知识为开头\",{\"1\":{\"65\":1}}],[\"之所以事务提交还会参与原始事务\",{\"1\":{\"80\":1}}],[\"之所以以\",{\"1\":{\"65\":1}}],[\"之后调用事务接口\",{\"1\":{\"72\":1,\"73\":1}}],[\"之前原本是直接\",{\"1\":{\"26\":1}}],[\"之前\",{\"1\":{\"23\":1}}],[\"之前只是用链表解决冲突问题\",{\"1\":{\"20\":1}}],[\"之前的\",{\"1\":{\"19\":1}}],[\"花絮\",{\"0\":{\"65\":1}}],[\"技术博客\",{\"1\":{\"64\":1}}],[\"爱飞翔\",{\"1\":{\"64\":1}}],[\"译者\",{\"1\":{\"64\":1}}],[\"yellin\",{\"1\":{\"64\":1}}],[\"第一个问题比较简单\",{\"1\":{\"79\":1}}],[\"第2章\",{\"1\":{\"64\":1}}],[\"第7章\",{\"1\":{\"45\":1}}],[\"性能分析和调优方面的思维\",{\"1\":{\"63\":1}}],[\"性能提升影响是比较大的\",{\"1\":{\"29\":1}}],[\"意在让大伙了解\",{\"1\":{\"63\":1}}],[\"意在让读者明白\",{\"1\":{\"44\":1}}],[\"设置每个线程的堆栈大小\",{\"1\":{\"62\":1}}],[\"设置元空间最大空间大小\",{\"1\":{\"62\":1}}],[\"设置元空间最小空间大小\",{\"1\":{\"62\":1}}],[\"设置永久代最大空间大小\",{\"1\":{\"62\":1}}],[\"设置永久代最小空间大小\",{\"1\":{\"62\":1}}],[\"设置新生代最大空间大小\",{\"1\":{\"62\":1}}],[\"设置新生代最小空间大小\",{\"1\":{\"62\":1}}],[\"设置堆的最大空间大小\",{\"1\":{\"62\":1}}],[\"设置堆的最小空间大小\",{\"1\":{\"62\":1}}],[\"设值\",{\"1\":{\"7\":1}}],[\"xss\",{\"1\":{\"62\":1}}],[\"xx\",{\"1\":{\"62\":6}}],[\"xmx\",{\"1\":{\"62\":1}}],[\"xms\",{\"1\":{\"62\":1}}],[\"xbootclasspath\",{\"1\":{\"41\":1}}],[\"栈内存的大小设置\",{\"1\":{\"62\":1}}],[\"栈帧随着方法调用而创建\",{\"1\":{\"55\":1}}],[\"栈帧是用来存储数据和部分过程结果的数据结构\",{\"1\":{\"55\":1}}],[\"栈帧\",{\"0\":{\"55\":1}}],[\"包括异常回滚\",{\"1\":{\"70\":2}}],[\"包括以下三类\",{\"1\":{\"61\":1}}],[\"包含文本字符串\",{\"1\":{\"61\":1}}],[\"包含运行时常量池\",{\"1\":{\"52\":1}}],[\"编译语言层面的概念\",{\"1\":{\"61\":1}}],[\"编译器编译后的代码等\",{\"1\":{\"60\":1}}],[\"编译器有栈上分配\",{\"1\":{\"58\":1}}],[\"编译器会自动收集类中的类变量赋值操作和静态代码块的语句合并而成\",{\"1\":{\"40\":1}}],[\"声明为\",{\"1\":{\"61\":1}}],[\"声明类变量时指定值\",{\"1\":{\"40\":1}}],[\"两者区别主要在于\",{\"1\":{\"60\":1}}],[\"永久代则被替换为\",{\"1\":{\"60\":1}}],[\"永久代\",{\"1\":{\"60\":1}}],[\"增多导致类膨胀\",{\"1\":{\"60\":1}}],[\"静态变量\",{\"1\":{\"60\":1}}],[\"优先分配在\",{\"1\":{\"58\":1}}],[\"老年代\",{\"1\":{\"58\":1}}],[\"区开辟了一小块内存区域\",{\"1\":{\"58\":1}}],[\"区\",{\"1\":{\"58\":3}}],[\"区别只在于\",{\"1\":{\"57\":1}}],[\"新增数据\",{\"1\":{\"77\":1}}],[\"新增树节点\",{\"1\":{\"24\":1}}],[\"新生代\",{\"1\":{\"58\":1}}],[\"角度来看\",{\"1\":{\"58\":1}}],[\"采用分代收集算法\",{\"1\":{\"58\":1}}],[\"采用两个头节点和两个尾节点保存元素构成链表\",{\"1\":{\"27\":1}}],[\"标量替换等优化技术的实现导致部分对象实例数据不存在\",{\"1\":{\"58\":1}}],[\"垃圾收集\",{\"1\":{\"58\":1}}],[\"垃圾回收\",{\"1\":{\"51\":1}}],[\"共享\",{\"0\":{\"58\":1,\"60\":1}}],[\"服务端发送通知给\",{\"1\":{\"77\":1}}],[\"服务端开启事务\",{\"1\":{\"77\":1}}],[\"服务\",{\"1\":{\"57\":2}}],[\"抛出了在方法内未被捕获的异常\",{\"1\":{\"55\":1}}],[\"随着方法结束而销毁\",{\"1\":{\"55\":1}}],[\"额外附加信息\",{\"1\":{\"55\":1}}],[\"动态扩展到无法申请足够内存时抛出\",{\"1\":{\"56\":1}}],[\"动态链接\",{\"1\":{\"55\":1}}],[\"动作能正确执行\",{\"1\":{\"37\":1}}],[\"局部变量表\",{\"1\":{\"55\":1}}],[\"◡\",{\"1\":{\"54\":1}}],[\"●\",{\"1\":{\"54\":2}}],[\"●ˇ∀ˇ●\",{\"1\":{\"0\":1,\"28\":1}}],[\"调试时点击\",{\"1\":{\"54\":1}}],[\"调用类的静态方法反射\",{\"1\":{\"40\":1}}],[\"调用treenode\",{\"1\":{\"27\":1}}],[\"调用父类\",{\"1\":{\"23\":1}}],[\"调用父类的构造方法\",{\"1\":{\"23\":1}}],[\"调用get\",{\"1\":{\"14\":1}}],[\"现在明白平常用\",{\"1\":{\"54\":1}}],[\"跳转\",{\"1\":{\"53\":1}}],[\"互不影响\",{\"1\":{\"53\":1}}],[\"私有\",{\"0\":{\"53\":1,\"54\":1,\"57\":1}}],[\"橙色私有\",{\"1\":{\"52\":1}}],[\"绿色共享\",{\"1\":{\"52\":1}}],[\"销毁\",{\"1\":{\"52\":2}}],[\"依赖用户线程的启动\",{\"1\":{\"52\":1}}],[\"依旧是从put\",{\"1\":{\"24\":1}}],[\"依旧实现map\",{\"1\":{\"23\":1}}],[\"数据已落库\",{\"1\":{\"77\":1}}],[\"数据刷新到缓存\",{\"1\":{\"77\":1}}],[\"数据不一致情况\",{\"1\":{\"77\":1}}],[\"数据\",{\"1\":{\"77\":2}}],[\"数据未更新\",{\"1\":{\"77\":1}}],[\"数据真正落库\",{\"1\":{\"77\":1}}],[\"数据库\",{\"1\":{\"77\":1}}],[\"数据操作\",{\"1\":{\"76\":1,\"78\":1}}],[\"数据操作时的原子性\",{\"1\":{\"69\":1}}],[\"数据区两大类\",{\"1\":{\"52\":1}}],[\"数组长度\",{\"1\":{\"8\":1}}],[\"数组其实就是entry<k\",{\"1\":{\"4\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"13\":1,\"18\":1,\"20\":1}}],[\"数组+链表\",{\"1\":{\"4\":1}}],[\"去管理\",{\"1\":{\"52\":1}}],[\"去获取\",{\"1\":{\"25\":1}}],[\"又是如何操作\",{\"1\":{\"51\":1}}],[\"管理的最大的一块内存\",{\"1\":{\"58\":1}}],[\"管理\",{\"1\":{\"51\":1}}],[\"平常编写的\",{\"1\":{\"51\":1}}],[\"平常或多或少会有这样的疑问\",{\"1\":{\"51\":1}}],[\"开发者\",{\"1\":{\"63\":1}}],[\"开发一样时刻关注内存的释放\",{\"1\":{\"52\":1}}],[\"开发一枚\",{\"1\":{\"0\":1}}],[\"开发人员\",{\"1\":{\"51\":1}}],[\"分代收集扩展至方法区\",{\"1\":{\"60\":1}}],[\"分配缓冲区\",{\"1\":{\"58\":1}}],[\"分别是\",{\"1\":{\"57\":1}}],[\"分别为以下三个部分\",{\"1\":{\"36\":1}}],[\"分为\",{\"1\":{\"52\":1}}],[\"分析\",{\"1\":{\"51\":1}}],[\"算法\",{\"1\":{\"51\":1}}],[\"算法确定key\",{\"1\":{\"3\":1}}],[\"generation\",{\"1\":{\"60\":1}}],[\"getpreviousisolationlevel\",{\"1\":{\"80\":1}}],[\"getautocommit\",{\"1\":{\"80\":1}}],[\"getconnection\",{\"1\":{\"80\":3}}],[\"getconnectionholder\",{\"1\":{\"80\":5}}],[\"getmapping\",{\"1\":{\"72\":1,\"73\":1}}],[\"getorder\",{\"1\":{\"70\":1}}],[\"gettreenode\",{\"1\":{\"25\":2}}],[\"getnode\",{\"1\":{\"25\":2}}],[\"getvalue\",{\"1\":{\"9\":1}}],[\"getentry\",{\"1\":{\"9\":2}}],[\"getfornullkey\",{\"1\":{\"9\":1}}],[\"get\",{\"0\":{\"9\":1,\"25\":1},\"1\":{\"6\":1,\"9\":2,\"18\":1,\"25\":1}}],[\"garbage\",{\"1\":{\"58\":1}}],[\"gc\",{\"1\":{\"51\":2,\"58\":4,\"60\":4}}],[\"学习\",{\"1\":{\"51\":1}}],[\"可能读者会有疑惑\",{\"1\":{\"77\":1}}],[\"可在这个事件类里注入其它依赖或声明业务逻辑\",{\"1\":{\"73\":1}}],[\"可通过transactionsynchronizationmanager\",{\"1\":{\"76\":1}}],[\"可通过\",{\"1\":{\"73\":1}}],[\"可通过下图来了解参数所控制的区域分别是什么\",{\"1\":{\"62\":1}}],[\"可执行的机器码\",{\"1\":{\"51\":1}}],[\"可以启发我们在内存管理\",{\"1\":{\"63\":1}}],[\"可以通过\",{\"1\":{\"62\":1}}],[\"可以简单的理解新生代主要是存放新创建的对象\",{\"1\":{\"58\":1}}],[\"可以围绕四个部分进行\",{\"1\":{\"51\":1}}],[\"可以是任何字面量\",{\"1\":{\"39\":1}}],[\"可以戳一下链接先去看看哦\",{\"1\":{\"32\":1}}],[\"可以快速定位\",{\"1\":{\"29\":1}}],[\"可以看到其实也是继承hashmap\",{\"1\":{\"23\":1}}],[\"可以先看下图简单对比头插法和尾插法\",{\"1\":{\"19\":1}}],[\"可以用来遍历\",{\"1\":{\"6\":1}}],[\"摘自维基百科\",{\"1\":{\"50\":1}}],[\"除了\",{\"1\":{\"50\":1}}],[\"除非显示使用另外一个类加载器来载入\",{\"1\":{\"42\":1}}],[\"上方说到事务同步注解方式若classes指定了多个值\",{\"1\":{\"78\":1}}],[\"上的描述是\",{\"1\":{\"76\":1}}],[\"上的类库\",{\"1\":{\"41\":1}}],[\"上\",{\"1\":{\"58\":1}}],[\"上运行的字节码\",{\"1\":{\"50\":1}}],[\"使得\",{\"1\":{\"50\":1}}],[\"使用事务注解\",{\"1\":{\"73\":1}}],[\"使用注解标记方法\",{\"1\":{\"73\":1}}],[\"使用方式\",{\"0\":{\"71\":1}}],[\"使用是非常频繁的\",{\"1\":{\"29\":1}}],[\"使用\",{\"1\":{\"0\":1,\"34\":1}}],[\"屏蔽了与具体操作系统平台相关的信息\",{\"1\":{\"50\":1}}],[\"语言层面的常量概念相近\",{\"1\":{\"61\":1}}],[\"语言开发的程序在不同平台上运行时不需要重新编译\",{\"1\":{\"50\":1}}],[\"语言规范的要求\",{\"1\":{\"37\":1}}],[\"寄存器等\",{\"1\":{\"50\":1}}],[\"堆中\",{\"1\":{\"60\":1}}],[\"堆保持一致\",{\"1\":{\"60\":1}}],[\"堆可分为\",{\"1\":{\"58\":1}}],[\"堆\",{\"0\":{\"58\":1},\"1\":{\"52\":1,\"58\":2}}],[\"堆内存大小如何设置等等\",{\"1\":{\"51\":1}}],[\"堆内存空间应当设置多大\",{\"1\":{\"51\":1}}],[\"堆栈设置\",{\"1\":{\"62\":1}}],[\"堆栈\",{\"1\":{\"50\":1}}],[\"堆区只是提供了一个入口去调用相应的对象数据\",{\"1\":{\"33\":1}}],[\"拥有自己完善的硬体架构\",{\"1\":{\"50\":1}}],[\"能够运行\",{\"1\":{\"50\":1}}],[\"能够理想地解决查询效率变低的问题\",{\"1\":{\"20\":1}}],[\"概念\",{\"0\":{\"50\":1}}],[\"机械工业出版社\",{\"1\":{\"45\":1,\"64\":2}}],[\"周志明等\",{\"1\":{\"64\":1}}],[\"周志明\",{\"1\":{\"45\":1,\"64\":1}}],[\"深入理解java虚拟机\",{\"1\":{\"45\":1,\"64\":1}}],[\"参数控制\",{\"1\":{\"62\":1}}],[\"参数指定路径中的\",{\"1\":{\"41\":1}}],[\"参考资料\",{\"0\":{\"45\":1,\"64\":1}}],[\"还会判断用户好友历史记录是否添加过目标用户\",{\"1\":{\"77\":1}}],[\"还可以在运行期间\",{\"1\":{\"61\":1}}],[\"还具有相应的指令系统\",{\"1\":{\"50\":1}}],[\"还能更深入的理解其核心原理\",{\"1\":{\"44\":1}}],[\"还保存了当前entry<k\",{\"1\":{\"4\":1}}],[\"久而久之\",{\"1\":{\"44\":1}}],[\"很多问题都是在某些情况下触发\",{\"1\":{\"44\":1}}],[\"很清晰易懂\",{\"1\":{\"13\":1}}],[\"步骤\",{\"1\":{\"73\":3}}],[\"步骤若是反复验证影响了加载效率该如何做\",{\"1\":{\"44\":1}}],[\"步骤如下\",{\"1\":{\"9\":1,\"25\":1}}],[\"代码生成器之类的案例\",{\"1\":{\"43\":1}}],[\"具体如何避免该问题\",{\"1\":{\"43\":1}}],[\"有值\",{\"1\":{\"75\":1}}],[\"有的虚拟机实现也将本地方法栈和虚拟机栈合并\",{\"1\":{\"57\":1}}],[\"有兴趣的读者也可了解下\",{\"1\":{\"43\":1}}],[\"有可能会破坏原本的双亲委派模型哦\",{\"1\":{\"43\":1}}],[\"有助于我们在使用时\",{\"1\":{\"29\":1}}],[\"继承\",{\"1\":{\"43\":1}}],[\"继承于\",{\"1\":{\"12\":2}}],[\"程序运行所产生的数据\",{\"1\":{\"63\":1}}],[\"程序中很多对象都是小对象且用过即丢\",{\"1\":{\"58\":1}}],[\"程序计数器是一块较小的内存空间\",{\"1\":{\"53\":1}}],[\"程序计数器\",{\"0\":{\"53\":1},\"1\":{\"52\":1}}],[\"程序的开发\",{\"1\":{\"52\":1}}],[\"程序的修改才会生效\",{\"1\":{\"42\":1}}],[\"程序只需生成在\",{\"1\":{\"50\":1}}],[\"程序直接引用等问题\",{\"1\":{\"44\":1}}],[\"程序员小灰\",{\"1\":{\"28\":1}}],[\"必须重启\",{\"1\":{\"42\":1}}],[\"系统中的例子\",{\"1\":{\"77\":1}}],[\"系统才会读取该类对应的二进制数据\",{\"1\":{\"42\":1}}],[\"系统变量指定路径中的类库\",{\"1\":{\"41\":1}}],[\"都算作方法结束\",{\"1\":{\"55\":1}}],[\"都是要读者们在实际应用中去注意\",{\"1\":{\"44\":1}}],[\"都是放在链表头节点\",{\"1\":{\"19\":1}}],[\"都会被缓存\",{\"1\":{\"42\":1}}],[\"先查询缓存\",{\"1\":{\"77\":1}}],[\"先看看注解的源码\",{\"1\":{\"73\":1}}],[\"先让父类加载器试图加载该类\",{\"1\":{\"42\":1}}],[\"先对\",{\"1\":{\"26\":1}}],[\"父类委托\",{\"1\":{\"42\":1}}],[\"父类构造器已经执行完毕\",{\"1\":{\"40\":1}}],[\"所有数据落库\",{\"1\":{\"77\":1}}],[\"所依赖的和引用的其他\",{\"1\":{\"42\":1}}],[\"所以尽量不要在事务回调中执行耗时较久的操作\",{\"1\":{\"80\":1}}],[\"所以肯定只会查到旧的\",{\"1\":{\"77\":1}}],[\"所以容易随着加载的\",{\"1\":{\"60\":1}}],[\"所以小对象通常会被\",{\"1\":{\"58\":1}}],[\"所以也不会触发初始化\",{\"1\":{\"40\":1}}],[\"所以到这里\",{\"1\":{\"33\":1}}],[\"所以直接同\",{\"1\":{\"27\":1}}],[\"所以\",{\"1\":{\"27\":1}}],[\"所以重新设置阈值后直接返回\",{\"1\":{\"10\":1}}],[\"所以停更\",{\"1\":{\"0\":1}}],[\"该请求处理步骤如下\",{\"1\":{\"77\":1}}],[\"该区域不会抛出\",{\"1\":{\"61\":1}}],[\"该\",{\"1\":{\"42\":1}}],[\"该类也就是红黑树节点对象\",{\"1\":{\"23\":1}}],[\"全盘负责\",{\"1\":{\"42\":1}}],[\"会等到方法执行完清理事务资源后\",{\"1\":{\"76\":1}}],[\"会先交给其父类加载器去完成\",{\"1\":{\"42\":1}}],[\"会保证子构造器方法执行前\",{\"1\":{\"40\":1}}],[\"双亲委派模型\",{\"0\":{\"42\":1}}],[\"扩展自己的思维\",{\"1\":{\"63\":1}}],[\"扩展类加载器\",{\"1\":{\"41\":1}}],[\"扩容方法实现逻辑重点在于复制数据的\",{\"1\":{\"27\":1}}],[\"扩容计算\",{\"1\":{\"27\":1}}],[\"扩容复制原理后\",{\"1\":{\"10\":1}}],[\"扩容的关键方法\",{\"1\":{\"10\":1}}],[\"扩容\",{\"1\":{\"7\":1}}],[\"扩容时使用\",{\"1\":{\"5\":1}}],[\"按\",{\"1\":{\"75\":1}}],[\"按文件名识别\",{\"1\":{\"41\":1}}],[\"按位与计算出下标\",{\"1\":{\"8\":1}}],[\"且被\",{\"1\":{\"41\":1}}],[\"目录中的\",{\"1\":{\"41\":2}}],[\"启动类加载器无法被\",{\"1\":{\"44\":1}}],[\"启动类加载器\",{\"1\":{\"41\":1}}],[\"提交后等情况下执行某些操作\",{\"1\":{\"69\":1}}],[\"提供的三种类加载器\",{\"1\":{\"41\":1}}],[\"提高了查询效率\",{\"1\":{\"18\":1}}],[\"自己控制提交的时机\",{\"1\":{\"80\":1}}],[\"自己去查看源码学习\",{\"1\":{\"14\":1}}],[\"自定义操作等\",{\"1\":{\"69\":1}}],[\"自定义类加载器\",{\"0\":{\"43\":1}}],[\"自带的虚拟机实现\",{\"1\":{\"60\":1}}],[\"自行完成\",{\"1\":{\"41\":1}}],[\"始化\",{\"1\":{\"40\":1}}],[\"常用实现方式\",{\"1\":{\"65\":1}}],[\"常用方法\",{\"0\":{\"6\":1}}],[\"常量\",{\"1\":{\"60\":1}}],[\"常量在编译期间会存入调用类的常量池\",{\"1\":{\"40\":1}}],[\"定义数组对象\",{\"1\":{\"40\":1}}],[\"命令调优\",{\"1\":{\"51\":1}}],[\"命令来运行某个主类\",{\"1\":{\"40\":1}}],[\"命中则直接返回\",{\"1\":{\"25\":1}}],[\"或\",{\"1\":{\"62\":1,\"75\":1}}],[\"或通过\",{\"1\":{\"41\":2}}],[\"或者对该静态变量赋值\",{\"1\":{\"40\":1}}],[\"或翻转\",{\"1\":{\"19\":1}}],[\"访问某个类或接口的静态变量\",{\"1\":{\"40\":1}}],[\"触发方式大概有以下几种\",{\"1\":{\"40\":1}}],[\"那么事务执行完后就得将连接恢复到初始状态\",{\"1\":{\"80\":1}}],[\"那么在方法体里如果获取本次事务监听的事件信息呢\",{\"1\":{\"78\":1}}],[\"那么当执行到步骤\",{\"1\":{\"77\":1}}],[\"那么操作依旧会参与原事务\",{\"1\":{\"76\":1}}],[\"那么编译器可以不为这个类生成构造器方法\",{\"1\":{\"40\":1}}],[\"那么类加载器就不会报告错误\",{\"1\":{\"33\":1}}],[\"假如类中有初始化语句\",{\"1\":{\"40\":1}}],[\"假如该类的直接父类还没有被初始化\",{\"1\":{\"40\":1}}],[\"假如这个类还没有被加载和连接\",{\"1\":{\"40\":1}}],[\"假设\",{\"1\":{\"77\":1}}],[\"假设数组长度原本是\",{\"1\":{\"27\":1}}],[\"假设长度为\",{\"1\":{\"26\":1}}],[\"假设有两个线程\",{\"1\":{\"19\":1}}],[\"负责加载用户路径\",{\"1\":{\"41\":1}}],[\"负责加载\",{\"1\":{\"41\":2}}],[\"负责对类进行初始化\",{\"1\":{\"40\":1}}],[\"负载因子\",{\"1\":{\"5\":2}}],[\"相对偏移量或一个间接定位到目标的句柄\",{\"1\":{\"39\":1}}],[\"相同赋值给\",{\"1\":{\"24\":1}}],[\"相同则覆盖并返回旧值\",{\"1\":{\"8\":1}}],[\"各种虚拟机实现的内存布局可以各不相同\",{\"1\":{\"39\":1}}],[\"引入\",{\"1\":{\"50\":1}}],[\"引用的目标并不一定要已经加载到内存中\",{\"1\":{\"39\":1}}],[\"引出了在\",{\"1\":{\"18\":1}}],[\"它与虚拟机实现的布局无关\",{\"1\":{\"39\":1}}],[\"接口方法\",{\"1\":{\"39\":1}}],[\"接下来一一讲解每个部分都做了什么\",{\"1\":{\"34\":1}}],[\"接下来我们具体看看\",{\"1\":{\"7\":1}}],[\"字面量\",{\"1\":{\"61\":1}}],[\"字符串池和静态变量等则放入到\",{\"1\":{\"60\":1}}],[\"字节码的虚拟机\",{\"1\":{\"50\":1}}],[\"字节码验证\",{\"1\":{\"37\":1}}],[\"字段的名称和描述符\",{\"1\":{\"61\":1}}],[\"字段\",{\"1\":{\"39\":1}}],[\"主要针对的是常量池的回收和类型的卸载\",{\"1\":{\"60\":1}}],[\"主要针对类或接口\",{\"1\":{\"39\":1}}],[\"主要对类变量进行初始化\",{\"1\":{\"40\":1}}],[\"主要是查找并加载类的二进制数据\",{\"1\":{\"35\":1}}],[\"主要是在新增\",{\"1\":{\"29\":1}}],[\"主要是因为红黑树结构\",{\"1\":{\"28\":1}}],[\"把常量池内的符号引用转换为直接引用\",{\"0\":{\"39\":1}}],[\"生成\",{\"1\":{\"38\":1}}],[\"阶段\",{\"1\":{\"38\":1}}],[\"实际场景\",{\"0\":{\"77\":1}}],[\"实际值的初始化会在\",{\"1\":{\"38\":1}}],[\"实现步骤\",{\"1\":{\"73\":1}}],[\"实现对于\",{\"1\":{\"58\":1}}],[\"实现\",{\"1\":{\"51\":1}}],[\"实现类\",{\"1\":{\"3\":1}}],[\"实现类有\",{\"1\":{\"2\":1}}],[\"比如\",{\"1\":{\"61\":1}}],[\"比如声明如下\",{\"1\":{\"38\":1}}],[\"比如classes=\",{\"1\":{\"75\":1}}],[\"比如class\",{\"1\":{\"33\":1}}],[\"准备\",{\"0\":{\"38\":1}}],[\"解绑资源\",{\"1\":{\"80\":1}}],[\"解释器就知道下一步要执行的字节码指令位置\",{\"1\":{\"53\":1}}],[\"解析\",{\"0\":{\"39\":1},\"1\":{\"37\":1}}],[\"解决问题\",{\"1\":{\"29\":1}}],[\"符号引用\",{\"1\":{\"39\":1,\"61\":1}}],[\"符号引用类型常见如下\",{\"1\":{\"39\":1}}],[\"符号引用验证\",{\"1\":{\"37\":1}}],[\"符合逻辑的\",{\"1\":{\"37\":1}}],[\"确保\",{\"1\":{\"37\":1}}],[\"确保被加载的类的正确性\",{\"0\":{\"37\":1}}],[\"确定程序语义是合法的\",{\"1\":{\"37\":1}}],[\"元空间并不在虚拟机中\",{\"1\":{\"60\":1}}],[\"元空间\",{\"1\":{\"60\":1}}],[\"元数据验证\",{\"1\":{\"37\":1}}],[\"元素存放在新数组要么是原位置\",{\"1\":{\"27\":1}}],[\"元素数量\",{\"1\":{\"8\":1}}],[\"大多是直接使用\",{\"1\":{\"69\":1}}],[\"大致会进行以下四个部分的验证\",{\"1\":{\"37\":1}}],[\"大小为原来的2倍\",{\"1\":{\"10\":1,\"14\":1}}],[\"规范规定该区域可抛出异常\",{\"1\":{\"59\":1}}],[\"规范规定该区域有两种异常\",{\"1\":{\"56\":1}}],[\"规范要求\",{\"1\":{\"37\":1}}],[\"规范允许类加载器在预料某个类将要被使用时就预先加载它\",{\"1\":{\"33\":1}}],[\"验证字节流是否符合\",{\"1\":{\"37\":1}}],[\"验证\",{\"0\":{\"37\":1},\"1\":{\"44\":1}}],[\"👈下面有做简单介绍\",{\"1\":{\"35\":1}}],[\"文件的常量池\",{\"1\":{\"61\":1}}],[\"文件的字节流信息是否符合当前\",{\"1\":{\"37\":1}}],[\"文件信息是如何被\",{\"1\":{\"51\":1}}],[\"文件编写后\",{\"1\":{\"44\":1}}],[\"文件格式中\",{\"1\":{\"39\":1}}],[\"文件格式的规范\",{\"1\":{\"37\":1}}],[\"文件格式验证\",{\"1\":{\"37\":1}}],[\"文件进行加载\",{\"1\":{\"35\":1}}],[\"文件中的二进制数据读入到内存中\",{\"1\":{\"33\":1}}],[\"卸载\",{\"1\":{\"34\":1}}],[\"初始化某个类的子类\",{\"1\":{\"40\":1}}],[\"初始化的步骤如下\",{\"1\":{\"40\":1}}],[\"初始化\",{\"0\":{\"40\":1},\"1\":{\"34\":1,\"38\":1,\"41\":1}}],[\"连接无意义占用而引发连接池溢出\",{\"1\":{\"80\":1}}],[\"连接直到事务回调执行完成后清理资源才释放\",{\"1\":{\"80\":1}}],[\"连接获取后autocommit的修改源码如下\",{\"1\":{\"80\":1}}],[\"连接细化分下来\",{\"1\":{\"36\":1}}],[\"连接\",{\"0\":{\"36\":1},\"1\":{\"34\":1,\"44\":1}}],[\"加上本人也想通过搭建一个博客网站\",{\"1\":{\"65\":1}}],[\"加上深感自己对技术的理解还不够深入\",{\"1\":{\"0\":1}}],[\"加载指定类时\",{\"1\":{\"40\":1}}],[\"加载是类加载过程的第一个阶段\",{\"1\":{\"35\":1}}],[\"加载\",{\"0\":{\"35\":1},\"1\":{\"34\":1,\"41\":1}}],[\"纯洁的微笑\",{\"1\":{\"33\":1}}],[\"此段引用于\",{\"1\":{\"33\":1}}],[\"此处附上文章\",{\"1\":{\"28\":1}}],[\"错误\",{\"1\":{\"33\":1}}],[\"用于存放编译期生产的各种字面量和符号引用\",{\"1\":{\"61\":1}}],[\"用来封装类在方法区内的数据结构\",{\"1\":{\"33\":1}}],[\"用以应对不同业务情况下的数据存储与使用\",{\"1\":{\"2\":1}}],[\"运行时常量池除了编译期产生的\",{\"1\":{\"61\":1}}],[\"运行时常量池\",{\"0\":{\"61\":1}}],[\"运行时数据区的方法区内\",{\"1\":{\"33\":1}}],[\"运算判断位置是否需要移动\",{\"1\":{\"27\":1}}],[\"运算效果相当于只跟高位\",{\"1\":{\"27\":1}}],[\"运算\",{\"1\":{\"27\":2}}],[\"运算为\",{\"1\":{\"27\":1}}],[\"运算的一直是哈希值的低\",{\"1\":{\"26\":1}}],[\"运算获取下标\",{\"1\":{\"26\":1}}],[\"什么是\",{\"0\":{\"49\":1}}],[\"什么是类的加载\",{\"0\":{\"33\":1}}],[\"什么是红黑树\",{\"1\":{\"28\":1}}],[\"我崇尚的是从不会\",{\"1\":{\"65\":1}}],[\"我将着重描述\",{\"1\":{\"32\":1}}],[\"我们就可以知道\",{\"1\":{\"51\":1}}],[\"我们就以此作为切入点\",{\"1\":{\"18\":1}}],[\"我们也可以自定义类加载器\",{\"1\":{\"43\":1}}],[\"我们也能理解为什么\",{\"1\":{\"33\":1}}],[\"我们先简单了解下\",{\"1\":{\"41\":1}}],[\"我们可以使用默认的类加载器\",{\"1\":{\"35\":1}}],[\"我们可以简单看张图理解下\",{\"1\":{\"33\":1}}],[\"我们常见的\",{\"1\":{\"2\":1}}],[\"篇已经详细讲解了\",{\"1\":{\"32\":1}}],[\"篇中\",{\"1\":{\"18\":1}}],[\"内存结构及其概念\",{\"1\":{\"63\":1}}],[\"内存调优从哪里入手\",{\"1\":{\"51\":1}}],[\"内存模型结构图\",{\"1\":{\"52\":1}}],[\"内存模型主要是指运行时内存模型\",{\"1\":{\"52\":1}}],[\"内存模型后\",{\"1\":{\"51\":1}}],[\"内存模型的讲解\",{\"1\":{\"51\":1}}],[\"内存模型的结构\",{\"1\":{\"32\":1}}],[\"内存模型\",{\"0\":{\"48\":1,\"52\":1},\"1\":{\"32\":1,\"51\":1,\"52\":1,\"64\":1}}],[\"内部定义的几个主要属性如下\",{\"1\":{\"5\":1}}],[\"也可达到缩小事务范围的效果\",{\"1\":{\"81\":1}}],[\"也可以先带着问题去阅读下源码\",{\"1\":{\"78\":1}}],[\"也可以理解为是用永久代方法实现了方法区\",{\"1\":{\"60\":1}}],[\"也可以自定义类加载器对\",{\"1\":{\"35\":1}}],[\"也就导致了事务回调期间的\",{\"1\":{\"80\":1}}],[\"也就是\",{\"1\":{\"40\":1}}],[\"也没有做一些知识记录\",{\"1\":{\"65\":1}}],[\"也是因为对于\",{\"1\":{\"65\":1}}],[\"也是\",{\"1\":{\"58\":1}}],[\"也是面试经典问题了\",{\"1\":{\"29\":1}}],[\"也与虚拟机栈相同\",{\"1\":{\"57\":1}}],[\"也有其它的开源或闭源实现\",{\"1\":{\"50\":1}}],[\"也有忽略的细节\",{\"1\":{\"44\":1}}],[\"也将由该类加载器负责载入\",{\"1\":{\"42\":1}}],[\"也在同一天发布了第一篇文章\",{\"1\":{\"0\":1}}],[\"掌握原理\",{\"1\":{\"29\":1}}],[\"结合上图梳理流程如下\",{\"1\":{\"77\":1}}],[\"结合上面对于\",{\"1\":{\"28\":1}}],[\"结束\",{\"1\":{\"52\":1}}],[\"结构是个什么样子\",{\"1\":{\"63\":1}}],[\"结构是数组+链表\",{\"1\":{\"4\":1}}],[\"结构变化\",{\"0\":{\"20\":1}}],[\"结构修改的次数\",{\"1\":{\"5\":1}}],[\"结构图\",{\"1\":{\"4\":1}}],[\"结构\",{\"0\":{\"4\":1,\"55\":1}}],[\"供感兴趣的读者学习下红黑树的相关知识\",{\"1\":{\"28\":1}}],[\"讲解起来会很啰嗦冗余\",{\"1\":{\"28\":1}}],[\"讲解了其原理\",{\"1\":{\"18\":1}}],[\"整体的实现逻辑描述\",{\"1\":{\"28\":1}}],[\"简单分为以下几步\",{\"1\":{\"27\":1}}],[\"简单讲就是链表中\",{\"1\":{\"13\":1}}],[\"旧容量\",{\"1\":{\"27\":1}}],[\"旧数组数据复制到新数组\",{\"1\":{\"10\":1}}],[\"说明新位置是原索引\",{\"1\":{\"27\":1}}],[\"说明原索引位置存值\",{\"1\":{\"27\":1}}],[\"仅第一次\",{\"1\":{\"27\":1}}],[\"尾声\",{\"0\":{\"29\":1}}],[\"尾节点不为空\",{\"1\":{\"27\":1}}],[\"尾节点为空\",{\"1\":{\"27\":1}}],[\"尾插法\",{\"1\":{\"19\":1,\"24\":2}}],[\"zero\",{\"1\":{\"27\":1}}],[\"<\",{\"1\":{\"27\":4}}],[\"<<\",{\"1\":{\"27\":3}}],[\"处就体现了上面说的元素是否需要移动的判断\",{\"1\":{\"27\":1}}],[\"高位\",{\"1\":{\"27\":1}}],[\"高位多\",{\"1\":{\"27\":1}}],[\"进行编写\",{\"1\":{\"73\":1}}],[\"进行位运算\",{\"1\":{\"27\":1}}],[\"进行\",{\"1\":{\"27\":1}}],[\"进行异或运算\",{\"1\":{\"26\":1}}],[\"来查询最新的\",{\"1\":{\"77\":1}}],[\"来判断当前方法是否处于活跃事务中\",{\"1\":{\"76\":1}}],[\"来总结自己一路学习的技术和知识\",{\"1\":{\"65\":1}}],[\"来实现\",{\"1\":{\"51\":1}}],[\"来看下resize\",{\"1\":{\"27\":1}}],[\"来看看\",{\"1\":{\"18\":1}}],[\"来确定是否需要移动即可\",{\"1\":{\"27\":1}}],[\"只要\",{\"1\":{\"43\":1}}],[\"只有一个值时\",{\"1\":{\"75\":1}}],[\"只有缓存区不存在\",{\"1\":{\"42\":1}}],[\"只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类\",{\"1\":{\"42\":1}}],[\"只有当父类加载器无法完成加载任务时\",{\"1\":{\"42\":1}}],[\"只会触发父类的初始化\",{\"1\":{\"40\":1}}],[\"只需要在\",{\"1\":{\"27\":1}}],[\"只是维护了双向链表的应用\",{\"1\":{\"23\":1}}],[\"经过实际测试\",{\"1\":{\"75\":1,\"76\":1}}],[\"经过\",{\"1\":{\"27\":1}}],[\"经验也不够充足\",{\"1\":{\"0\":1}}],[\"红色\",{\"1\":{\"27\":1}}],[\"红黑树根节点\",{\"1\":{\"23\":1}}],[\"红黑树和链表就会频繁转换\",{\"1\":{\"21\":1}}],[\"红黑树和链表就互相转换\",{\"1\":{\"21\":1}}],[\"红黑树的平均查找时间为\",{\"1\":{\"21\":1}}],[\"红黑树又会转换为链表\",{\"1\":{\"21\":1}}],[\"搭配一张图来看就会很好理解\",{\"1\":{\"27\":1}}],[\"要考虑的细节还是挺多\",{\"1\":{\"65\":1}}],[\"要么是原位置加上\",{\"1\":{\"27\":1}}],[\"要高出许多\",{\"1\":{\"12\":1}}],[\"倍\",{\"1\":{\"27\":3}}],[\"倍的新数组\",{\"1\":{\"10\":1}}],[\"次幂\",{\"1\":{\"27\":2}}],[\"次幂扩展\",{\"1\":{\"27\":1}}],[\"次方\",{\"1\":{\"26\":1}}],[\"否则可能导致\",{\"1\":{\"80\":1}}],[\"否则抛出参数类型错误异常\",{\"1\":{\"75\":1}}],[\"否则无操作\",{\"1\":{\"70\":1}}],[\"否则\",{\"1\":{\"27\":1}}],[\"want\",{\"1\":{\"80\":1}}],[\"was\",{\"1\":{\"27\":1}}],[\"windows\",{\"1\":{\"51\":1}}],[\"with\",{\"1\":{\"27\":2}}],[\"web\",{\"1\":{\"62\":1,\"69\":1}}],[\"we\",{\"1\":{\"27\":1,\"80\":2}}],[\"while\",{\"1\":{\"10\":1,\"19\":3,\"25\":1,\"27\":1}}],[\"减少碰撞\",{\"1\":{\"26\":1}}],[\"以保证其描述的信息符合\",{\"1\":{\"37\":1}}],[\"以及树节点平衡被打破后的处理情况等内容比较复杂\",{\"1\":{\"28\":1}}],[\"以下部分是遍历链表节点进行复制\",{\"1\":{\"27\":1}}],[\"以让低\",{\"1\":{\"26\":1}}],[\"以key\",{\"1\":{\"3\":1}}],[\"便让哈希值与高\",{\"1\":{\"26\":1}}],[\"便于在红黑树和链表之间进行转换\",{\"1\":{\"23\":1}}],[\"位更随机散列\",{\"1\":{\"26\":1}}],[\"位更随机\",{\"1\":{\"26\":1}}],[\"位运算结果取决于低\",{\"1\":{\"26\":1}}],[\"位\",{\"1\":{\"26\":3}}],[\"位甚至更低\",{\"1\":{\"26\":1}}],[\"长度都小于\",{\"1\":{\"26\":1}}],[\"长度始终保持为\",{\"1\":{\"5\":1}}],[\"对事务的特性和使用需有所理解\",{\"1\":{\"81\":1}}],[\"对一门新技术\",{\"1\":{\"65\":1}}],[\"对于异常抛出规范\",{\"1\":{\"57\":1}}],[\"对于\",{\"1\":{\"50\":1}}],[\"对字节码描述的信息进行语义分析\",{\"1\":{\"37\":1}}],[\"对key\",{\"1\":{\"26\":1}}],[\"对象中\",{\"1\":{\"80\":1}}],[\"对象都存放在堆区的原因\",{\"1\":{\"33\":1}}],[\"对象封装了类在方法区内的数据结构\",{\"1\":{\"33\":1}}],[\"对象进行存储\",{\"1\":{\"14\":1}}],[\"对象并添加\",{\"1\":{\"8\":1}}],[\"对象的\",{\"1\":{\"4\":1}}],[\"对象\",{\"1\":{\"4\":1,\"33\":1,\"35\":1,\"40\":1,\"42\":2}}],[\"对象存储\",{\"1\":{\"4\":1}}],[\"操作和执行耗时较长的操作\",{\"1\":{\"81\":1}}],[\"操作就会提交\",{\"1\":{\"80\":1}}],[\"操作都没有被提交\",{\"1\":{\"80\":1}}],[\"操作栈\",{\"1\":{\"55\":1}}],[\"操作实现如下\",{\"1\":{\"26\":1}}],[\"操作\",{\"1\":{\"26\":1,\"72\":1,\"73\":1,\"77\":1,\"81\":1}}],[\"就新开事务执行\",{\"1\":{\"81\":1}}],[\"就需要保证\",{\"1\":{\"77\":1}}],[\"就只会查到旧数据\",{\"1\":{\"77\":1}}],[\"就导致容易遗忘\",{\"1\":{\"65\":1}}],[\"就对应着虚拟机栈的入栈到出栈的过程\",{\"1\":{\"54\":1}}],[\"就可以在多种平台上不加修改地运行\",{\"1\":{\"50\":1}}],[\"就得查看浏览下\",{\"1\":{\"43\":1}}],[\"就已经可以正常使用\",{\"1\":{\"41\":1}}],[\"就说明引用的目标在内存已经存在\",{\"1\":{\"39\":1}}],[\"就是直接指向目标的指针\",{\"1\":{\"39\":1}}],[\"就是在高位多\",{\"1\":{\"27\":1}}],[\"就进行扩容resize\",{\"1\":{\"24\":1}}],[\"就将链表转换为红黑树\",{\"1\":{\"24\":1}}],[\"就会转换为红黑树\",{\"1\":{\"21\":1}}],[\"就会很轻松了\",{\"1\":{\"14\":1}}],[\"就会进行扩容操作\",{\"1\":{\"5\":1}}],[\"超过则扩容\",{\"1\":{\"24\":1}}],[\">>>\",{\"1\":{\"26\":2}}],[\">\",{\"1\":{\"24\":1,\"25\":1,\"27\":2}}],[\">=\",{\"1\":{\"8\":1,\"10\":1,\"24\":2,\"27\":2}}],[\"传递\",{\"1\":{\"24\":1}}],[\"覆盖\",{\"1\":{\"24\":1}}],[\"添加好友的流程除了处理好友请求记录外\",{\"1\":{\"77\":1}}],[\"添加请求在流程中明明只有一次\",{\"1\":{\"77\":1}}],[\"添加\",{\"1\":{\"24\":1}}],[\"执行完这一步\",{\"1\":{\"80\":1}}],[\"执行\",{\"1\":{\"24\":1}}],[\"右节点\",{\"1\":{\"23\":1}}],[\"左节点\",{\"1\":{\"23\":1}}],[\"posts\",{\"0\":{\"85\":1}}],[\"pool\",{\"1\":{\"80\":1}}],[\"power\",{\"1\":{\"27\":2}}],[\"ps\",{\"1\":{\"77\":1,\"78\":1}}],[\"phase\",{\"1\":{\"73\":2,\"79\":1}}],[\"protected\",{\"1\":{\"80\":2}}],[\"println\",{\"1\":{\"72\":4,\"73\":1}}],[\"private\",{\"1\":{\"72\":1,\"73\":1}}],[\"prepareconnectionfortransaction\",{\"1\":{\"80\":1}}],[\"precedence\",{\"1\":{\"70\":1}}],[\"preserve\",{\"1\":{\"27\":1}}],[\"previousisolationlevel\",{\"1\":{\"80\":2}}],[\"prev\",{\"1\":{\"23\":1}}],[\"permsize\",{\"1\":{\"62\":1}}],[\"permanent\",{\"1\":{\"60\":1}}],[\"placed\",{\"1\":{\"27\":1}}],[\"p\",{\"1\":{\"24\":10}}],[\"parent\",{\"1\":{\"23\":1}}],[\"publishevent\",{\"1\":{\"73\":1}}],[\"publisher\",{\"1\":{\"73\":2}}],[\"public\",{\"1\":{\"6\":10,\"8\":1,\"9\":1,\"24\":1,\"25\":1,\"38\":2,\"70\":9,\"72\":6,\"73\":7,\"79\":1}}],[\"putifabsent\",{\"1\":{\"24\":1}}],[\"puttreeval\",{\"1\":{\"24\":2}}],[\"putval\",{\"1\":{\"24\":2}}],[\"putfornullkey\",{\"1\":{\"8\":1}}],[\"put\",{\"0\":{\"8\":1,\"24\":1},\"1\":{\"6\":1,\"8\":1,\"18\":1,\"24\":2}}],[\"但拿到的却都是旧数据\",{\"1\":{\"77\":1}}],[\"但也有一些特殊情况\",{\"1\":{\"69\":1}}],[\"但其本身并不能跨平台\",{\"1\":{\"51\":1}}],[\"但其内部方法实现基本相同\",{\"1\":{\"23\":1}}],[\"但事无巨细\",{\"1\":{\"44\":1}}],[\"但这里有个要注意的点\",{\"1\":{\"43\":1}}],[\"但本质上并没有直接引用定义常量的类\",{\"1\":{\"40\":1}}],[\"但是它们能接受的符号引用必须是一致的\",{\"1\":{\"39\":1}}],[\"但如果是下面的声明方式\",{\"1\":{\"38\":1}}],[\"但一般情况下\",{\"1\":{\"26\":1}}],[\"但treenode<k\",{\"1\":{\"23\":1}}],[\"但synchronize是重量级锁\",{\"1\":{\"12\":1}}],[\"update\",{\"1\":{\"72\":1,\"73\":1}}],[\"unbindresource\",{\"1\":{\"80\":1}}],[\"unnecessarily\",{\"1\":{\"80\":1}}],[\"undefined\",{\"1\":{\"53\":1}}],[\"unchecked\",{\"1\":{\"27\":1}}],[\"untreeify\",{\"1\":{\"21\":1}}],[\"using\",{\"1\":{\"27\":2}}],[\"usealthashing\",{\"1\":{\"10\":3}}],[\"默认传递\",{\"1\":{\"24\":1}}],[\"默认的转换为链表的节点阈值\",{\"1\":{\"21\":1}}],[\"默认的转换为红黑树的节点阈值\",{\"1\":{\"21\":1}}],[\"默认是true\",{\"1\":{\"80\":1}}],[\"默认是\",{\"1\":{\"5\":1}}],[\"频繁增删\",{\"1\":{\"21\":1}}],[\"徘徊\",{\"1\":{\"21\":1}}],[\"和\",{\"0\":{\"23\":1},\"1\":{\"21\":1,\"27\":1,\"52\":1,\"57\":1,\"60\":1}}],[\"首次主动使用\",{\"1\":{\"33\":1}}],[\"首次建立个人博客\",{\"1\":{\"0\":1}}],[\"首先用链表存储\",{\"1\":{\"21\":1}}],[\"查询速度就会受到影响\",{\"1\":{\"20\":1}}],[\"查找匹配的节点\",{\"1\":{\"25\":1}}],[\"查找\",{\"1\":{\"20\":1}}],[\"变量在修改\",{\"1\":{\"80\":1}}],[\"变为\",{\"1\":{\"27\":1}}],[\"变大时\",{\"1\":{\"20\":1}}],[\"变大\",{\"1\":{\"20\":1}}],[\"变成\",{\"1\":{\"19\":1}}],[\"显著提高了查询效率\",{\"1\":{\"20\":1}}],[\"再搭配上策略模式优雅代码\",{\"1\":{\"79\":1}}],[\"再到能讲解给别人听让别人理解\",{\"1\":{\"65\":1}}],[\"再去查看关于红黑树操作的源码\",{\"1\":{\"28\":1}}],[\"再将链表头节点存放到新数组的相应位置\",{\"1\":{\"27\":1}}],[\"再进一步计算下标\",{\"1\":{\"26\":1}}],[\"再存入到新数组中\",{\"1\":{\"19\":1}}],[\"再次贴上复制数据的方法源码\",{\"1\":{\"19\":1}}],[\"循环\",{\"1\":{\"53\":1}}],[\"循环中\",{\"1\":{\"27\":1}}],[\"循环复制数据中\",{\"1\":{\"19\":1}}],[\"循环里遍历一个节点就插入到新的数组位置\",{\"1\":{\"19\":1}}],[\"源码\",{\"1\":{\"19\":1}}],[\"源码如下\",{\"1\":{\"10\":1}}],[\"方志朋\",{\"1\":{\"64\":1}}],[\"方面与\",{\"1\":{\"60\":1}}],[\"方式与数据结构并没有强制规定\",{\"1\":{\"57\":1}}],[\"方便大家回顾\",{\"1\":{\"19\":1}}],[\"方法入参推荐不指定\",{\"1\":{\"78\":1}}],[\"方法入参类型为\",{\"1\":{\"75\":1}}],[\"方法入参只能为\",{\"1\":{\"75\":1}}],[\"方法的名称和描述符\",{\"1\":{\"61\":1}}],[\"方法的源码了\",{\"1\":{\"43\":1}}],[\"方法的源码\",{\"1\":{\"27\":1}}],[\"方法返回值和异常分派\",{\"1\":{\"55\":1}}],[\"方法返回地址\",{\"1\":{\"55\":1}}],[\"方法执行过程\",{\"1\":{\"54\":1}}],[\"方法执行的内存模型\",{\"1\":{\"54\":1}}],[\"方法执行时生成的变量\",{\"1\":{\"51\":1}}],[\"方法区也常被称为\",{\"1\":{\"60\":1}}],[\"方法区主要存放的是虚拟机加载的类信息\",{\"1\":{\"60\":1}}],[\"方法区\",{\"0\":{\"60\":1},\"1\":{\"52\":1}}],[\"方法句柄和调用点限定符七类符号引用\",{\"1\":{\"39\":1}}],[\"方法类型\",{\"1\":{\"39\":1}}],[\"方法优化\",{\"1\":{\"29\":1}}],[\"方法进行具体操作\",{\"1\":{\"27\":1}}],[\"方法上有这么一段注释\",{\"1\":{\"27\":1}}],[\"方法开始\",{\"1\":{\"24\":1}}],[\"方法\",{\"0\":{\"24\":1,\"25\":1,\"26\":1,\"27\":1},\"1\":{\"24\":1,\"43\":2,\"53\":2,\"57\":2,\"61\":1}}],[\"方法时同样计算key的哈希值然后获取数组下标\",{\"1\":{\"14\":1}}],[\"方法存值时会调用key\",{\"1\":{\"14\":1}}],[\"方法里作了判断\",{\"1\":{\"12\":1}}],[\"方法里计算key的hash值找到下标然后循环遍历判断key的值\",{\"1\":{\"9\":1}}],[\"方法将旧数组数据循环遍历复制到新数组\",{\"1\":{\"10\":1}}],[\"方法就简单多了\",{\"1\":{\"9\":1}}],[\"方法后\",{\"1\":{\"9\":1}}],[\"方法判断是否需要扩容\",{\"1\":{\"8\":1}}],[\"方法实现\",{\"0\":{\"8\":1,\"9\":1,\"10\":1}}],[\"方法原理\",{\"0\":{\"7\":1}}],[\"另一个是因为复制数据是在\",{\"1\":{\"19\":1}}],[\"后修改连接的自动提交autocommit为false\",{\"1\":{\"80\":1}}],[\"后有效\",{\"1\":{\"62\":2}}],[\"后无效\",{\"1\":{\"62\":2}}],[\"后者依然是基于\",{\"1\":{\"60\":1}}],[\"后\",{\"1\":{\"42\":1,\"60\":1,\"77\":1}}],[\"后判断是否等于\",{\"1\":{\"27\":1}}],[\"后就被阻塞\",{\"1\":{\"19\":1}}],[\"后依旧在同一个数组下标位置\",{\"1\":{\"19\":1}}],[\"后续新篇章也会对\",{\"1\":{\"13\":1}}],[\"每个方法\",{\"1\":{\"54\":1}}],[\"每个线程都有一个独立的计数器\",{\"1\":{\"53\":1}}],[\"每个节点都是一个entry<k\",{\"1\":{\"4\":1}}],[\"每当添加新元素时\",{\"1\":{\"19\":1}}],[\"原因是流程做了简化\",{\"1\":{\"77\":1}}],[\"原因之一是链表节点的存储方式引起\",{\"1\":{\"19\":1}}],[\"原\",{\"1\":{\"27\":1}}],[\"原索引+原数组容量\",{\"1\":{\"27\":1}}],[\"原理宏观上跟以前的思路差不多\",{\"1\":{\"29\":1}}],[\"原理解析\",{\"0\":{\"22\":1}}],[\"原理并不复杂\",{\"1\":{\"14\":1}}],[\"原头节点就变成新节点的\",{\"1\":{\"19\":1}}],[\"版本有了哪些变化\",{\"1\":{\"18\":1}}],[\"版本开始\",{\"1\":{\"13\":1}}],[\"至于其它的一些细枝末节\",{\"1\":{\"14\":1}}],[\"前的\",{\"1\":{\"14\":1}}],[\"前言\",{\"0\":{\"2\":1,\"18\":1,\"69\":1}}],[\"最终返回结果\",{\"1\":{\"14\":1}}],[\"最后只能依赖连接的autocommit恢复后\",{\"1\":{\"80\":1}}],[\"最后判断容量若大于阈值\",{\"1\":{\"24\":1}}],[\"最后来概括下\",{\"1\":{\"14\":1}}],[\"最后将key\",{\"1\":{\"8\":1}}],[\"然后由\",{\"1\":{\"80\":1}}],[\"然后系统加以运行\",{\"1\":{\"51\":1}}],[\"然后编写加载的具体逻辑代码即可\",{\"1\":{\"43\":1}}],[\"然后在堆区创建一个java\",{\"1\":{\"33\":1}}],[\"然后进入putval\",{\"1\":{\"24\":1}}],[\"然后确定数组下标\",{\"1\":{\"20\":1}}],[\"然后通过instanceof或class\",{\"1\":{\"79\":1}}],[\"然后通过key\",{\"1\":{\"25\":1}}],[\"然后通过\",{\"1\":{\"14\":1}}],[\"然后将key和value作为entry<k\",{\"1\":{\"4\":1}}],[\"作者\",{\"1\":{\"64\":2}}],[\"作为方法区的一部分\",{\"1\":{\"61\":1}}],[\"作为\",{\"1\":{\"51\":1,\"63\":1}}],[\"作为入口用于访问该对象在方法区里的数据结构\",{\"1\":{\"35\":1}}],[\"作为下一个节点\",{\"1\":{\"8\":1}}],[\"作下介绍讲解\",{\"1\":{\"13\":1}}],[\"8080\",{\"1\":{\"38\":3}}],[\"80\",{\"1\":{\"38\":2}}],[\"8\",{\"0\":{\"17\":1},\"1\":{\"13\":3,\"14\":1,\"18\":2,\"19\":3,\"20\":3,\"21\":8,\"23\":2,\"24\":2,\"26\":1,\"29\":2,\"60\":1,\"62\":4}}],[\"疫苗\",{\"1\":{\"13\":1}}],[\"陈皓的\",{\"1\":{\"13\":1}}],[\"刚好需要扩容\",{\"1\":{\"13\":1}}],[\"竞用条件\",{\"1\":{\"13\":1}}],[\"runtime\",{\"1\":{\"73\":1}}],[\"rollbackfor\",{\"1\":{\"72\":1,\"73\":1}}],[\"rt\",{\"1\":{\"41\":1}}],[\"rawtypes\",{\"1\":{\"27\":1}}],[\"race\",{\"1\":{\"13\":1}}],[\"right\",{\"1\":{\"23\":1}}],[\"releaseconnection\",{\"1\":{\"80\":2}}],[\"releasing\",{\"1\":{\"80\":1}}],[\"request\",{\"1\":{\"77\":4}}],[\"req\",{\"1\":{\"77\":11}}],[\"retentionpolicy\",{\"1\":{\"73\":1}}],[\"retention\",{\"1\":{\"73\":1}}],[\"return\",{\"1\":{\"8\":4,\"9\":4,\"10\":1,\"24\":3,\"25\":5,\"26\":1,\"27\":2,\"70\":1}}],[\"registersynchronization\",{\"1\":{\"72\":1}}],[\"readonly\",{\"1\":{\"70\":1}}],[\"reset\",{\"1\":{\"80\":1}}],[\"resetconnectionaftertransaction\",{\"1\":{\"80\":1}}],[\"resource\",{\"1\":{\"73\":1}}],[\"restcontroller\",{\"1\":{\"72\":1,\"73\":1}}],[\"resume\",{\"1\":{\"70\":1}}],[\"resize\",{\"0\":{\"10\":1,\"27\":1},\"1\":{\"8\":1,\"10\":1,\"18\":1,\"24\":2,\"27\":1}}],[\"redis\",{\"1\":{\"77\":1}}],[\"red\",{\"1\":{\"23\":1}}],[\"rehash\",{\"1\":{\"10\":4,\"19\":3}}],[\"rehashing\",{\"1\":{\"10\":1}}],[\"recordaccess\",{\"1\":{\"8\":1}}],[\"remove\",{\"1\":{\"6\":1,\"80\":1}}],[\"产生\",{\"1\":{\"13\":1}}],[\"死链就出现了\",{\"1\":{\"19\":1}}],[\"死链原因和解决方法\",{\"0\":{\"19\":1}}],[\"死链是指在\",{\"1\":{\"13\":1}}],[\"死链问题\",{\"0\":{\"13\":1},\"1\":{\"18\":1}}],[\"效率将会降低\",{\"1\":{\"21\":1}}],[\"效率比\",{\"1\":{\"12\":1}}],[\"效率较低\",{\"1\":{\"12\":1}}],[\"效率较高\",{\"1\":{\"12\":1}}],[\"其抽象实现transactionsynchronizationadapter源码如下\",{\"1\":{\"70\":1}}],[\"其它都是由\",{\"1\":{\"41\":1}}],[\"其它代码省略\",{\"1\":{\"4\":1,\"23\":2}}],[\"其实在最初的\",{\"1\":{\"41\":1}}],[\"其实有三步\",{\"1\":{\"36\":1}}],[\"其意思大概就是初始化或增加数组大小\",{\"1\":{\"27\":1}}],[\"其采用的是分段锁\",{\"1\":{\"12\":1}}],[\"推荐使用\",{\"1\":{\"12\":1}}],[\"因为\",{\"1\":{\"58\":1,\"77\":1,\"80\":1}}],[\"因为该参数是告诉虚拟机是否要对类进行初始化\",{\"1\":{\"40\":1}}],[\"因为符号引用的字面量形式明确定义在\",{\"1\":{\"39\":1}}],[\"因为扩容后\",{\"1\":{\"27\":1}}],[\"因为扩容为n\",{\"1\":{\"27\":1}}],[\"因为使用的是\",{\"1\":{\"27\":1}}],[\"因此方法参数指定为applicationevent类型即可\",{\"1\":{\"79\":1}}],[\"因此便可利用事务同步来控制步骤\",{\"1\":{\"77\":1}}],[\"因此便有了这个开头\",{\"1\":{\"65\":1}}],[\"因此不受\",{\"1\":{\"77\":1}}],[\"因此还是推荐不设置参数\",{\"1\":{\"75\":1}}],[\"因此事务同步回调时可获取该事件的信息\",{\"1\":{\"73\":1}}],[\"因此元空间的大小仅受本地内存限制\",{\"1\":{\"60\":1}}],[\"因此从\",{\"1\":{\"58\":1}}],[\"因此具体的虚拟机可以自由实现它\",{\"1\":{\"57\":1}}],[\"因此最终加载任务都会传递到顶层的启动类加载器\",{\"1\":{\"42\":1}}],[\"因此扩容时不需要重新计算\",{\"1\":{\"27\":1}}],[\"因此\",{\"1\":{\"20\":1}}],[\"因此在多线程并发应用中使用是比较少的\",{\"1\":{\"12\":1}}],[\"因工作琐事\",{\"1\":{\"0\":1}}],[\"容器\",{\"1\":{\"62\":1}}],[\"容易引起线程上下文切换而带来线程调度的开销\",{\"1\":{\"12\":1}}],[\"容量\",{\"1\":{\"5\":1}}],[\"datasource\",{\"1\":{\"80\":1}}],[\"datasourcetransactionobject\",{\"1\":{\"80\":2}}],[\"datasourceutils\",{\"1\":{\"80\":4}}],[\"drivers\",{\"1\":{\"80\":1}}],[\"drop\",{\"1\":{\"54\":1}}],[\"debug\",{\"1\":{\"80\":4}}],[\"definition\",{\"1\":{\"80\":3}}],[\"defaults\",{\"1\":{\"27\":1}}],[\"default\",{\"1\":{\"5\":1,\"27\":4,\"73\":5}}],[\"db\",{\"1\":{\"69\":1,\"72\":1,\"73\":1,\"76\":1,\"77\":6,\"78\":1,\"80\":5,\"81\":2}}],[\"dispatch\",{\"1\":{\"55\":1}}],[\"dirs\",{\"1\":{\"41\":1}}],[\"dictionary<k\",{\"1\":{\"12\":1}}],[\"docleanupaftercompletion\",{\"1\":{\"80\":1}}],[\"documented\",{\"1\":{\"73\":1}}],[\"don\",{\"1\":{\"80\":1}}],[\"dobegin\",{\"1\":{\"80\":1}}],[\"double\",{\"1\":{\"27\":1}}],[\"doubles\",{\"1\":{\"27\":1}}],[\"do\",{\"1\":{\"25\":1,\"27\":1,\"79\":2,\"80\":1}}],[\"线程恢复等基础功能也都依赖于该计数器来实现\",{\"1\":{\"53\":1}}],[\"线程共享数据区域则随虚拟机的启动\",{\"1\":{\"52\":1}}],[\"线程共享\",{\"1\":{\"52\":2}}],[\"线程私有数据区域生命周期与线程相同\",{\"1\":{\"52\":1}}],[\"线程私有\",{\"1\":{\"52\":2,\"58\":1}}],[\"线程一获取到\",{\"1\":{\"19\":1}}],[\"线程安全\",{\"1\":{\"12\":1}}],[\"线程不安全\",{\"1\":{\"12\":1}}],[\"唯一\",{\"1\":{\"12\":1}}],[\"允许为\",{\"1\":{\"12\":1}}],[\"与上面同理\",{\"1\":{\"27\":1}}],[\"与\",{\"0\":{\"12\":1},\"1\":{\"61\":1}}],[\"补充\",{\"0\":{\"11\":1,\"62\":1}}],[\"理解\",{\"0\":{\"51\":1}}],[\"理解起来就会比较轻松了\",{\"1\":{\"28\":1}}],[\"理解清楚\",{\"1\":{\"10\":1}}],[\"理解了put\",{\"1\":{\"9\":1}}],[\"关闭\",{\"1\":{\"52\":1}}],[\"关于堆\",{\"1\":{\"62\":1}}],[\"关于\",{\"1\":{\"35\":1}}],[\"关于红黑树\",{\"0\":{\"28\":1}}],[\"关于其逻辑实现在下面会讲到\",{\"1\":{\"19\":1}}],[\"关于死链具体情况\",{\"1\":{\"13\":1}}],[\"关于作者\",{\"0\":{\"0\":1}}],[\"关键\",{\"1\":{\"10\":1}}],[\"头节点指向当前遍历节点\",{\"1\":{\"27\":1}}],[\"头部插入\",{\"1\":{\"10\":1}}],[\"头插法\",{\"1\":{\"10\":1,\"19\":1}}],[\"节点不为空\",{\"1\":{\"24\":1}}],[\"节点为空直接添加\",{\"1\":{\"24\":1}}],[\"节点以及下一节点\",{\"1\":{\"19\":1}}],[\"节点\",{\"1\":{\"10\":1,\"19\":1}}],[\"链表存储方式变为尾插法\",{\"1\":{\"29\":1}}],[\"链表红黑树互转等则讲解不多\",{\"1\":{\"28\":1}}],[\"链表与红黑树转换时机\",{\"0\":{\"21\":1}}],[\"链表结构\",{\"1\":{\"19\":1}}],[\"链表变成\",{\"1\":{\"19\":1}}],[\"链表头部插入\",{\"1\":{\"10\":1}}],[\"链表节点中的下一个\",{\"1\":{\"4\":1}}],[\"遍历链表\",{\"1\":{\"24\":1}}],[\"遍历当前节点的链表\",{\"1\":{\"10\":1}}],[\"遍历旧数组复制数据\",{\"1\":{\"27\":1}}],[\"遍历旧数组\",{\"1\":{\"10\":1}}],[\"++j\",{\"1\":{\"27\":1}}],[\"++size\",{\"1\":{\"24\":1}}],[\"++modcount\",{\"1\":{\"24\":1}}],[\"++bincount\",{\"1\":{\"24\":1}}],[\"+o\",{\"1\":{\"20\":2}}],[\"+\",{\"1\":{\"10\":1,\"27\":2,\"72\":2,\"77\":1,\"80\":6}}],[\"+1\",{\"1\":{\"8\":2}}],[\"^\",{\"1\":{\"10\":1,\"26\":1}}],[\"autocommit\",{\"1\":{\"80\":1}}],[\"acquired\",{\"1\":{\"80\":1}}],[\"accord\",{\"1\":{\"27\":1}}],[\"aevent\",{\"1\":{\"79\":2}}],[\"annotation\",{\"1\":{\"73\":3}}],[\"abstract\",{\"1\":{\"70\":1}}],[\"abstractmap<k\",{\"1\":{\"12\":1}}],[\"applicationeventpublisher\",{\"1\":{\"73\":1}}],[\"applicationevent\",{\"1\":{\"73\":1,\"79\":1}}],[\"application\",{\"1\":{\"41\":1}}],[\"attribute\",{\"1\":{\"73\":2}}],[\"at\",{\"1\":{\"27\":1}}],[\"are\",{\"1\":{\"27\":1}}],[\"already\",{\"1\":{\"80\":1}}],[\"aliasfor\",{\"1\":{\"73\":2}}],[\"allocation\",{\"1\":{\"58\":1}}],[\"allocates\",{\"1\":{\"27\":1}}],[\"always\",{\"1\":{\"25\":1}}],[\"alternative\",{\"1\":{\"10\":1}}],[\"aftercompletion方法回调时若有\",{\"1\":{\"78\":1}}],[\"aftercompletion\",{\"0\":{\"76\":1},\"1\":{\"70\":1,\"72\":1}}],[\"aftercommit\",{\"0\":{\"76\":1},\"1\":{\"70\":1,\"72\":1,\"73\":1,\"78\":1,\"79\":1}}],[\"afternodeinsertion\",{\"1\":{\"24\":1}}],[\"afternodeaccess\",{\"1\":{\"24\":1}}],[\"after\",{\"1\":{\"23\":1,\"73\":2,\"79\":1,\"80\":2}}],[\"after两个属性\",{\"1\":{\"23\":1}}],[\"a\",{\"1\":{\"13\":2,\"19\":5,\"27\":1,\"75\":3,\"77\":5}}],[\"addentry\",{\"1\":{\"8\":2}}],[\"|=\",{\"1\":{\"10\":1}}],[\"||\",{\"1\":{\"8\":1,\"9\":1,\"24\":4,\"25\":2,\"80\":1}}],[\"基于注解\",{\"0\":{\"73\":1}}],[\"基于接口\",{\"0\":{\"72\":1}}],[\"基本不存在\",{\"1\":{\"60\":1}}],[\"基本不存在扩容情况\",{\"1\":{\"10\":1}}],[\"基本侧重于\",{\"1\":{\"28\":1}}],[\"基本上其它方法实现都可以很容易理解了\",{\"1\":{\"10\":1}}],[\"基础\",{\"0\":{\"3\":1}}],[\"已会可忽略\",{\"1\":{\"28\":1}}],[\"已有的节点往后移作为\",{\"1\":{\"10\":1}}],[\"已经大的夸张\",{\"1\":{\"10\":1}}],[\"已存储的元素数量\",{\"1\":{\"5\":1}}],[\"获取连接进行重置\",{\"1\":{\"80\":1}}],[\"获取数组下标位置第一个节点\",{\"1\":{\"25\":1}}],[\"获取key的\",{\"1\":{\"24\":1}}],[\"获取元素的逻辑还是比较简单\",{\"1\":{\"25\":1}}],[\"获取元素的时间复杂度就变为\",{\"1\":{\"20\":1}}],[\"获取元素可以简单分为以下两步\",{\"1\":{\"20\":1}}],[\"获取\",{\"1\":{\"20\":1,\"24\":1,\"29\":1}}],[\"获取是否需要重新计算\",{\"1\":{\"10\":1}}],[\"获取旧数组长度\",{\"1\":{\"10\":1}}],[\"获取所有entry<k\",{\"1\":{\"6\":1}}],[\"获取所有key的\",{\"1\":{\"6\":1}}],[\"中为类变量进行初始值设定有两种方式\",{\"1\":{\"40\":1}}],[\"中类的加载到底经历了哪些过程\",{\"1\":{\"32\":1}}],[\"中间存在差值\",{\"1\":{\"21\":1}}],[\"中则变为node<k\",{\"1\":{\"23\":1}}],[\"中则利用红黑树替代链表\",{\"1\":{\"20\":1}}],[\"中则更改为\",{\"1\":{\"19\":1}}],[\"中已经得到解决\",{\"1\":{\"13\":1}}],[\"中\",{\"0\":{\"17\":1},\"1\":{\"10\":1,\"18\":1,\"20\":2,\"29\":1}}],[\"中是否已存在\",{\"1\":{\"6\":1}}],[\"三目表达式判断\",{\"1\":{\"9\":1}}],[\"三大集合框架之一\",{\"1\":{\"2\":1}}],[\"直接使用\",{\"1\":{\"40\":1}}],[\"直接引用\",{\"1\":{\"39\":1}}],[\"直接取数组下标为\",{\"1\":{\"9\":1}}],[\"直接上源码\",{\"1\":{\"9\":1,\"24\":1}}],[\"直接存放在数组下标\",{\"1\":{\"8\":1}}],[\"在这两个方法中执行\",{\"1\":{\"76\":1}}],[\"在回调时事务资源可能仍然处于活跃状态并可访问\",{\"1\":{\"76\":1}}],[\"在事务明明已经提交的情况下\",{\"1\":{\"78\":1}}],[\"在事务完成后执行\",{\"1\":{\"77\":1}}],[\"在事务接口方法里\",{\"1\":{\"73\":1}}],[\"在事务方法中通过transactionsynchronizationmanager事务同步管理器注册事务同步\",{\"1\":{\"72\":1}}],[\"在相应的事务阶段回调方法中实现业务逻辑\",{\"1\":{\"72\":1}}],[\"在transactionsynchronization接口有定义\",{\"1\":{\"70\":1}}],[\"在transfer\",{\"1\":{\"10\":1}}],[\"在aftercompletion方法的入参status有三种状态\",{\"1\":{\"70\":1}}],[\"在addentry\",{\"1\":{\"8\":1}}],[\"在下方事务同步的两种使用方式本质都是利用了该抽象类来实现\",{\"1\":{\"70\":1}}],[\"在下面源码中\",{\"1\":{\"23\":1}}],[\"在常规的\",{\"1\":{\"69\":1}}],[\"在此区域出现频率较低\",{\"1\":{\"60\":1}}],[\"在新生代的\",{\"1\":{\"58\":1}}],[\"在新增和获取过程中\",{\"1\":{\"26\":1}}],[\"在执行时都会创建一个栈帧\",{\"1\":{\"54\":1}}],[\"在理解了\",{\"1\":{\"51\":1}}],[\"在理解了上面的内容后\",{\"1\":{\"14\":1}}],[\"在上面类加器图中我们可以看到\",{\"1\":{\"42\":1}}],[\"在上面内容中\",{\"1\":{\"28\":1}}],[\"在静态代码块赋值\",{\"1\":{\"40\":1}}],[\"在编译阶段会为\",{\"1\":{\"38\":1}}],[\"在实际开发中\",{\"1\":{\"29\":1}}],[\"在java\",{\"1\":{\"29\":1}}],[\"在resize\",{\"1\":{\"27\":1}}],[\"在发生碰撞问题时\",{\"1\":{\"20\":1}}],[\"在最后简单描述了\",{\"1\":{\"18\":1}}],[\"在聊聊\",{\"1\":{\"18\":1}}],[\"在左耳朵耗子\",{\"1\":{\"13\":1}}],[\"在\",{\"1\":{\"10\":1,\"13\":1,\"18\":1,\"20\":4,\"23\":1,\"26\":1,\"27\":1,\"32\":2,\"60\":1}}],[\"在getentry\",{\"1\":{\"9\":1}}],[\"在日常开发使用中\",{\"1\":{\"2\":1}}],[\"插入到链表头\",{\"1\":{\"8\":1}}],[\"碰撞\",{\"1\":{\"8\":1}}],[\"不会再有提交操作\",{\"1\":{\"80\":1}}],[\"不会在主程序运行期对方法区进行清理\",{\"1\":{\"60\":1}}],[\"不会触发类初\",{\"1\":{\"40\":1}}],[\"不会触发类初始化的情况如下\",{\"1\":{\"40\":1}}],[\"不会触发\",{\"1\":{\"40\":1}}],[\"不会触发该类的初始化\",{\"1\":{\"40\":1}}],[\"不存在事务时\",{\"1\":{\"73\":1}}],[\"不存在线程共享和适合被快速\",{\"1\":{\"58\":1}}],[\"不存在则返回null\",{\"1\":{\"9\":1}}],[\"不含\",{\"1\":{\"54\":1}}],[\"不仅问题解决了\",{\"1\":{\"44\":1}}],[\"不为\",{\"1\":{\"27\":1}}],[\"不为空说明链表存在\",{\"1\":{\"27\":1}}],[\"不为空先判断key\",{\"1\":{\"24\":1}}],[\"不为空则进行覆盖并返回旧值\",{\"1\":{\"24\":1}}],[\"不为空\",{\"1\":{\"8\":1,\"12\":1}}],[\"不需要改变位置的链表头节点\",{\"1\":{\"27\":1}}],[\"不超过最大值则扩容为原来的\",{\"1\":{\"27\":1}}],[\"不同说明发生碰撞\",{\"1\":{\"24\":1}}],[\"不覆盖\",{\"1\":{\"24\":1}}],[\"不匹配则循环判断下一节点\",{\"1\":{\"9\":1}}],[\"不指定则默认为\",{\"1\":{\"5\":1}}],[\"若只是代码执行耗时\",{\"1\":{\"81\":1}}],[\"若只是使用事务注解标记整个处理流程\",{\"1\":{\"77\":1}}],[\"若有必要\",{\"1\":{\"81\":1}}],[\"若有也会去修改\",{\"1\":{\"77\":1}}],[\"若有冲突\",{\"1\":{\"25\":1}}],[\"若事务方法发布的事件刚好与参数的事件类型一致\",{\"1\":{\"75\":1}}],[\"若方法入参为空或不为事件类型\",{\"1\":{\"75\":1}}],[\"若方法入参为事件类型\",{\"1\":{\"75\":1}}],[\"若遇到异常\",{\"1\":{\"29\":1}}],[\"若当前遍历的节点元素位置没有冲突\",{\"1\":{\"27\":1}}],[\"若当前节点没有冲突\",{\"1\":{\"27\":1}}],[\"若新数组未设置阈值\",{\"1\":{\"27\":1}}],[\"若无数据并且阈值为\",{\"1\":{\"27\":1}}],[\"若无数据\",{\"1\":{\"27\":1}}],[\"若是超过最大值\",{\"1\":{\"27\":1}}],[\"若是链表节点\",{\"1\":{\"24\":1}}],[\"若多出的高位\",{\"1\":{\"27\":1}}],[\"若下标处第一个节点匹配则返回\",{\"1\":{\"25\":1}}],[\"若节点已经存在\",{\"1\":{\"24\":1}}],[\"若为\",{\"1\":{\"53\":1}}],[\"若为链表节点则进行遍历\",{\"1\":{\"27\":1}}],[\"若为链表则遍历判断\",{\"1\":{\"25\":1}}],[\"若为空直接新增\",{\"1\":{\"24\":1}}],[\"若为树节点则调用\",{\"1\":{\"25\":1}}],[\"若为树节点\",{\"1\":{\"24\":1,\"27\":2}}],[\"若数组下标位置节点key不匹配\",{\"1\":{\"20\":1}}],[\"若链表元素\",{\"1\":{\"19\":1}}],[\"若\",{\"1\":{\"8\":1,\"21\":1,\"24\":1}}],[\"创建事件类\",{\"1\":{\"73\":1}}],[\"创建事件对象\",{\"1\":{\"73\":1}}],[\"创建类的实例\",{\"1\":{\"40\":1}}],[\"创建大小为原来\",{\"1\":{\"10\":1}}],[\"创建一个新的数组\",{\"1\":{\"10\":1}}],[\"创建\",{\"1\":{\"8\":1,\"72\":1}}],[\"则善用线程池异步处理\",{\"1\":{\"81\":1}}],[\"则查询\",{\"1\":{\"77\":1}}],[\"则可以正确回调\",{\"1\":{\"75\":1}}],[\"则入参不需要指定\",{\"1\":{\"75\":1}}],[\"则表示方法不关心任何事件\",{\"1\":{\"75\":1}}],[\"则表示只要事件发布了就回调\",{\"1\":{\"73\":1}}],[\"则代表是感兴趣的事件\",{\"1\":{\"75\":1}}],[\"则计数器的值为空\",{\"1\":{\"53\":1}}],[\"则计数器记录的是正在执行的虚拟机字节码指令的地址\",{\"1\":{\"53\":1}}],[\"则计算新的数组下标直接存值\",{\"1\":{\"27\":1}}],[\"则需要使用到类加载器\",{\"1\":{\"41\":1}}],[\"则其父类也会被初始化\",{\"1\":{\"40\":1}}],[\"则系统依次执行这些初始化语句\",{\"1\":{\"40\":1}}],[\"则先初始化其直接父类\",{\"1\":{\"40\":1}}],[\"则程序先加载并连接该类\",{\"1\":{\"40\":1}}],[\"则会直接赋值为\",{\"1\":{\"38\":1}}],[\"则会触发扩容操作\",{\"1\":{\"5\":1}}],[\"则直接计算新的数组下标存值\",{\"1\":{\"27\":1}}],[\"则链表存在\",{\"1\":{\"27\":1}}],[\"则链表为空\",{\"1\":{\"27\":1}}],[\"则链表元素会出现逆序\",{\"1\":{\"19\":1}}],[\"则是对应链表尾节点\",{\"1\":{\"27\":1}}],[\"则调用\",{\"1\":{\"27\":1}}],[\"则进入此处计算新的\",{\"1\":{\"27\":1}}],[\"则使用默认值设置\",{\"1\":{\"27\":1}}],[\"则用初始化阈值赋值\",{\"1\":{\"27\":1}}],[\"则不扩容\",{\"1\":{\"27\":1}}],[\"则不需要变化\",{\"1\":{\"27\":1}}],[\"则元素\",{\"1\":{\"27\":1}}],[\"则按默认值进行初始化\",{\"1\":{\"27\":1}}],[\"则下标运算的结果取决于哈希值的低\",{\"1\":{\"26\":1}}],[\"则替换旧值oldvalue并返回\",{\"1\":{\"24\":1}}],[\"则遍历到链表尾部判断\",{\"1\":{\"24\":1}}],[\"则遍历链表\",{\"1\":{\"20\":1}}],[\"则判断是否与当前遍历节点相同\",{\"1\":{\"24\":1}}],[\"则转换为红黑树\",{\"1\":{\"24\":1}}],[\"则说明发生\",{\"1\":{\"8\":1}}],[\"则扩容为原来的2倍大小\",{\"1\":{\"8\":1}}],[\"bootstrap\",{\"1\":{\"41\":1}}],[\"boolean\",{\"1\":{\"6\":3,\"10\":3,\"19\":1,\"23\":1,\"24\":2,\"70\":1,\"73\":1}}],[\"buffer\",{\"1\":{\"58\":1}}],[\"bug\",{\"1\":{\"29\":1}}],[\"bucketindex\",{\"1\":{\"8\":7}}],[\"bit\",{\"1\":{\"27\":4}}],[\"bin\",{\"1\":{\"27\":1}}],[\"bincount\",{\"1\":{\"24\":2}}],[\"bevent\",{\"1\":{\"79\":2}}],[\"because\",{\"1\":{\"27\":1}}],[\"beforecompletion\",{\"1\":{\"70\":1}}],[\"beforecommit\",{\"1\":{\"70\":1}}],[\"before\",{\"1\":{\"23\":1}}],[\"break\",{\"1\":{\"24\":2}}],[\"b\",{\"1\":{\"13\":2,\"19\":5,\"75\":2,\"77\":8}}],[\"封装为\",{\"1\":{\"8\":1}}],[\"将连接回收到数据库连接池\",{\"1\":{\"80\":1}}],[\"将新的常量加入常量池\",{\"1\":{\"61\":1}}],[\"将新数组赋值给\",{\"1\":{\"10\":1}}],[\"将编译好的文件解释成平台系统\",{\"1\":{\"51\":1}}],[\"将其放在\",{\"1\":{\"33\":1}}],[\"将头节点保存在相应位置\",{\"1\":{\"27\":1}}],[\"将尾节点指向当前遍历节点\",{\"1\":{\"27\":2}}],[\"将原有节点\",{\"1\":{\"8\":1}}],[\"将\",{\"1\":{\"8\":2}}],[\"6\",{\"1\":{\"8\":1,\"21\":3,\"24\":4,\"27\":12}}],[\"修改次数\",{\"1\":{\"8\":1}}],[\"5\",{\"1\":{\"8\":1,\"10\":1,\"24\":1,\"27\":2}}],[\"obtaindatasource\",{\"1\":{\"80\":2}}],[\"object\",{\"1\":{\"6\":4,\"8\":1,\"9\":3,\"25\":2,\"26\":1,\"42\":1,\"73\":1,\"80\":2}}],[\"out\",{\"1\":{\"72\":4,\"73\":1}}],[\"outofmemoryerror\",{\"1\":{\"51\":1,\"56\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1}}],[\"override\",{\"1\":{\"70\":8,\"72\":2,\"80\":2}}],[\"open\",{\"1\":{\"60\":1}}],[\"oom\",{\"1\":{\"51\":1,\"53\":1,\"60\":1}}],[\"offset\",{\"1\":{\"27\":1}}],[\"of\",{\"1\":{\"27\":2}}],[\"otherwise\",{\"1\":{\"27\":1}}],[\"oracle\",{\"1\":{\"50\":1}}],[\"ordered\",{\"1\":{\"70\":2}}],[\"order\",{\"1\":{\"27\":1}}],[\"or\",{\"1\":{\"27\":2}}],[\"onlyifabsent\",{\"1\":{\"24\":3}}],[\"o\",{\"1\":{\"20\":2}}],[\"oldthr\",{\"1\":{\"27\":4}}],[\"oldtab\",{\"1\":{\"27\":7}}],[\"oldtable\",{\"1\":{\"10\":2}}],[\"oldcap\",{\"1\":{\"27\":10}}],[\"oldcapacity\",{\"1\":{\"10\":2}}],[\"oldalthashing\",{\"1\":{\"10\":2}}],[\"oldvalue\",{\"1\":{\"8\":2,\"24\":3}}],[\"4\",{\"1\":{\"8\":1,\"10\":1,\"21\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":2}}],[\"event\",{\"1\":{\"79\":3}}],[\"eventlistener\",{\"1\":{\"73\":3}}],[\"evict\",{\"1\":{\"24\":2}}],[\"eclipse\",{\"1\":{\"62\":1}}],[\"eden\",{\"1\":{\"58\":2}}],[\"either\",{\"1\":{\"27\":1}}],[\"each\",{\"1\":{\"27\":1}}],[\"elementtype\",{\"1\":{\"73\":2}}],[\"elements\",{\"1\":{\"27\":1}}],[\"else\",{\"1\":{\"24\":3,\"27\":8,\"79\":1}}],[\"ex\",{\"1\":{\"80\":3}}],[\"example\",{\"1\":{\"80\":1}}],[\"exposed\",{\"1\":{\"80\":1}}],[\"explicitly\",{\"1\":{\"80\":1}}],[\"expensive\",{\"1\":{\"80\":1}}],[\"expansion\",{\"1\":{\"27\":1}}],[\"exception\",{\"0\":{\"56\":1,\"59\":1},\"1\":{\"55\":1,\"72\":1,\"73\":1}}],[\"ext\",{\"1\":{\"41\":2}}],[\"extension\",{\"1\":{\"41\":1}}],[\"extends\",{\"1\":{\"23\":2,\"72\":1,\"73\":1}}],[\"exe\",{\"1\":{\"40\":1}}],[\"existing\",{\"1\":{\"24\":1}}],[\"equals\",{\"1\":{\"8\":1,\"9\":1,\"14\":1,\"20\":1,\"24\":3,\"25\":3}}],[\"e\",{\"1\":{\"8\":13,\"9\":7,\"10\":10,\"19\":10,\"24\":13,\"25\":10,\"27\":19}}],[\"entry<>\",{\"1\":{\"8\":1}}],[\"entry<k\",{\"1\":{\"4\":9,\"5\":1,\"8\":2,\"9\":3,\"10\":2,\"14\":1,\"19\":2,\"23\":7}}],[\"entryset\",{\"1\":{\"6\":1}}],[\"entry\",{\"1\":{\"4\":2,\"5\":1,\"8\":3,\"9\":3,\"10\":4,\"13\":2,\"19\":1,\"23\":1}}],[\"32\",{\"1\":{\"27\":1}}],[\"3\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"21\":1,\"24\":2,\"27\":10,\"73\":1}}],[\"计算下标方式\",{\"1\":{\"26\":1}}],[\"计算下标时\",{\"1\":{\"26\":1}}],[\"计算哈希值从而获取数组下标\",{\"1\":{\"14\":1}}],[\"计算数组下标\",{\"1\":{\"10\":1,\"24\":2}}],[\"计算数组下标并循环遍历该下标处的链表节点\",{\"1\":{\"9\":1}}],[\"计算key的\",{\"1\":{\"8\":1,\"25\":1}}],[\"计算\",{\"1\":{\"8\":1,\"9\":1,\"26\":1}}],[\"为何还会参与原始事务\",{\"1\":{\"78\":1}}],[\"为何还要加事务\",{\"1\":{\"77\":1}}],[\"为避免出现这种情况\",{\"1\":{\"77\":1}}],[\"为好友\",{\"1\":{\"77\":1}}],[\"为类的静态变量赋予正确的初始值\",{\"1\":{\"40\":1}}],[\"为类的静态变量分配内存\",{\"0\":{\"38\":1}}],[\"为了让哈希值的低\",{\"1\":{\"26\":1}}],[\"为空则先创建\",{\"1\":{\"24\":1}}],[\"为空则创建\",{\"1\":{\"24\":1}}],[\"为空直接添加\",{\"1\":{\"24\":1}}],[\"为空直接抛出\",{\"1\":{\"12\":1}}],[\"为空直接获取数组下标为\",{\"1\":{\"9\":1}}],[\"为null则直接存放到数组下标为\",{\"1\":{\"8\":1}}],[\"为\",{\"1\":{\"8\":1,\"9\":1,\"27\":2,\"80\":1}}],[\"1111\",{\"1\":{\"27\":2}}],[\"1st\",{\"1\":{\"24\":1}}],[\"1<<30\",{\"1\":{\"10\":1}}],[\"1\",{\"1\":{\"8\":3,\"9\":1,\"10\":2,\"20\":2,\"24\":6,\"25\":2,\"26\":1,\"27\":13,\"40\":1,\"70\":1,\"73\":1,\"75\":1,\"77\":4}}],[\"16\",{\"1\":{\"5\":1,\"26\":7,\"27\":4}}],[\"复制数据等方法的具体实现是怎么样的\",{\"1\":{\"7\":1}}],[\"取值\",{\"1\":{\"7\":1,\"10\":1}}],[\"集合\",{\"1\":{\"6\":2},\"2\":{\"16\":1,\"31\":1}}],[\"即修改autocommit=true\",{\"1\":{\"80\":1}}],[\"即缺少最新的请求记录\",{\"1\":{\"77\":1}}],[\"即可看到注解方法内的内容输出\",{\"1\":{\"73\":1}}],[\"即可看到如下结果\",{\"1\":{\"72\":1}}],[\"即事务同步\",{\"1\":{\"69\":1}}],[\"即数据类型的默认初始值\",{\"1\":{\"38\":1}}],[\"即数据元素\",{\"1\":{\"6\":1}}],[\"即原来大小的\",{\"1\":{\"27\":1}}],[\"即长度为\",{\"1\":{\"26\":1}}],[\"即添加的新元素会放在链表尾节点\",{\"1\":{\"19\":1}}],[\"即\",{\"1\":{\"19\":2,\"27\":2,\"58\":1,\"77\":1}}],[\"即一个key对应一个value\",{\"1\":{\"2\":1}}],[\"存放的是几乎所有的对象实例和数组数据\",{\"1\":{\"58\":1}}],[\"存放\",{\"1\":{\"51\":1}}],[\"存放键值对\",{\"1\":{\"6\":1}}],[\"存入缓存区\",{\"1\":{\"42\":1}}],[\"存储的元素数量在\",{\"1\":{\"21\":1}}],[\"存储的元素数量达到该值\",{\"1\":{\"5\":1}}],[\"存在返回值\",{\"1\":{\"9\":1}}],[\"判断类型\",{\"1\":{\"79\":1}}],[\"判断当前\",{\"1\":{\"37\":1}}],[\"判断两个尾节点\",{\"1\":{\"27\":1}}],[\"判断是树节点还是链表节点\",{\"1\":{\"25\":1}}],[\"判断是否为树节点\",{\"1\":{\"24\":1}}],[\"判断是否超过阈值\",{\"1\":{\"24\":1}}],[\"判断是否需要重新计算\",{\"1\":{\"10\":1}}],[\"判断是否\",{\"1\":{\"9\":1}}],[\"判断下标处元素\",{\"1\":{\"24\":1}}],[\"判断该位置是否为空\",{\"1\":{\"24\":1}}],[\"判断值是否相同\",{\"1\":{\"14\":1}}],[\"判断key是否\",{\"1\":{\"9\":1}}],[\"判断key是否重复\",{\"1\":{\"8\":1}}],[\"判断key是否为null\",{\"1\":{\"8\":1}}],[\"判断传递的value是否已有key进行映射\",{\"1\":{\"6\":1}}],[\"判断传递的key在\",{\"1\":{\"6\":1}}],[\"判断\",{\"1\":{\"6\":1,\"8\":2,\"9\":1,\"24\":2}}],[\"返回请求处理结果\",{\"1\":{\"77\":1}}],[\"返回结果等\",{\"1\":{\"51\":1}}],[\"返回\",{\"1\":{\"6\":1}}],[\"一次编译\",{\"1\":{\"51\":1}}],[\"一组符号来描述目标\",{\"1\":{\"39\":1}}],[\"一旦\",{\"1\":{\"5\":1}}],[\"一些配置还有内容还需要时间慢慢缝补\",{\"1\":{\"0\":1}}],[\"重要的变化可以简单归纳为\",{\"1\":{\"29\":1}}],[\"重要的是内部静态类增加了treenode<k\",{\"1\":{\"23\":1}}],[\"重复则覆盖并返回旧值\",{\"1\":{\"8\":1}}],[\"重新计算阈值\",{\"1\":{\"10\":1}}],[\"重新调整\",{\"1\":{\"5\":1}}],[\"重新扩容等\",{\"1\":{\"5\":1}}],[\"重拾博客\",{\"1\":{\"0\":1}}],[\"如上即为连接获取后autocommit的修改操作\",{\"1\":{\"80\":1}}],[\"如添加好友\",{\"1\":{\"77\":1}}],[\"如资源准备\",{\"1\":{\"69\":1}}],[\"如技术原理\",{\"1\":{\"65\":1}}],[\"如何处理\",{\"1\":{\"63\":1}}],[\"如处理器\",{\"1\":{\"50\":1}}],[\"如\",{\"1\":{\"41\":1,\"44\":1,\"57\":1}}],[\"如class\",{\"1\":{\"40\":1}}],[\"如新增树节点\",{\"1\":{\"28\":1}}],[\"如果在堆中没有内存完成实例分配\",{\"1\":{\"59\":1}}],[\"如果在预先加载的过程中遇到了\",{\"1\":{\"33\":1}}],[\"如果线程正在执行的是一个\",{\"1\":{\"53\":1}}],[\"如果直接重写\",{\"1\":{\"43\":1}}],[\"如果有需要\",{\"1\":{\"43\":1}}],[\"如果指定参数initialize为\",{\"1\":{\"40\":1}}],[\"如果一个类中既没有类变量也没有静态代码块\",{\"1\":{\"40\":1}}],[\"如果这个类一直没有被程序主动使用\",{\"1\":{\"33\":1}}],[\"如果想先了解\",{\"1\":{\"32\":1}}],[\"如果数组本就为空\",{\"1\":{\"27\":1}}],[\"如果链表长度大于等于treeify\",{\"1\":{\"24\":1}}],[\"如果加入新元素超过阈值\",{\"1\":{\"8\":1}}],[\"如此一来\",{\"1\":{\"20\":1}}],[\"如修改值\",{\"1\":{\"5\":1}}],[\"如下图\",{\"1\":{\"27\":1}}],[\"如下图所示\",{\"1\":{\"26\":1,\"34\":1,\"41\":1}}],[\"如下\",{\"1\":{\"4\":1,\"73\":1}}],[\"记录\",{\"1\":{\"5\":1,\"77\":1}}],[\"metaspacesize\",{\"1\":{\"62\":1}}],[\"metaspace\",{\"1\":{\"60\":1}}],[\"method\",{\"1\":{\"39\":1,\"73\":1}}],[\"move\",{\"1\":{\"27\":1}}],[\"modcount++\",{\"1\":{\"8\":1}}],[\"modcount\",{\"1\":{\"5\":1}}],[\"mustrestoreautocommit\",{\"1\":{\"80\":2}}],[\"must\",{\"1\":{\"27\":1}}],[\"min\",{\"1\":{\"10\":1}}],[\"misc\",{\"1\":{\"10\":1}}],[\"manual\",{\"1\":{\"80\":2}}],[\"mac\",{\"1\":{\"51\":1}}],[\"machine\",{\"1\":{\"50\":1}}],[\"math\",{\"1\":{\"10\":1}}],[\"maxmetaspacesize\",{\"1\":{\"62\":1}}],[\"maxpermsize\",{\"1\":{\"62\":1}}],[\"maxnewsize\",{\"1\":{\"62\":1}}],[\"max\",{\"1\":{\"10\":2,\"27\":2}}],[\"maximum\",{\"1\":{\"10\":3,\"27\":4}}],[\"mapping\",{\"1\":{\"24\":1}}],[\"map\",{\"1\":{\"2\":2,\"3\":1,\"4\":2,\"23\":1}}],[\"当连接默认为自动提交时\",{\"1\":{\"80\":1}}],[\"当服务端接收\",{\"1\":{\"77\":1}}],[\"当存在多个事务同步且有顺序要去时可指定\",{\"1\":{\"70\":1}}],[\"当存值时若元素数量大于阈值threshold则进行扩容\",{\"1\":{\"14\":1}}],[\"当线程请求栈深度超出虚拟机栈所允许的深度时抛出\",{\"1\":{\"56\":1}}],[\"当线程一恢复运行后\",{\"1\":{\"19\":1}}],[\"当然了\",{\"1\":{\"60\":1}}],[\"当然本篇并不算全面细致的讲解\",{\"1\":{\"44\":1}}],[\"当然\",{\"1\":{\"43\":1}}],[\"当程序中需要使用某个\",{\"1\":{\"42\":1}}],[\"当一个类加载器负责加载某个\",{\"1\":{\"42\":1}}],[\"当一个类加载器收到类加载任务\",{\"1\":{\"42\":1}}],[\"当有了直接引用\",{\"1\":{\"39\":1}}],[\"当节点不存在则新增\",{\"1\":{\"24\":1}}],[\"当节点数量达到\",{\"1\":{\"21\":1}}],[\"当链表节点数量\",{\"1\":{\"24\":1}}],[\"当链表节点数量大于等于\",{\"1\":{\"21\":1}}],[\"当发生哈希碰撞时\",{\"1\":{\"21\":1}}],[\"当碰撞频率高时\",{\"1\":{\"20\":1}}],[\"当通过put\",{\"1\":{\"14\":1}}],[\"当\",{\"1\":{\"5\":1,\"56\":1,\"77\":1}}],[\"当前节点的前一节点\",{\"1\":{\"23\":1}}],[\"当前\",{\"1\":{\"4\":1}}],[\"阈值大小计算为\",{\"1\":{\"5\":1}}],[\"阈值\",{\"1\":{\"5\":2}}],[\"lindholm\",{\"1\":{\"64\":1}}],[\"linux\",{\"1\":{\"51\":1}}],[\"linkageerror\",{\"1\":{\"33\":1}}],[\"linkedhashmap\",{\"1\":{\"2\":1,\"23\":2}}],[\"lib\",{\"1\":{\"41\":2}}],[\"lang\",{\"1\":{\"33\":1,\"35\":1}}],[\"left\",{\"1\":{\"23\":1}}],[\"length\",{\"1\":{\"8\":5,\"9\":1,\"10\":2,\"19\":1,\"24\":2,\"25\":1,\"27\":1}}],[\"lowest\",{\"1\":{\"70\":1}}],[\"local\",{\"1\":{\"58\":1}}],[\"lotail\",{\"1\":{\"27\":7}}],[\"lohead\",{\"1\":{\"27\":4}}],[\"loadclass\",{\"1\":{\"43\":3}}],[\"load\",{\"1\":{\"27\":1}}],[\"loadfactor\",{\"1\":{\"5\":2,\"10\":1,\"27\":1}}],[\"logger\",{\"1\":{\"80\":7}}],[\"log\",{\"1\":{\"20\":1,\"21\":1}}],[\"f\",{\"1\":{\"77\":11}}],[\"flush\",{\"1\":{\"70\":1}}],[\"float\",{\"1\":{\"5\":1,\"27\":3}}],[\"frank\",{\"1\":{\"64\":1}}],[\"framework\",{\"0\":{\"87\":1}}],[\"frame\",{\"0\":{\"55\":1},\"1\":{\"54\":1}}],[\"from\",{\"1\":{\"27\":1,\"58\":1,\"80\":1}}],[\"ft\",{\"1\":{\"27\":3}}],[\"fail\",{\"1\":{\"77\":1}}],[\"fallbackexecution\",{\"1\":{\"73\":1}}],[\"false\",{\"1\":{\"24\":2,\"40\":1,\"73\":1,\"80\":2}}],[\"factor\",{\"1\":{\"27\":1}}],[\"field\",{\"1\":{\"27\":1,\"39\":1}}],[\"first\",{\"1\":{\"25\":9}}],[\"final\",{\"1\":{\"4\":1,\"5\":2,\"9\":1,\"21\":2,\"23\":3,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"38\":1,\"61\":1}}],[\"forname\",{\"1\":{\"40\":2}}],[\"for\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"19\":1,\"24\":3,\"27\":2,\"80\":2}}],[\"switching\",{\"1\":{\"80\":1}}],[\"switch\",{\"1\":{\"80\":1}}],[\"so\",{\"1\":{\"80\":1}}],[\"some\",{\"1\":{\"80\":1}}],[\"something\",{\"1\":{\"79\":2}}],[\"source\",{\"1\":{\"73\":3}}],[\"save\",{\"1\":{\"72\":1,\"73\":1}}],[\"same\",{\"1\":{\"27\":1}}],[\"system\",{\"1\":{\"72\":4,\"73\":1}}],[\"synchronize同步锁\",{\"1\":{\"12\":1}}],[\"spel\",{\"1\":{\"73\":1}}],[\"spring\",{\"0\":{\"68\":1,\"86\":1},\"1\":{\"77\":1,\"80\":5,\"81\":1},\"2\":{\"82\":1,\"83\":1}}],[\"split\",{\"1\":{\"27\":3}}],[\"string\",{\"1\":{\"61\":1,\"72\":2,\"73\":1}}],[\"status\",{\"1\":{\"70\":1,\"72\":2}}],[\"static\",{\"1\":{\"4\":1,\"5\":1,\"8\":1,\"21\":2,\"23\":3,\"26\":1,\"38\":2}}],[\"stackoverflowerror\",{\"1\":{\"56\":1,\"57\":1}}],[\"stack\",{\"0\":{\"55\":1}}],[\"stay\",{\"1\":{\"27\":1}}],[\"servivor\",{\"1\":{\"58\":2}}],[\"setautocommit\",{\"1\":{\"80\":2}}],[\"setmustrestoreautocommit\",{\"1\":{\"80\":1}}],[\"setreadonly\",{\"1\":{\"80\":1}}],[\"setpreviousisolationlevel\",{\"1\":{\"80\":1}}],[\"setsynchronizedwithtransaction\",{\"1\":{\"80\":1}}],[\"setconnectionholder\",{\"1\":{\"80\":1}}],[\"set>\",{\"1\":{\"6\":1}}],[\"set\",{\"1\":{\"6\":3,\"80\":1}}],[\"signifies\",{\"1\":{\"27\":1}}],[\"size++\",{\"1\":{\"8\":1}}],[\"size\",{\"1\":{\"5\":1,\"6\":1,\"8\":1,\"27\":1}}],[\"success\",{\"1\":{\"77\":1}}],[\"suspend\",{\"1\":{\"70\":1}}],[\"suppresswarnings\",{\"1\":{\"27\":1}}],[\"super\",{\"1\":{\"23\":2,\"73\":1}}],[\"sun\",{\"1\":{\"10\":1,\"60\":1}}],[\"t\",{\"1\":{\"80\":1}}],[\"type\",{\"1\":{\"73\":1}}],[\"txobject\",{\"1\":{\"80\":16}}],[\"txsyncevent\",{\"1\":{\"73\":4}}],[\"txsyncdemo\",{\"1\":{\"72\":3,\"73\":1}}],[\"txdemo\",{\"1\":{\"72\":2,\"73\":2}}],[\"txcontroller\",{\"1\":{\"72\":1,\"73\":1}}],[\"txname\",{\"1\":{\"72\":5}}],[\"tim\",{\"1\":{\"64\":1}}],[\"tlab\",{\"1\":{\"58\":2}}],[\"to\",{\"1\":{\"58\":1,\"80\":4}}],[\"tomcat\",{\"1\":{\"43\":1,\"62\":1}}],[\"test\",{\"1\":{\"40\":2}}],[\"two\",{\"1\":{\"27\":2}}],[\"target\",{\"1\":{\"27\":1,\"73\":1,\"77\":3}}],[\"tab\",{\"1\":{\"24\":8,\"25\":4}}],[\"table\",{\"1\":{\"5\":1,\"8\":7,\"9\":2,\"10\":3,\"19\":1,\"24\":3,\"25\":1,\"27\":4}}],[\"throwable\",{\"1\":{\"80\":2}}],[\"thread\",{\"1\":{\"58\":1,\"80\":1}}],[\"threshold\",{\"1\":{\"5\":2,\"8\":1,\"10\":3,\"21\":2,\"24\":3,\"27\":8}}],[\"the\",{\"1\":{\"27\":2,\"80\":3}}],[\"this\",{\"1\":{\"8\":1,\"23\":4,\"24\":1,\"27\":1,\"72\":1,\"80\":2}}],[\"try\",{\"1\":{\"80\":2}}],[\"true\",{\"1\":{\"24\":2,\"73\":1,\"80\":5}}],[\"treenode\",{\"1\":{\"23\":1,\"24\":1,\"25\":1,\"27\":2}}],[\"treenode<k\",{\"0\":{\"23\":1},\"1\":{\"23\":6,\"24\":1,\"25\":1,\"27\":1}}],[\"treeifybin\",{\"1\":{\"24\":1}}],[\"treeify\",{\"1\":{\"21\":1,\"24\":1}}],[\"treemap\",{\"1\":{\"2\":1}}],[\"transactiondefinition\",{\"1\":{\"80\":1}}],[\"transaction\",{\"1\":{\"80\":6},\"2\":{\"83\":1}}],[\"transactionphase\",{\"1\":{\"73\":3,\"79\":1}}],[\"transactionaleventlistener注解classes属性是否有指定值分情况说明\",{\"1\":{\"75\":1}}],[\"transactionaleventlistener\",{\"1\":{\"73\":2,\"79\":1}}],[\"transactionaleventlistener与applicationevent事件对象两者搭配使用\",{\"1\":{\"73\":1}}],[\"transactional\",{\"1\":{\"72\":1,\"73\":1}}],[\"transactional注解方法来完成事务操作\",{\"1\":{\"69\":1}}],[\"transactionsynchronizationmanager\",{\"1\":{\"72\":1,\"80\":1}}],[\"transactionsynchronization\",{\"1\":{\"70\":1}}],[\"transactionsynchronizationadapter\",{\"1\":{\"70\":1,\"72\":1}}],[\"transfer\",{\"0\":{\"10\":1},\"1\":{\"10\":2,\"18\":1,\"19\":1}}],[\"transient\",{\"1\":{\"5\":3}}],[\"并通过注解属性指定回调时的事务阶段和感兴趣的事件\",{\"1\":{\"73\":1}}],[\"并可通过ordered接口控制多个事务同步的执行顺序\",{\"1\":{\"70\":1}}],[\"并分享给别人\",{\"1\":{\"65\":1}}],[\"并不需要像\",{\"1\":{\"52\":1}}],[\"并理解类加载器的执行机制\",{\"1\":{\"44\":1}}],[\"并重写其\",{\"1\":{\"43\":1}}],[\"并重新计算阈值\",{\"1\":{\"10\":1}}],[\"并在准备阶段赋值为\",{\"1\":{\"38\":1}}],[\"并初始化类变量的值\",{\"1\":{\"38\":1}}],[\"并将其转换成\",{\"1\":{\"42\":1}}],[\"并将其初始化为默认值\",{\"0\":{\"38\":1}}],[\"并将key\",{\"1\":{\"14\":1}}],[\"并提供了访问方法区内的数据结构的接口\",{\"1\":{\"33\":1}}],[\"并判断节点在新数组的位置\",{\"1\":{\"27\":1}}],[\"并含有before\",{\"1\":{\"23\":1}}],[\"并且利用事务同步功能\",{\"1\":{\"81\":1}}],[\"并且得等到清理资源时才提交\",{\"1\":{\"78\":1}}],[\"并且至少得等到下一次有用户对\",{\"1\":{\"77\":1}}],[\"并且类的元数据放入本地内存\",{\"1\":{\"60\":1}}],[\"并且堆也无法再扩展时抛出\",{\"1\":{\"59\":1}}],[\"并且该内存区域是唯一一个在虚拟机中没有规定任何\",{\"1\":{\"53\":1}}],[\"并且\",{\"1\":{\"29\":1,\"40\":1,\"58\":1}}],[\"并且在扩容方法的\",{\"1\":{\"19\":1}}],[\"并且死链情况在\",{\"1\":{\"13\":1}}],[\"并发扩容出现死链\",{\"1\":{\"19\":1}}],[\"并发情况下\",{\"1\":{\"13\":1}}],[\"并解决了死链问题\",{\"1\":{\"18\":1}}],[\"并保存了下一个entry<k\",{\"1\":{\"4\":1}}],[\"并采用\",{\"1\":{\"3\":1}}],[\"这个变量后面恢复连接自动提交时会用到\",{\"1\":{\"80\":1}}],[\"这个过程走下来\",{\"1\":{\"41\":1}}],[\"这个过程称为\",{\"1\":{\"10\":1}}],[\"这对于我个人的知识总结能力也大有脾益\",{\"1\":{\"65\":1}}],[\"这是因为\",{\"1\":{\"60\":1}}],[\"这是连接的第一步\",{\"1\":{\"37\":1}}],[\"这就是为什么修改了\",{\"1\":{\"42\":1}}],[\"这就导致\",{\"1\":{\"26\":1}}],[\"这就导致了并发扩容时\",{\"1\":{\"19\":1}}],[\"这一步从数据库连接池里获取连接\",{\"1\":{\"80\":1}}],[\"这一步开发者可以控制外\",{\"1\":{\"41\":1}}],[\"这一步后\",{\"1\":{\"41\":1}}],[\"这一步主要是在方法区中为类变量分配内存\",{\"1\":{\"38\":1}}],[\"这一篇\",{\"1\":{\"32\":1}}],[\"这才有了转换的必要\",{\"1\":{\"21\":1}}],[\"这两个方法在\",{\"1\":{\"76\":1}}],[\"这两个方法主要是数组扩容和数据复制\",{\"1\":{\"10\":1}}],[\"这两步获取元素的时间复杂度为\",{\"1\":{\"20\":1}}],[\"这样子的好处是保证了使用不同的类加载器最终得到的都是同样一个\",{\"1\":{\"42\":1}}],[\"这样就避免了死链问题\",{\"1\":{\"19\":1}}],[\"这样在扩容时就不会出现元素逆序的情况\",{\"1\":{\"19\":1}}],[\"这篇里讲解的非常清楚\",{\"1\":{\"13\":1}}],[\"这里是从连接池获取连接的操作\",{\"1\":{\"80\":1}}],[\"这里就不多赘述\",{\"1\":{\"10\":1}}],[\"这里需要注意\",{\"1\":{\"4\":1}}],[\"这也是为什么\",{\"1\":{\"4\":1}}],[\"==\",{\"1\":{\"8\":3,\"9\":5,\"10\":2,\"19\":1,\"24\":9,\"25\":5,\"26\":1,\"27\":6}}],[\"=\",{\"1\":{\"4\":4,\"5\":1,\"8\":14,\"9\":7,\"10\":16,\"19\":8,\"21\":2,\"23\":4,\"24\":20,\"25\":14,\"26\":1,\"27\":43,\"38\":2,\"72\":2,\"73\":7,\"79\":2,\"80\":6}}],[\"not\",{\"1\":{\"80\":1}}],[\"node\",{\"1\":{\"23\":1,\"25\":1,\"27\":1}}],[\"node<k\",{\"0\":{\"23\":1},\"1\":{\"23\":8,\"24\":3,\"25\":4,\"27\":8}}],[\"native\",{\"1\":{\"53\":1,\"54\":1,\"57\":1}}],[\"npe\",{\"1\":{\"12\":1}}],[\"necessary\",{\"1\":{\"80\":1}}],[\"netty\",{\"1\":{\"77\":2}}],[\"newcon\",{\"1\":{\"80\":3}}],[\"newcap\",{\"1\":{\"27\":8}}],[\"newcapacity\",{\"1\":{\"10\":6,\"19\":2}}],[\"newsize\",{\"1\":{\"62\":1}}],[\"newinstance\",{\"1\":{\"33\":1}}],[\"newtab\",{\"1\":{\"27\":7}}],[\"newtable\",{\"1\":{\"10\":7,\"19\":4}}],[\"newthr\",{\"1\":{\"27\":6}}],[\"newnode\",{\"1\":{\"24\":2}}],[\"new\",{\"1\":{\"8\":1,\"10\":1,\"27\":2,\"40\":1,\"72\":1,\"73\":1,\"80\":1}}],[\"next\",{\"1\":{\"4\":3,\"8\":1,\"9\":1,\"10\":5,\"13\":2,\"19\":5,\"23\":8,\"24\":4,\"25\":2,\"27\":9}}],[\"null\",{\"1\":{\"8\":7,\"9\":11,\"10\":2,\"12\":1,\"19\":2,\"24\":10,\"25\":9,\"26\":1,\"27\":17,\"80\":1}}],[\"n\",{\"1\":{\"4\":2,\"20\":4,\"24\":4,\"25\":3,\"26\":3,\"27\":4}}],[\"构造函数\",{\"1\":{\"4\":1}}],[\"值与旧数组长度\",{\"1\":{\"27\":1}}],[\"值跟原数组长度\",{\"1\":{\"27\":1}}],[\"值找到数组下标\",{\"1\":{\"25\":1}}],[\"值并通过该值确定数组下标位置\",{\"1\":{\"8\":1}}],[\"值是否相同且不为\",{\"1\":{\"9\":1}}],[\"值是否相同\",{\"1\":{\"8\":1}}],[\"值和\",{\"1\":{\"8\":1,\"9\":1,\"24\":1}}],[\"值计算数组下标\",{\"1\":{\"8\":1}}],[\"值\",{\"1\":{\"4\":1,\"8\":1,\"9\":1,\"20\":1,\"24\":2,\"27\":1}}],[\"it\",{\"1\":{\"80\":2}}],[\"im\",{\"1\":{\"77\":1}}],[\"implements\",{\"1\":{\"4\":1,\"23\":1,\"70\":1}}],[\"idea\",{\"1\":{\"62\":1}}],[\"ide\",{\"1\":{\"54\":1,\"62\":1}}],[\"ismustrestoreautocommit\",{\"1\":{\"80\":1}}],[\"isnewconnectionholder\",{\"1\":{\"80\":2}}],[\"is\",{\"1\":{\"80\":1}}],[\"isreadonly\",{\"1\":{\"80\":2}}],[\"isdebugenabled\",{\"1\":{\"80\":3}}],[\"issynchronizedwithtransaction\",{\"1\":{\"80\":1}}],[\"isassignableform\",{\"1\":{\"79\":1}}],[\"isactualtransactionactive\",{\"1\":{\"76\":1}}],[\"isbooted\",{\"1\":{\"10\":1}}],[\"isempty\",{\"1\":{\"6\":1}}],[\"i\",{\"1\":{\"8\":3,\"10\":3,\"19\":3,\"24\":3}}],[\"if\",{\"1\":{\"8\":3,\"9\":2,\"10\":2,\"19\":1,\"24\":10,\"25\":5,\"27\":15,\"79\":3,\"80\":11}}],[\"info\",{\"1\":{\"39\":3}}],[\"in\",{\"1\":{\"27\":4,\"80\":1}}],[\"instanceof\",{\"1\":{\"24\":1,\"25\":1,\"27\":1,\"79\":2}}],[\"index\",{\"1\":{\"8\":1,\"20\":1,\"27\":2}}],[\"indexfor\",{\"1\":{\"8\":3,\"9\":2,\"10\":1,\"19\":1}}],[\"initializes\",{\"1\":{\"27\":1}}],[\"initial\",{\"1\":{\"5\":1,\"27\":6}}],[\"interface\",{\"1\":{\"73\":1}}],[\"intern\",{\"1\":{\"61\":1}}],[\"integer\",{\"1\":{\"10\":2,\"27\":2,\"80\":1}}],[\"int\",{\"1\":{\"4\":2,\"5\":4,\"6\":1,\"8\":9,\"9\":1,\"10\":5,\"19\":2,\"21\":2,\"23\":4,\"24\":3,\"25\":2,\"26\":2,\"27\":6,\"38\":2,\"70\":2,\"72\":1}}],[\"keyset\",{\"1\":{\"6\":1}}],[\"key\",{\"1\":{\"4\":2,\"6\":4,\"8\":17,\"9\":13,\"10\":2,\"12\":2,\"14\":1,\"19\":2,\"23\":9,\"24\":18,\"25\":13,\"26\":4}}],[\"key唯一\",{\"1\":{\"3\":1}}],[\"k\",{\"1\":{\"4\":4,\"6\":1,\"8\":6,\"9\":3,\"23\":4,\"24\":9,\"25\":7}}],[\"catch\",{\"1\":{\"80\":2}}],[\"capacity也就是构建\",{\"1\":{\"5\":1}}],[\"capacity\",{\"1\":{\"5\":2,\"10\":3,\"27\":9}}],[\"channel\",{\"1\":{\"77\":1}}],[\"check\",{\"1\":{\"25\":1}}],[\"c++\",{\"1\":{\"52\":1}}],[\"could\",{\"1\":{\"80\":1}}],[\"collection\",{\"1\":{\"58\":1}}],[\"component\",{\"1\":{\"73\":1}}],[\"commit\",{\"1\":{\"73\":2,\"79\":1,\"80\":2}}],[\"com\",{\"1\":{\"40\":1}}],[\"configured\",{\"1\":{\"80\":1}}],[\"con\",{\"1\":{\"80\":11}}],[\"connectionholder\",{\"1\":{\"80\":2}}],[\"connection\",{\"1\":{\"80\":10}}],[\"constant\",{\"1\":{\"39\":3}}],[\"constantvalue\",{\"1\":{\"38\":1}}],[\"condition\",{\"1\":{\"13\":1,\"73\":1}}],[\"concurrenthashmap\",{\"1\":{\"12\":1}}],[\"containsvalue\",{\"1\":{\"6\":1}}],[\"containskey\",{\"1\":{\"6\":1}}],[\"continue\",{\"1\":{\"0\":1}}],[\"c\",{\"1\":{\"19\":3,\"52\":1}}],[\"createentry\",{\"1\":{\"8\":2}}],[\"clear\",{\"1\":{\"6\":1,\"80\":1}}],[\"classes指定多个值时\",{\"1\":{\"75\":1}}],[\"classes\",{\"1\":{\"73\":4,\"79\":1}}],[\"classpath\",{\"1\":{\"41\":1}}],[\"classloader\",{\"1\":{\"41\":3,\"43\":1}}],[\"class文件缺失或存在错误\",{\"1\":{\"33\":1}}],[\"class对象\",{\"1\":{\"33\":1}}],[\"class\",{\"1\":{\"4\":1,\"23\":3,\"33\":3,\"35\":1,\"37\":2,\"39\":2,\"40\":2,\"42\":8,\"50\":1,\"60\":1,\"61\":1,\"70\":1,\"72\":3,\"73\":9,\"75\":2,\"79\":2}}],[\"类和接口的全限定名\",{\"1\":{\"61\":1}}],[\"类初始化其实是执行类构造器方法的过程\",{\"1\":{\"40\":1}}],[\"类方法\",{\"1\":{\"39\":1}}],[\"类的\",{\"1\":{\"61\":1}}],[\"类的数据全部都存放在\",{\"1\":{\"33\":1}}],[\"类的加载机制\",{\"1\":{\"51\":1}}],[\"类的加载过程\",{\"0\":{\"34\":1}}],[\"类的加载的最终结果是位于堆区中的\",{\"1\":{\"33\":1}}],[\"类的加载指的是将类的\",{\"1\":{\"33\":1}}],[\"类加载经过\",{\"1\":{\"41\":1}}],[\"类加载过程\",{\"1\":{\"34\":1}}],[\"类加载主要经历五个部分\",{\"1\":{\"34\":1}}],[\"类加载器先从缓存区寻找该\",{\"1\":{\"42\":1}}],[\"类加载器\",{\"0\":{\"41\":1},\"1\":{\"35\":1,\"41\":1}}],[\"类加载器必须在程序首次主动使用该类时才报告错误\",{\"1\":{\"33\":1}}],[\"类加载器并不需要等到某个类被\",{\"1\":{\"33\":1}}],[\"类加载完毕后\",{\"1\":{\"33\":1}}],[\"类加载\",{\"1\":{\"33\":1}}],[\"类加载机制\",{\"0\":{\"32\":1},\"1\":{\"32\":1,\"33\":1,\"44\":1}}],[\"类中对它有一个静态实现\",{\"1\":{\"4\":1}}],[\"类图\",{\"1\":{\"3\":1}}],[\"类图如下\",{\"1\":{\"3\":1}}],[\"键值对\",{\"1\":{\"4\":1}}],[\"本质上是为了保证一次业务请求处理过程中涉及多次\",{\"1\":{\"69\":1}}],[\"本质上是一个映射\",{\"1\":{\"4\":1}}],[\"本地方法栈是为\",{\"1\":{\"57\":1}}],[\"本地方法栈的作用其实与虚拟机栈类似\",{\"1\":{\"57\":1}}],[\"本地方法栈\",{\"0\":{\"57\":1},\"1\":{\"52\":1}}],[\"本篇是我第一次编写的博客文章\",{\"1\":{\"65\":1}}],[\"本篇主要说明\",{\"1\":{\"63\":1}}],[\"本篇主要讲解\",{\"1\":{\"44\":1}}],[\"本篇着重于\",{\"1\":{\"51\":1}}],[\"本篇\",{\"1\":{\"2\":1}}],[\"而偏偏这个操作\",{\"1\":{\"80\":1}}],[\"而发布\",{\"1\":{\"75\":1}}],[\"而本篇主要讲述的事务功能是实现在事务执行的某个阶段去做某些事\",{\"1\":{\"69\":1}}],[\"而本篇的主角是\",{\"1\":{\"2\":1}}],[\"而了解\",{\"1\":{\"63\":1}}],[\"而老年代则是存放生命周期或存活时间较长的对象\",{\"1\":{\"58\":1}}],[\"而虚拟机栈是为\",{\"1\":{\"57\":1}}],[\"而分支\",{\"1\":{\"53\":1}}],[\"而创建\",{\"1\":{\"52\":2}}],[\"而是使用本地内存\",{\"1\":{\"60\":1}}],[\"而是栈内存\",{\"1\":{\"58\":1}}],[\"而是全权交由\",{\"1\":{\"52\":1}}],[\"而是通过\",{\"1\":{\"51\":1}}],[\"而自定义实现类加载器的有\",{\"1\":{\"43\":1}}],[\"而类加载器存在以下机制\",{\"1\":{\"42\":1}}],[\"而控制加载过程\",{\"1\":{\"41\":1}}],[\"而子类不会初始化\",{\"1\":{\"40\":1}}],[\"而初始化只有在对类的主动使用时才会触发\",{\"1\":{\"40\":1}}],[\"而不是\",{\"1\":{\"38\":1}}],[\"而不是通过key确定数组下标后直接存放值\",{\"1\":{\"4\":1}}],[\"而且很多知识点都是零零散散\",{\"1\":{\"65\":1}}],[\"而且这一步也是可控的\",{\"1\":{\"35\":1}}],[\"而且对不了解红黑树的读者会很不友好\",{\"1\":{\"28\":1}}],[\"而这一阶段也就会在堆区生成一个\",{\"1\":{\"35\":1}}],[\"而这些改变对\",{\"1\":{\"29\":1}}],[\"而红黑树相关的内容\",{\"1\":{\"28\":1}}],[\"而红黑树是一种自平衡的二叉查找树\",{\"1\":{\"20\":1}}],[\"而进入该类\",{\"1\":{\"23\":1}}],[\"而选择\",{\"1\":{\"21\":1}}],[\"而链表则为\",{\"1\":{\"21\":1}}],[\"而链表则是单向的\",{\"1\":{\"4\":1}}],[\"而一旦节点数量小于等于\",{\"1\":{\"21\":1}}],[\"而在\",{\"1\":{\"19\":1}}],[\"而线程二直接完成了扩容操作\",{\"1\":{\"19\":1}}],[\"而\",{\"1\":{\"13\":1,\"60\":1}}],[\"而此时\",{\"1\":{\"13\":1}}],[\"而它之所以是线程安全\",{\"1\":{\"12\":1}}],[\"的连接\",{\"1\":{\"80\":1}}],[\"的事务机制有关\",{\"1\":{\"80\":1}}],[\"的事务未提交\",{\"1\":{\"77\":1}}],[\"的添加好友请求已处理完毕\",{\"1\":{\"77\":1}}],[\"的缓存删了等于没删\",{\"1\":{\"77\":1}}],[\"的视角来看\",{\"1\":{\"77\":1}}],[\"的请求处理完成\",{\"1\":{\"77\":1}}],[\"的查询请求\",{\"1\":{\"77\":1}}],[\"的常量值等\",{\"1\":{\"61\":1}}],[\"的设计团队选择把\",{\"1\":{\"60\":1}}],[\"的设值\",{\"1\":{\"10\":1}}],[\"的重点照顾对象\",{\"1\":{\"58\":1}}],[\"的效果\",{\"1\":{\"51\":1}}],[\"的缩写\",{\"1\":{\"50\":1}}],[\"的类\",{\"1\":{\"41\":1}}],[\"的方式\",{\"1\":{\"40\":1}}],[\"的方法区\",{\"1\":{\"33\":1}}],[\"的内容一直都是仅凭记忆\",{\"1\":{\"65\":1}}],[\"的内存模型\",{\"1\":{\"32\":1}}],[\"的内部接口\",{\"1\":{\"4\":1}}],[\"的性能提升一文中含有性能测试的结果\",{\"1\":{\"29\":1}}],[\"的原理解析\",{\"1\":{\"28\":1}}],[\"的哈希值进行\",{\"1\":{\"26\":1}}],[\"的构造方法\",{\"1\":{\"23\":1}}],[\"的实现\",{\"1\":{\"23\":1}}],[\"的下一节点又变成\",{\"1\":{\"19\":1}}],[\"的几个方法\",{\"1\":{\"18\":1}}],[\"的改变\",{\"0\":{\"17\":1}}],[\"的工作原理\",{\"1\":{\"14\":1}}],[\"的结构就变为了\",{\"1\":{\"13\":1}}],[\"的key不能为空\",{\"1\":{\"12\":1}}],[\"的区别\",{\"0\":{\"12\":1}}],[\"的table变量\",{\"1\":{\"10\":1}}],[\"的一半减1\",{\"1\":{\"10\":1}}],[\"的值为\",{\"1\":{\"10\":1}}],[\"的元素\",{\"1\":{\"9\":2}}],[\"的元素数量\",{\"1\":{\"6\":1}}],[\"的位置\",{\"1\":{\"8\":2}}],[\"的大小以便存放更多的元素\",{\"1\":{\"5\":1}}],[\"的size超过阈值\",{\"1\":{\"5\":1}}],[\"的默认初始容量\",{\"1\":{\"5\":1}}],[\"的幂次方\",{\"1\":{\"5\":1}}],[\"的底层结构是\",{\"1\":{\"4\":1}}],[\"的\",{\"1\":{\"3\":1,\"8\":1,\"9\":1,\"13\":3,\"18\":1,\"24\":1,\"26\":2,\"77\":3}}],[\"的源码和原理讲解全部基于\",{\"1\":{\"2\":1}}],[\"是在执行事务回调完成后\",{\"1\":{\"80\":1}}],[\"是跟\",{\"1\":{\"80\":1}}],[\"是如何管理内存\",{\"1\":{\"63\":1}}],[\"是如何处理并正确使用\",{\"1\":{\"44\":1}}],[\"是回退到方法执行前的原因了吧\",{\"1\":{\"54\":1}}],[\"是描述\",{\"1\":{\"54\":1}}],[\"是当前线程所执行的字节码的行号指示器\",{\"1\":{\"53\":1}}],[\"是通过\",{\"1\":{\"51\":1}}],[\"是通过计算key的hash值来确定数组下标位置\",{\"1\":{\"4\":1}}],[\"是一道必须攻破的关卡\",{\"1\":{\"63\":1}}],[\"是一门可跨平台的语言\",{\"1\":{\"51\":1}}],[\"是一种用于计算设备的规范\",{\"1\":{\"50\":1}}],[\"是一个key\",{\"1\":{\"2\":1}}],[\"是则调用puttreeval\",{\"1\":{\"24\":1}}],[\"是假设当链表长度大于小于\",{\"1\":{\"21\":1}}],[\"是将索引下标处的链表节点全部遍历获取后\",{\"1\":{\"19\":1}}],[\"是因为put\",{\"1\":{\"12\":1}}],[\"是否相同\",{\"1\":{\"24\":1}}],[\"是否\",{\"1\":{\"9\":1}}],[\"是否为红色节点\",{\"1\":{\"23\":1}}],[\"是否为\",{\"1\":{\"8\":1}}],[\"是否为空\",{\"1\":{\"6\":1,\"24\":1}}],[\"是\",{\"1\":{\"4\":1,\"10\":1,\"50\":1,\"58\":1}}],[\"是作为\",{\"1\":{\"4\":1}}],[\"是基于哈希表\",{\"1\":{\"3\":1}}],[\"75\",{\"1\":{\"5\":1}}],[\"7\",{\"1\":{\"2\":1,\"18\":1,\"19\":2,\"21\":1,\"24\":2}}],[\"等同于classes指定了该事件\",{\"1\":{\"75\":1}}],[\"等来配置\",{\"1\":{\"62\":1}}],[\"等\",{\"1\":{\"2\":1,\"51\":1,\"64\":1}}],[\"ve\",{\"1\":{\"80\":1}}],[\"very\",{\"1\":{\"80\":1}}],[\"virtual\",{\"1\":{\"50\":1}}],[\"val\",{\"1\":{\"23\":2}}],[\"value的值在准备阶段会被初始化为\",{\"1\":{\"38\":1}}],[\"value的存储位置从而保证其进行数据快速存取\",{\"1\":{\"3\":1}}],[\"value是用entry<k\",{\"1\":{\"23\":1}}],[\"value作为\",{\"1\":{\"14\":1}}],[\"value封装为entry<k\",{\"1\":{\"8\":1}}],[\"value\",{\"1\":{\"4\":3,\"6\":2,\"8\":11,\"10\":2,\"23\":6,\"24\":9,\"25\":1,\"27\":2,\"38\":3,\"73\":1}}],[\"value可重复\",{\"1\":{\"3\":1}}],[\"value形式保存数据\",{\"1\":{\"3\":1}}],[\"value键值对映射的接口\",{\"1\":{\"2\":1}}],[\"vm\",{\"1\":{\"10\":1}}],[\"void\",{\"1\":{\"6\":1,\"8\":2,\"10\":2,\"19\":1,\"70\":7,\"72\":3,\"73\":2,\"79\":1,\"80\":2}}],[\"v\",{\"1\":{\"4\":4,\"6\":4,\"8\":5,\"9\":1,\"23\":4,\"24\":5,\"25\":1}}],[\"v>本身并没有直接使用到这两个属性\",{\"1\":{\"23\":1}}],[\"v>类\",{\"1\":{\"23\":2}}],[\"v>类是继承linkedhashmap\",{\"1\":{\"23\":1}}],[\"v>类型数组\",{\"1\":{\"4\":1}}],[\"v>接口\",{\"1\":{\"23\":1}}],[\"v>的\",{\"1\":{\"6\":1}}],[\"v>节点的数据\",{\"1\":{\"4\":1}}],[\"v>对象保存\",{\"1\":{\"8\":1,\"23\":1}}],[\"v>对象保存了key\",{\"1\":{\"4\":1}}],[\"v>对象数组\",{\"1\":{\"5\":1}}],[\"v>对象\",{\"1\":{\"4\":2}}],[\"v>对象的下一个entry<k\",{\"1\":{\"4\":1}}],[\"v>对象进行存储\",{\"1\":{\"4\":1}}],[\"v>\",{\"0\":{\"23\":2},\"1\":{\"4\":8,\"8\":2,\"9\":3,\"10\":2,\"12\":2,\"14\":1,\"19\":2,\"23\":19,\"24\":4,\"25\":5,\"27\":9}}],[\"vuepress\",{\"1\":{\"0\":1}}],[\"时便设置为\",{\"1\":{\"80\":1}}],[\"时便已存在\",{\"1\":{\"2\":1}}],[\"时再加载它\",{\"1\":{\"33\":1}}],[\"时\",{\"1\":{\"21\":3,\"42\":2,\"77\":1}}],[\"时指定的容量大小\",{\"1\":{\"5\":1}}],[\"时隔三年\",{\"1\":{\"0\":1}}],[\"jdbc\",{\"1\":{\"80\":5}}],[\"jdk\",{\"1\":{\"19\":1,\"60\":2,\"62\":4}}],[\"jdk1\",{\"1\":{\"2\":2,\"18\":1}}],[\"jit\",{\"1\":{\"58\":1}}],[\"jar\",{\"1\":{\"41\":1}}],[\"javadoc\",{\"1\":{\"76\":1}}],[\"java虚拟机规范\",{\"1\":{\"64\":1}}],[\"java\",{\"0\":{\"17\":1,\"84\":1},\"1\":{\"0\":1,\"2\":1,\"13\":5,\"14\":1,\"18\":2,\"19\":2,\"20\":3,\"23\":2,\"26\":1,\"29\":1,\"32\":1,\"33\":2,\"35\":2,\"37\":1,\"39\":1,\"40\":3,\"41\":3,\"43\":1,\"44\":2,\"50\":6,\"51\":4,\"52\":2,\"53\":1,\"54\":1,\"57\":1,\"58\":4,\"60\":3,\"61\":1,\"63\":2,\"64\":1},\"2\":{\"15\":1,\"16\":1,\"30\":1,\"31\":1,\"46\":1,\"47\":1,\"66\":1,\"67\":1}}],[\"jvm\",{\"0\":{\"32\":1,\"48\":1,\"49\":1,\"52\":1},\"1\":{\"32\":4,\"33\":3,\"34\":1,\"37\":1,\"40\":2,\"41\":2,\"42\":1,\"44\":2,\"50\":4,\"51\":8,\"52\":3,\"53\":1,\"56\":2,\"58\":4,\"59\":1,\"63\":4,\"64\":1,\"65\":2},\"2\":{\"47\":1,\"67\":1}}],[\"j\",{\"1\":{\"27\":7}}],[\"hasconnectionholder\",{\"1\":{\"80\":1}}],[\"hashcode\",{\"1\":{\"14\":1,\"20\":1,\"26\":2}}],[\"hashing\",{\"1\":{\"10\":1}}],[\"hash值\",{\"1\":{\"4\":1}}],[\"hash\",{\"0\":{\"26\":1},\"1\":{\"3\":1,\"4\":3,\"8\":18,\"9\":7,\"10\":5,\"19\":3,\"20\":1,\"23\":8,\"24\":14,\"25\":9,\"26\":5,\"27\":5,\"29\":1}}],[\"hashtable\",{\"0\":{\"12\":1},\"1\":{\"2\":1,\"3\":1,\"12\":3}}],[\"hashmap的死循环\",{\"1\":{\"13\":1}}],[\"hashmap\",{\"0\":{\"1\":1,\"13\":1,\"17\":1},\"1\":{\"2\":3,\"3\":2,\"4\":4,\"5\":9,\"6\":5,\"7\":1,\"8\":1,\"10\":3,\"12\":1,\"13\":5,\"14\":2,\"18\":5,\"19\":2,\"20\":2,\"21\":2,\"23\":2,\"26\":1,\"28\":2,\"29\":5},\"2\":{\"16\":1,\"31\":1}}],[\"hotspot\",{\"1\":{\"57\":1,\"60\":2}}],[\"home\",{\"1\":{\"41\":2}}],[\"holder\",{\"1\":{\"10\":1,\"80\":1}}],[\"hitail\",{\"1\":{\"27\":7}}],[\"hihead\",{\"1\":{\"27\":4}}],[\"heap\",{\"1\":{\"52\":1,\"58\":1}}],[\"held\",{\"1\":{\"27\":1}}],[\"hexo\",{\"1\":{\"0\":2}}],[\"h\",{\"1\":{\"4\":2,\"8\":2,\"26\":4}}],[\"聊聊\",{\"0\":{\"1\":1}}],[\"转向\",{\"1\":{\"0\":1}}],[\"从源码可看到事务同步作用就是在事务执行的各个阶段进行方法回调\",{\"1\":{\"70\":1}}],[\"从源码可以看出\",{\"1\":{\"4\":1}}],[\"从而实现事务的功能\",{\"1\":{\"80\":1}}],[\"从而在\",{\"1\":{\"60\":1}}],[\"从而引发\",{\"1\":{\"60\":1}}],[\"从图片我们知道\",{\"1\":{\"33\":1}}],[\"从\",{\"1\":{\"0\":1,\"77\":1}}],[\"2^16\",{\"1\":{\"26\":1}}],[\"2\",{\"1\":{\"2\":1,\"5\":1,\"8\":2,\"9\":1,\"10\":2,\"21\":1,\"24\":2,\"25\":1,\"26\":1,\"27\":9,\"40\":1,\"70\":1,\"73\":1,\"77\":4}}],[\"21\",{\"1\":{\"0\":1}}],[\"2023\",{\"1\":{\"0\":1}}],[\"2020\",{\"1\":{\"0\":2}}],[\"0001\",{\"1\":{\"27\":2}}],[\"0000\",{\"1\":{\"27\":2}}],[\"0\",{\"1\":{\"5\":1,\"8\":3,\"9\":3,\"10\":1,\"19\":1,\"24\":2,\"25\":1,\"26\":1,\"27\":12,\"38\":1,\"70\":1,\"75\":1}}],[\"09\",{\"1\":{\"0\":2}}],[\"08\",{\"1\":{\"0\":2}}],[\"07\",{\"1\":{\"0\":1}}],[\"~\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
